* Table Of Contents                                               :TOC_2_org:
- [[Emacs init.el][Emacs init.el]]
- [[Defuns][Defuns]]
  - [[lisp-defuns][lisp-defuns]]
  - [[misc-defuns][misc-defuns]]
  - [[settings][settings]]
  - [[appearance.el][appearance.el]]
  - [[sane-defaults.el][sane-defaults.el]]
  - [[setup-eshell.el][setup-eshell.el]]
  - [[setup-exwm.el][setup-exwm.el]]
  - [[setup-haskell.el][setup-haskell.el]]
  - [[setup-helm.el][setup-helm.el]]
  - [[setup-hledger.el][setup-hledger.el]]
  - [[setup-hugo.el][setup-hugo.el]]
  - [[setup-hydra.el][setup-hydra.el]]
  - [[setup-init.el][setup-init.el]]
  - [[setup-keybindings.el][setup-keybindings.el]]
  - [[setup-js2-mode.el][setup-js2-mode.el]]
  - [[setup-magit.el][setup-magit.el]]
  - [[setup-markdown.el][setup-markdown.el]]
  - [[setup-elfeed.el][setup-elfeed.el]]
  - [[setup-eshell.el][setup-eshell.el]]
  - [[setup-exwm.el][setup-exwm.el]]
  - [[setup-haskell.el][setup-haskell.el]]
  - [[setup-helm.el][setup-helm.el]]
  - [[setup-hledger.el][setup-hledger.el]]
  - [[setup-hugo.el][setup-hugo.el]]
  - [[setup-hydra.el][setup-hydra.el]]
  - [[setup-init.el][setup-init.el]]
  - [[setup-keybindings.el][setup-keybindings.el]]
  - [[setup-js2-mode.el][setup-js2-mode.el]]
  - [[setup-magit.el][setup-magit.el]]
  - [[setup-markdown.el][setup-markdown.el]]
  - [[setup-org.el][setup-org.el]]
  - [[setup-package.el][setup-package.el]]
  - [[setup-paredit.el][setup-paredit.el]]
  - [[setup-perspective.el][setup-perspective.el]]
  - [[setup-python.el][setup-python.el]]
  - [[setup-rcirc.el][setup-rcirc.el]]
  - [[setup-slime.el][setup-slime.el]]
  - [[setup-yasnippet.el][setup-yasnippet.el]]
- [[Email][Email]]
  - [[Initial setup][Initial setup]]
  - [[Password][Password]]
- [[site-lisp][site-lisp]]
- [[Xsessions settings][Xsessions settings]]
- [[GHCI][GHCI]]
* Emacs init.el
- This file should be small and quite readable. Without this, things will crush
- Set my user name and all my email address
- Really not required but \m/ \m/
- If this is not set, the init file may become really noisy.
- You can read more here: [[https://www.gnu.org/software/emacs/manual/html_node/emacs/Saving-Customizations.html][Saving customizations]]
- Any useful function that I come across in the interwebs is dumped in the
  defuns directory: ".emacs.d/defuns"
- This keeps things nice and clean
- Create custom dirs for things
- Really long.
- I use the `require` function to load packages if they haven't already been
  loaded.
- The order in which things are been loaded is important.
- Perhaps I should rethink how I've named them.

#+BEGIN_SRC emacs-lisp :padding no :tangle ~/.emacs.d/init.el :mkdirp yes :noweb yes
  ;;; init.el

(defvar user-home-directory (concat (expand-file-name "~") "/"))

;; Keep emacs Custom-settings in separate file

(let ((file-name (expand-file-name "custom.el" user-emacs-directory)))
  (when (not (file-exists-p file-name))
  (write-region "" nil file-name)))
(setq custom-file (expand-file-name "custom.el" user-emacs-directory))
(load custom-file)

;; Set up a settings dir
(defun create-directory-if-nonexistent (dir-name)
  "Create a new directory if it does not exist"
  (when (not (file-directory-p dir-name))
    (make-directory dir-name)))

(create-directory-if-nonexistent
  (expand-file-name "settings" user-emacs-directory))
(setq settings-dir
      (expand-file-name "settings" user-emacs-directory))
(add-to-list 'load-path settings-dir)

;; Set path to dependencies
(create-directory-if-nonexistent
 (expand-file-name "site-lisp" user-emacs-directory))
(setq site-lisp-dir
      (expand-file-name "site-lisp" user-emacs-directory))
(add-to-list 'load-path site-lisp-dir)

;; Set up vendor dir
(create-directory-if-nonexistent
 (expand-file-name "vendor" user-emacs-directory))
(defvar bonface/vendor-dir
  (expand-file-name "vendor" user-emacs-directory))
(add-to-list 'load-path bonface/vendor-dir)

(dolist (project (directory-files bonface/vendor-dir t "\\w+"))
  (when (file-directory-p project)
    (add-to-list 'load-path project)))

;; Write backup files to own directory
(create-directory-if-nonexistent
 (expand-file-name
  (concat user-emacs-directory "backups")))
(setq backup-directory-alist
      `(("." . ,(expand-file-name
                 (concat user-emacs-directory "backups")))))

(require 'setup-package)

(create-directory-if-nonexistent
 (expand-file-name "defuns" user-emacs-directory))
(setq defuns-dir (expand-file-name "defuns" user-emacs-directory))

(dolist (file (directory-files defuns-dir t "\\w+"))
  (when (file-regular-p file)
    (load file)))
(require 'setup-init)
(require 'sane-defaults)
(require 'setup-email)
(require 'appearance)
(require 'setup-elfeed)
(require 'setup-exwm)
(require 'setup-eshell)
(require 'setup-paredit)
(require 'setup-hledger)
(require 'setup-org)
(require 'setup-hugo)
(require 'setup-hydra)
(require 'setup-perspective)
(require 'setup-rcirc)
(require 'setup-yasnippet)
(require 'setup-slime)
(require 'setup-helm)

(eval-after-load 'org '(require 'setup-org))
(eval-after-load 'magit '(require
                          'setup-magit))
(eval-after-load 'js2-mode '(require 'setup-js2-mode))
(eval-after-load 'markdown-mode '(require 'setup-markdown))

(use-package buffer-move :ensure)
(use-package itail :ensure)
(use-package guix :ensure)
(use-package xclip :ensure
  :config
  (xclip-mode 1))

(use-package purescript-mode            ; PureScript mode
  :ensure)

;; Purescript
(use-package psci                       ; psci integration
  :ensure)
(require 'setup-keybindings)

(setq default-buffer-file-coding-system 'utf-8)
(use-package helm-swoop :ensure
  :config
  (setq helm-swoop-split-with-multiple-windows t))



(with-eval-after-load 'yasnippet
  (add-to-list 'yas-snippet-dirs "~/guix/etc/snippets"))
(load-file "~/guix/etc/copyright.el")

(use-package multi-term :ensure
  :config
  (setq multi-term-program "/home/bonface/.guix-profile/bin/zsh")
  (add-hook 'term-mode-hook
            (lambda ()
              (setq term-buffer-maximum-size 10000)))
  (defcustom term-unbind-key-list
    '("C-z" "C-x" "C-c" "C-h" "C-y" "<ESC>")
    "The key list that will need to be unbind."
    :type 'list
    :group 'multi-term)

  (defun term-send-esc ()
    "Send ESC in term mode."
    (interactive)
    (term-send-raw-string "\e"))
  
  (defcustom term-bind-key-alist
    '(
      ("C-c C-c" . term-interrupt-subjob)
      ("C-p" . previous-line)
      ("C-n" . next-line)
      ("C-s" . isearch-forward)
      ("C-r" . isearch-backward)
      ("C-m" . term-send-raw)
      ("M-f" . term-send-forward-word)
      ("M-b" . term-send-backward-word)
      ("M-o" . term-send-backspace)
      ("M-p" . term-send-up)
      ("M-n" . term-send-down)
      ("M-M" . term-send-forward-kill-word)
      ("M-N" . term-send-backward-kill-word)
      ("M-r" . term-send-reverse-search-history)
      ("M-," . term-send-input)
      ("C-c C-e" . term-send-escape)
      ("M-." . comint-dynamic-complete))
    "The key alist that will need to be bind.
  If you do not like default setup, modify it, with (KEY . COMMAND) format."
    :type 'alist
    :group 'multi-term)
  (add-hook 'term-mode-hook
            (lambda ()
              (add-to-list 'term-bind-key-alist '("M-[" . multi-term-prev))
              (add-to-list 'term-bind-key-alist '("M-]" . multi-term-next)))))

(use-package dumb-jump :ensure)
(add-hook 'xref-backend-functions #'dumb-jump-xref-activate)
  ;;; init.el ends here
#+END_SRC
* Defuns
- Most of this defuns were lifted online over time
** lisp-defuns
Really quick way to insert evaluated functions in the buffer.

#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/defuns/lisp-defuns.el
;;; lisp-defuns.el -*- lexical-binding: t; -*-
(use-package s)

(require 'recentf)

(defun create-scratch-buffer nil
  "create a new scratch buffer to work in. (could be *scratch* - *scratchX*)"
  (interactive)
  (let ((n 0)
        bufname)
    (while (progn
             (setq bufname (concat "*scratch"
                                   (if (= n 0) "" (int-to-string n))
                                   "*"))
             (setq n (1+ n))
             (get-buffer bufname)))
    (switch-to-buffer (get-buffer-create bufname))
    (emacs-lisp-mode)
    ))

(defun toggle-window-split ()
  (interactive)
  (if (= (count-windows) 2)
      (let* ((this-win-buffer (window-buffer))
             (next-win-buffer (window-buffer (next-window)))
             (this-win-edges (window-edges (selected-window)))
             (next-win-edges (window-edges (next-window)))
             (this-win-2nd (not (and (<= (car this-win-edges)
                                         (car next-win-edges))
                                     (<= (cadr this-win-edges)
                                         (cadr next-win-edges)))))
             (splitter
              (if (= (car this-win-edges)
                     (car (window-edges (next-window))))
                  'split-window-horizontally
                'split-window-vertically)))
        (delete-other-windows)
        (let ((first-win (selected-window)))
          (funcall splitter)
          (if this-win-2nd (other-window 1))
          (set-window-buffer (selected-window) this-win-buffer)
          (set-window-buffer (next-window) next-win-buffer)
          (select-window first-win)
          (if this-win-2nd (other-window 1))))))

(defun untabify-buffer ()
  "Remove tabs from the current buffer where the point is in"
  (interactive)
  (untabify (point-min) (point-max)))

(defun indent-buffer ()
  "Indent the buffer properly using 'indent-region"
  (interactive)
  (indent-region (point-min) (point-max)))

(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer.
Including indent-buffer, which should not be called automatically on save."
  (interactive)
  (untabify-buffer)
  (delete-trailing-whitespace)
  (indent-buffer))

(defun horizontal-recenter ()
  "make the point horizontally centered in the window"
  (interactive)
  (let ((mid (/ (window-width) 2))
        (line-len (save-excursion (end-of-line) (current-column)))
        (cur (current-column)))
    (if (< mid cur)
        (set-window-hscroll (selected-window)
                            (- cur mid)))))

(global-set-key (kbd "C-S-l") 'horizontal-recenter)

(defun insert-standard-date ()
  "Inserts standard date time string."
  (interactive)
  (insert (format-time-string "%c")))

(defun eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

(defun make-async-cmd (start end)
  "Wrap a command with async-shell-command"
  (interactive "r")
  (setq cmd (filter-buffer-substring start end t))
  (insert (concat "(async-shell-command \"" cmd "\" \"*" cmd "*\")")))

(defun open-line-below ()
  (interactive)
  (end-of-line)
  (newline)
  (indent-for-tab-command))

(defun open-line-above ()
  (interactive)
  (beginning-of-line)
  (newline)
  (forward-line -1)
  (indent-for-tab-command))

(defun newline-in-between ()
  (interactive)
  (newline)
  (save-excursion
    (newline)
    (indent-for-tab-command))
  (indent-for-tab-command))

(defun newline-dwim ()
  (interactive)
  (let ((break-open-pair (or (and (looking-back "{" 1) (looking-at "}"))
                             (and (looking-back ">" 1) (looking-at "<"))
                             (and (looking-back "(" 1) (looking-at ")"))
                             (and (looking-back "\\[" 1) (looking-at "\\]")))))
    (newline)
    (when break-open-pair
      (save-excursion
        (newline)
        (indent-for-tab-command)))
    (indent-for-tab-command)))

(defun duplicate-current-line-or-region (arg)
  "Duplicates the current line or region ARG times.
  If there's no region, the current line will be duplicated."
  (interactive "p")
  (if (region-active-p)
      (let ((beg (region-beginning))
            (end (region-end)))
        (duplicate-region arg beg end)
        (one-shot-keybinding "d" (λ (duplicate-region 1 beg end))))
    (duplicate-current-line arg)
    (one-shot-keybinding "d" 'duplicate-current-line)))

(defun one-shot-keybinding (key command)
  (set-temporary-overlay-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd key) command)
     map) t))

(defun replace-region-by (fn)
  (let* ((beg (region-beginning))
         (end (region-end))
         (contents (buffer-substring beg end)))
    (delete-region beg end)
    (insert (funcall fn contents))))

(defun duplicate-region (&optional num start end)
  "Duplicates the region bounded by START and END NUM times.
  If no START and END is provided, the current region-beginning and
  region-end is used."
  (interactive "p")
  (save-excursion
    (let* ((start (or start (region-beginning)))
           (end (or end (region-end)))
           (region (buffer-substring start end)))
      (goto-char end)
      (dotimes (i num)
        (insert region)))))

(defun paredit-duplicate-current-line ()
  (back-to-indentation)
  (let (kill-ring kill-ring-yank-pointer)
    (paredit-kill)
    (yank)
    (newline-and-indent)
    (yank)))

(defun duplicate-current-line (&optional num)
  "Duplicate the current line NUM times."
  (interactive "p")
  (if (bound-and-true-p paredit-mode)
      (paredit-duplicate-current-line)
    (save-excursion
      (when (eq (point-at-eol) (point-max))
        (goto-char (point-max))
        (newline)
        (forward-char -1))
      (duplicate-region num (point-at-bol) (1+ (point-at-eol))))))

;; automatically indenting yanked text if in programming-modes
(defvar yank-indent-modes '(prog-mode
                            sgml-mode
                            js2-mode)
  "Modes in which to indent regions that are yanked (or yank-popped)")

(defvar yank-advised-indent-threshold 1000
  "Threshold (# chars) over which indentation does not automatically occur.")

(defun yank-advised-indent-function (beg end)
  "Do indentation, as long as the region isn't too large."
  (if (<= (- end beg) yank-advised-indent-threshold)
      (indent-region beg end nil)))

(defadvice yank (after yank-indent activate)
  "If current mode is one of 'yank-indent-modes, indent yanked text (with prefix arg don't indent)."
  (if (and (not (ad-get-arg 0))
           (--any? (derived-mode-p it) yank-indent-modes))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning) (region-end)))))

(defadvice yank-pop (after yank-pop-indent activate)
  "If current mode is one of 'yank-indent-modes, indent yanked text (with prefix arg don't indent)."
  (if (and (not (ad-get-arg 0))
           (member major-mode yank-indent-modes))
      (let ((transient-mark-mode nil))
        (yank-advised-indent-function (region-beginning) (region-end)))))

(defun yank-unindented ()
  (interactive)
  (yank 1))

;; toggle quotes

(defun current-quotes-char ()
  (nth 3 (syntax-ppss)))

(defalias 'point-is-in-string-p 'current-quotes-char)

(defun move-point-forward-out-of-string ()
  (while (point-is-in-string-p) (forward-char)))

(defun move-point-backward-out-of-string ()
  (while (point-is-in-string-p) (backward-char)))

(defun alternate-quotes-char ()
  (if (eq ?' (current-quotes-char)) ?\" ?'))

(defun toggle-quotes ()
  (interactive)
  (if (point-is-in-string-p)
      (let ((old-quotes (char-to-string (current-quotes-char)))
            (new-quotes (char-to-string (alternate-quotes-char)))
            (start (make-marker))
            (end (make-marker)))
        (save-excursion
          (move-point-forward-out-of-string)
          (backward-delete-char 1)
          (set-marker end (point))
          (insert new-quotes)
          (move-point-backward-out-of-string)
          (delete-char 1)
          (insert new-quotes)
          (set-marker start (point))
          (replace-string new-quotes (concat "\\" new-quotes) nil start end)
          (replace-string (concat "\\" old-quotes) old-quotes nil start end)))
    (error "Point isn't in a string")))

;; kill region if active, otherwise kill backward word
(defun kill-region-or-backward-word ()
  (interactive)
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (backward-kill-word 1)))

(defun kill-to-beginning-of-line ()
  (interactive)
  (kill-region (save-excursion (beginning-of-line) (point))
               (point)))

;; copy region if active
;; otherwise copy to end of current line
;;   * with prefix, copy N whole lines
(defun copy-to-end-of-line ()
  (interactive)
  (kill-ring-save (point)
                  (line-end-position))
  (message "Copied to end of line"))

(defun copy-whole-lines (arg)
  "Copy lines (as many as prefix argument) in the kill ring"
  (interactive "p")
  (kill-ring-save (line-beginning-position)
                  (line-beginning-position (+ 1 arg)))
  (message "%d line%s copied" arg (if (= 1 arg) "" "s")))

(defun copy-line (arg)
  "Copy to end of line, or as many lines as prefix argument"
  (interactive "P")
  (if (null arg)
      (copy-to-end-of-line)
    (copy-whole-lines (prefix-numeric-value arg))))

(defun save-region-or-current-line (arg)
  (interactive "P")
  (if (region-active-p)
      (kill-ring-save (region-beginning) (region-end))
    (copy-line arg)))

(defun kill-and-retry-line ()
  "Kill the entire current line and reposition point at indentation"
  (interactive)
  (back-to-indentation)
  (kill-line))

(defun camelize-buffer ()
  (interactive)
  (goto-char 0)
  (ignore-errors
    (replace-next-underscore-with-camel 0))
  (goto-char 0))

;; kill all comments in buffer
(defun comment-kill-all ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (comment-kill (save-excursion
                    (goto-char (point-max))
                    (line-number-at-pos)))))

(defun incs (s &optional num)
  (let* ((inc (or num 1))
         (new-number (number-to-string (+ inc (string-to-number s))))
         (zero-padded? (s-starts-with? "0" s)))
    (if zero-padded?
        (s-pad-left (length s) "0" new-number)
      new-number)))

(defun goto-closest-number ()
  (interactive)
  (let ((closest-behind (save-excursion (search-backward-regexp "[0-9]" nil t)))
        (closest-ahead (save-excursion (search-forward-regexp "[0-9]" nil t))))
    (push-mark)
    (goto-char
     (cond
      ((and (not closest-ahead) (not closest-behind)) (error "No numbers in buffer"))
      ((and closest-ahead (not closest-behind)) closest-ahead)
      ((and closest-behind (not closest-ahead)) closest-behind)
      ((> (- closest-ahead (point)) (- (point) closest-behind)) closest-behind)
      ((> (- (point) closest-behind) (- closest-ahead (point))) closest-ahead)
      :else closest-ahead))))

(defun change-number-at-point (arg)
  (interactive "p")
  (unless (or (looking-at "[0-9]")
              (looking-back "[0-9]"))
    (goto-closest-number))
  (save-excursion
    (while (looking-back "[0-9]")
      (forward-char -1))
    (re-search-forward "[0-9]+" nil)
    (replace-match (incs (match-string 0) arg) nil nil)))

(defun subtract-number-at-point (arg)
  (interactive "p")
  (change-number-at-point (- arg)))

(defun replace-next-underscore-with-camel (arg)
  (interactive "p")
  (if (> arg 0)
      (setq arg (1+ arg))) ; 1-based index to get eternal loop with 0
  (let ((case-fold-search nil))
    (while (not (= arg 1))
      (search-forward-regexp "\\b_[a-z]")
      (forward-char -2)
      (delete-char 1)
      (capitalize-word 1)
      (setq arg (1- arg)))))

(defun snakeify-current-word ()
  (interactive)
  (er/mark-word)
  (let* ((beg (region-beginning))
         (end (region-end))
         (current-word (buffer-substring-no-properties beg end))
         (snakified (snake-case current-word)))
    (replace-string current-word snakified nil beg end)))

(defun kebab-current-word ()
  (interactive)
  (er/mark-word)
  (let* ((beg (region-beginning))
         (end (region-end))
         (current-word (buffer-substring-no-properties beg end))
         (kebabed (s-dashed-words current-word)))
    (replace-string current-word kebabed nil beg end)))

(defun transpose-params ()
  "Presumes that params are in the form (p, p, p) or {p, p, p} or [p, p, p]"
  (interactive)
  (let* ((end-of-first (cond
                        ((looking-at ", ") (point))
                        ((and (looking-back ",") (looking-at " ")) (- (point) 1))
                        ((looking-back ", ") (- (point) 2))
                        (t (error "Place point between params to transpose."))))
         (start-of-first (save-excursion
                           (goto-char end-of-first)
                           (move-backward-out-of-param)
                           (point)))
         (start-of-last (+ end-of-first 2))
         (end-of-last (save-excursion
                        (goto-char start-of-last)
                        (move-forward-out-of-param)
                        (point))))
    (transpose-regions start-of-first end-of-first start-of-last end-of-last)))

(defun move-forward-out-of-param ()
  (while (not (looking-at ")\\|, \\| ?}\\| ?\\]"))
    (cond
     ((point-is-in-string-p) (move-point-forward-out-of-string))
     ((looking-at "(\\|{\\|\\[") (forward-list))
     (t (forward-char)))))

(defun move-backward-out-of-param ()
  (while (not (looking-back "(\\|, \\|{ ?\\|\\[ ?"))
    (cond
     ((point-is-in-string-p) (move-point-backward-out-of-string))
     ((looking-back ")\\|}\\|\\]") (backward-list))
     (t (backward-char)))))

(autoload 'zap-up-to-char "misc"
  "Kill up to, but not including ARGth occurrence of CHAR.")

(defun css-expand-statement ()
  (interactive)
  (save-excursion
    (end-of-line)
    (search-backward "{")
    (forward-char 1)
    (let ((beg (point)))
      (newline)
      (er/mark-inside-pairs)
      (replace-regexp ";" ";\n" nil (region-beginning) (region-end))
      (indent-region beg (point)))))

(defun css-contract-statement ()
  (interactive)
  (end-of-line)
  (search-backward "{")
  (while (not (looking-at "}"))
    (join-line -1))
  (back-to-indentation))

(defun ot/ido-choose-from-recentf ()
  "Use ido to select a recently opened file from the `recentf-list'"
  (interactive)
  (let ((home (expand-file-name (getenv "HOME"))))
    (find-file
     (ido-completing-read "Recentf open: "
                          (mapcar (lambda (path)
                                    (replace-regexp-in-string home "~" path))
                                  recentf-list)
                          nil t))))

(defun ot/cider-eval-defun-or-region ()
  "Eval defun at point or region when it is active"
  (interactive)
  (if (use-region-p)
      (cider-eval-region)
    (cider-eval-defun-at-point)))

(defun ot/cider-eval-count-defun-at-point ()
  (interactive)
  (cider-interactive-eval
   (format "(count %s)"
           (cider-eval-defun-at-point))))

(defun ot/cider-nth-from-defun-at-point (n)
  (interactive "p")
  (cider-interactive-eval
   (format "(count %s %s)"
           (cider-eval-defun-at-point) n)))

(defun ot/cider-benchmark-defun-at-point ()
  (interactive)
  (cider-interactive-eval
   (format "(require 'criterium.core)
            (criterium.core/quick-benchmark %s)"
           (cider-eval-defun-at-point))))

(defun ot/goto-match-beginning ()
  (when (and isearch-forward isearch-other-end (not isearch-mode-end-hook-quit))
    (goto-char isearch-other-end)))

;; Based on Bodil Stokke's version
;; Only if you duplicate something at the start of a line it will also add a newline above
(defun ot/paredit-duplicate-after-point
    (&optional prefix)
  "Duplicates the content of the line that is after the point."
  (interactive "P")
  (if (use-region-p)
      (ot/duplicate-current-line-or-region 1)
    ;; skips to the next sexp
    (while (looking-at " ")
      (forward-char))
    (set-mark-command nil)
    ;; while we find sexps we move forward on the line
    (while (and (bounds-of-thing-at-point 'sexp)
                (<= (point) (car (bounds-of-thing-at-point 'sexp)))
                (not (= (point) (line-end-position))))
      (forward-sexp)
      (while (looking-at " ")
        (forward-char)))
    (kill-ring-save (mark) (point))
    ;; go to the next line and copy the sexprs we encountered
    (paredit-newline)
    (yank)
    (exchange-point-and-mark)
    (when prefix
      (paredit-newline))))

(defun ot/join-line ()
  (interactive)
  (join-line -1))

(defun ot/move-lines-down-from-point ()
  "Insert empty lines above the current line but move the cursor down with the rest of the text."
  (interactive)
  (save-excursion
    (move-beginning-of-line nil)
    (newline-and-indent)))

(defun ot/cider-eval-count-defun-at-point ()
  (interactive)
  (cider-interactive-eval
   (format "(count %s)"
           (cider-eval-defun-at-point))))

(defun ot/cider-nth-from-defun-at-point (n)
  (interactive "p")
  (cider-interactive-eval
   (format "(count %s %s)"
           (cider-eval-defun-at-point) n)))

(defun ot/cider-benchmark-defun-at-point ()
  (interactive)
  (cider-interactive-eval
   (format "(require 'criterium.core)
            (criterium.core/quick-benchmark %s)"
           (cider-eval-defun-at-point))))

(defun yas/popup-isearch-prompt (prompt choices &optional display-fn)
  (when (featurep 'popup)
    (popup-menu*
     (mapcar
      (lambda (choice)
        (popup-make-item
         (or (and display-fn (funcall display-fn choice))
             choice)
         :value choice))
      choices)
     :prompt prompt
     ;; start isearch mode immediately
     :isearch t
     )))

(defun ot/point-in-comment ()
  "Determine if the point is inside a comment"
  (interactive)
  (let ((syn (syntax-ppss)))
    (and (nth 8 syn)
         (not (nth 3 syn)))))

(defun ot/end-of-code-or-line+ (arg)
  "Move to the end of code. If already there, move to the end of line,
  that is after the possible comment. If at the end of line, move
  to the end of code. Comments are recognized in any mode that
  sets syntax-ppss properly."
  (interactive "P")
  (let ((eoc (save-excursion
               (move-end-of-line arg)
               (while (ot/point-in-comment)
                 (backward-char))
               (skip-chars-backward " \t")
               (point))))
    (cond ((= (point) eoc)
           (move-end-of-line arg))
          (t
           (move-end-of-line arg)
           (while (ot/point-in-comment)
             (backward-char))
           (skip-chars-backward " \t")))))

(defun ot/back-to-indentation-or-beginning ()
  (interactive)
  (if (= (point) (progn (back-to-indentation) (point)))
      (beginning-of-line)))

(defun ot/next-user-buffer ()
  "Switch to the next user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun ot/previous-user-buffer ()
  "Switch to the previous user buffer.
User buffers are those whose name does not start with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (string-match "^*" (buffer-name)) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

(defun ot/next-emacs-buffer ()
  "Switch to the next emacs buffer.
Emacs buffers are those whose name starts with *."
  (interactive)
  (next-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (next-buffer) )))

(defun ot/previous-emacs-buffer ()
  "switch to the previous emacs buffer.
emacs buffers are those whose name starts with *."
  (interactive)
  (previous-buffer)
  (let ((i 0))
    (while (and (not (string-match "^*" (buffer-name))) (< i 50))
      (setq i (1+ i)) (previous-buffer) )))

;; Navigating Clojure with Helm
(defun ot/helm-clojure-headlines ()
  "Display headlines for the current Clojure file."
  (interactive)
  (helm-mode t)
  (helm :sources '(((name . "Clojure Headlines")
                    (volatile)
                    (headline "^[(]")))))

(defun ot/indent-whole-buffer ()
  "indent whole buffer"
  (interactive)
  (delete-trailing-whitespace)
  (indent-region (point-min) (point-max) nil)
  (untabify (point-min) (point-max)))

(defun ot/esk-add-watchwords ()
  (font-lock-add-keywords
   nil '(("\\<\\(FIX\\(ME\\)?\\|TODO\\|HACK\\|REFACTOR\\|NOCOMMIT\\)"
          1 font-lock-warning-face t))))

(defun ot/esk-remove-elc-on-save ()
  "If you're saving an elisp file, likely the .elc is no longer valid."
  (make-local-variable 'after-save-hook)
  (add-hook 'after-save-hook
            (lambda ()
              (if (file-exists-p (concat buffer-file-name "c"))
                  (delete-file (concat buffer-file-name "c"))))))

(defun ot/esk-prog-mode-hook ()
  (run-hooks 'prog-mode-hook))

(defun ot/paredit--is-at-start-of-sexp ()
  (and (looking-at "(\\|\\[")
       (not (nth 3 (syntax-ppss))) ;; inside string
       (not (nth 4 (syntax-ppss))))) ;; inside comment

(defun ot/paredit-duplicate-closest-sexp ()
  (interactive)
  ;; skips to start of current sexp
  (while (not (ot/paredit--is-at-start-of-sexp))
    (paredit-backward))
  (set-mark-command nil)
  ;; while we find sexps we move forward on the line
  (while (and (bounds-of-thing-at-point 'sexp)
              (<= (point) (car (bounds-of-thing-at-point 'sexp)))
              (not (= (point) (line-end-position))))
    (forward-sexp)
    (while (looking-at " ")
      (forward-char)))
  (kill-ring-save (mark) (point))
  ;; go to the next line and copy the sexprs we encountered
  (paredit-newline)
  (yank)
  (exchange-point-and-mark))

(defun ot/paredit-wrap-round-from-behind ()
  (interactive)
  (forward-sexp -1)
  (paredit-wrap-round)
  (insert " ")
  (forward-char -1))

(defun ot/paredit-wrap-square-from-behind ()
  (interactive)
  (forward-sexp -1)
  (paredit-wrap-square))

(defun ot/paredit-wrap-curly-from-behind ()
  (interactive)
  (forward-sexp -1)
  (paredit-wrap-curly))

(defun ot/paredit-kill-region-or-backward-word ()
  (interactive)
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (paredit-backward-kill-word)))

(defun ot/rotate-windows ()
  "Rotate your windows"
  (interactive)
  (cond ((not (> (count-windows)1))
         (message "You can't rotate a single window!"))
        (t
         (setq i 1)
         (setq numWindows (count-windows))
         (while  (< i numWindows)
           (let* (
                  (w1 (elt (window-list) i))
                  (w2 (elt (window-list) (+ (% i numWindows) 1)))

                  (b1 (window-buffer w1))
                  (b2 (window-buffer w2))

                  (s1 (window-start w1))
                  (s2 (window-start w2))
                  )
             (set-window-buffer w1  b2)
             (set-window-buffer w2 b1)
             (set-window-start w1 s2)
             (set-window-start w2 s1)
             (setq i (1+ i)))))))

(defun ot/delete-current-buffer-file ()
  "Removes file connected to current buffer and kills buffer."
  (interactive)
  (let ((filename (buffer-file-name))
        (buffer (current-buffer))
        (name (buffer-name)))
    (if (not (and filename (file-exists-p filename)))
        (ido-kill-buffer)
      (when (yes-or-no-p "Are you sure you want to remove this file? ")
        (delete-file filename)
        (kill-buffer buffer)
        (message "File '%s' successfully removed" filename)))))

(defun ot/rename-current-buffer-file ()
  "Renames current buffer and file it is visiting."
  (interactive)
  (let ((name (buffer-name))
        (filename (buffer-file-name)))
    (if (not (and filename (file-exists-p filename)))
        (error "Buffer '%s' is not visiting a file!" name)
      (let ((new-name (read-file-name "New name: " filename)))
        (if (get-buffer new-name)
            (error "A buffer named '%s' already exists!" new-name)
          (rename-file filename new-name 1)
          (rename-buffer new-name)
          (set-visited-file-name new-name)
          (set-buffer-modified-p nil)
          (message "File '%s' successfully renamed to '%s'"
                   name (file-name-nondirectory new-name)))))))

(defun ot/move-line-down ()
  (interactive)
  (let ((col (current-column)))
    (save-excursion
      (forward-line)
      (transpose-lines 1))
    (forward-line)
    (move-to-column col)))

(defun ot/move-line-up ()
  (interactive)
  (let ((col (current-column)))
    (save-excursion
      (forward-line)
      (transpose-lines -1))
    (move-to-column col)))

(defun ot/open-line-below ()
  (interactive)
  (end-of-line)
  (newline)
  (indent-for-tab-command))

(defun ot/open-line-above ()
  (interactive)
  (beginning-of-line)
  (newline)
  (forward-line -1)
  (indent-for-tab-command))

(defun ot/replace-regexp-in-region (start end)
  (interactive "*r")
  (save-excursion
    (save-restriction
      (let ((regexp (read-string "Regexp: "))
            (to-string (read-string "Replacement: ")))
        (narrow-to-region start end)
        (goto-char (point-min))
        (while (re-search-forward regexp nil t)
          (replace-match to-string nil nil))))))

(defun ot/duplicate-current-line-or-region (arg)
  "Duplicates the current line or region ARG times.
If there's no region, the current line will be duplicated. However, if
there's a region, all lines that region covers will be duplicated."
  (interactive "p")
  (let (beg end (origin (point)))
    (if (and mark-active (> (point) (mark)))
        (exchange-point-and-mark))
    (setq beg (line-beginning-position))
    (if mark-active
        (exchange-point-and-mark))
    ;; Don't include the last line if a region exists and the point is at the beginning of the last line.
    (if (and mark-active (= origin (line-beginning-position)))
        (setq end (- origin 1))
      (setq end (line-end-position)))
    (let ((region (buffer-substring-no-properties beg end)))
      (dotimes (i arg)
        (goto-char end)
        (newline)
        (insert region)
        (setq end (point)))
      (goto-char (+ origin (* (length region) arg) arg)))))

(defun ot/smart-open-line ()
  "Insert an empty line after the current line.
Position the cursor at its beginning, according to the current mode."
  (interactive)
  (move-end-of-line nil)
  (newline-and-indent))

;; Magnars Emacs config
(defun ot/clj-duplicate-top-level-form ()
  (interactive)
  (save-excursion
    (cljr--goto-toplevel)
    (insert (cljr--extract-sexp) "\n")
    (cljr--just-one-blank-line)))

;; Magnars Emacs config
(defun ot/clj-hippie-expand-no-case-fold ()
  (interactive)
  (let ((old-syntax (char-to-string (char-syntax ?/))))
    (modify-syntax-entry ?/ " ")
    (hippie-expand-no-case-fold)
    (modify-syntax-entry ?/ old-syntax)))

(defun ot/kill-region-or-backward-word ()
  (interactive)
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (backward-kill-word 1)))

(defun ot/kill-to-beginning-of-line ()
  (interactive)
  (kill-region (save-excursion (beginning-of-line) (point))
               (point)))

(defun ot/kill-and-retry-line ()
  "Kill the entire current line and reposition point at indentation"
  (interactive)
  (back-to-indentation)
  (kill-line))

(defun ot/split-window-right-and-move-there-dammit ()
  (interactive)
  (split-window-right)
  (windmove-right))

(defun ot/eval-and-replace ()
  "Replace the preceding sexp with its value."
  (interactive)
  (backward-kill-sexp)
  (condition-case nil
      (prin1 (eval (read (current-kill 0)))
             (current-buffer))
    (error (message "Invalid expression")
           (insert (current-kill 0)))))

;;; Borrowed from: https://github.com/otijhuis/emacs.d/blob/master/config/custom-defuns.el
(use-package avy-zap)
(require 'avy-zap)

(defun ot/avy-zap-to-char-save ()
  "Zap to a character, but save instead of kill."
  (interactive)
  (save-excursion
    (avy-zap-to-char)
    (yank)))

(defun ot/avy-zap-up-to-char-save ()
  "Zap up to a character, but save instead of kill."
  (interactive)
  (save-excursion
    (avy-zap-up-to-char)
    (yank)))

;; Clojure
(defun ot/reload-current-clj-ns (next-p)
  (interactive "P")
  (let ((ns (clojure-find-ns)))
    (message (format "Loading %s ..." ns))
    (inf-clojure-eval-string (format "(require '%s :reload)" ns))
    (when (not next-p) (inf-clojure-eval-string (format "(in-ns '%s)" ns)))))

(defun ot/find-tag-without-ns (next-p)
  (interactive "P")
  (find-tag (first (last (split-string (symbol-name (symbol-at-point)) "/")))
            next-p))

(defun ot/erase-inf-buffer ()
  (interactive)
  (with-current-buffer (get-buffer "*inf-clojure*")
    (erase-buffer))
  (inf-clojure-eval-string ""))

(defun ot/step-out-forward ()
  "Step forward out of current list or string."
  (interactive)
  (cond
   ;; if inside comment just insert paren
   ((nth 4 (syntax-ppss (point))) (insert ")"))
   ;; if inside string keep moving forward
   ((nth 3 (syntax-ppss (point)))
    (forward-char)
    (while (and (not (eobp)) (nth 3 (syntax-ppss (point))))
      (forward-char)))
   (t (up-list))))

;; From http://endlessparentheses.com/emacs-narrow-or-widen-dwim.html
(defun ot/narrow-or-widen-dwim (p)
  "Widen if buffer is narrowed, narrow-dwim otherwise.
Dwim means: region, org-src-block, org-subtree, or defun,
whichever applies first. Narrowing to org-src-block actually
calls `org-edit-src-code'.
With prefix P, don't widen, just narrow even if buffer is
already narrowed."
  (interactive "P")
  (declare (interactive-only))
  (cond ((and (buffer-narrowed-p) (not p)) (widen))
        ((region-active-p)
         (narrow-to-region (region-beginning) (region-end)))
        ((derived-mode-p 'org-mode)
         ;; `org-edit-src-code' is not a real narrowing
         ;; command. Remove this first conditional if you
         ;; don't want it.
         (cond ((ignore-errors (org-edit-src-code))
                (delete-other-windows))
               ((ignore-errors (org-narrow-to-block) t))
               (t (org-narrow-to-subtree))))
        ((derived-mode-p 'latex-mode)
         (LaTeX-narrow-to-environment))
        (t (narrow-to-defun))))

(defun ot/ispell-word-then-abbrev (p)
  "Call `ispell-word', then create an abbrev for it.
With prefix P, create local abbrev. Otherwise it will
be global.
If there's nothing wrong with the word at point, keep
looking for a typo until the beginning of buffer. You can
skip typos you don't want to fix with `SPC', and you can
abort completely with `C-g'."
  (interactive "P")
  (let (bef aft)
    (save-excursion
      (while (if (setq bef (thing-at-point 'word))
                 ;; Word was corrected or used quit.
                 (if (ispell-word nil 'quiet)
                     nil ; End the loop.
                   ;; Also end if we reach `bob'.
                   (not (bobp)))
               ;; If there's no word at point, keep looking
               ;; until `bob'.
               (not (bobp)))
        (backward-word))
      (setq aft (thing-at-point 'word)))
    (if (and aft bef (not (equal aft bef)))
        (let ((aft (downcase aft))
              (bef (downcase bef)))
          (define-abbrev
            (if p local-abbrev-table global-abbrev-table)
            bef aft)
          (message "\"%s\" now expands to \"%s\" %sally"
                   bef aft (if p "loc" "glob")))
      (user-error "No typo at or before point"))))

(defun ot/kill-sexp ()
  (interactive)
  (if (looking-at-p "\\s(")
      (kill-sexp)
    (paxedit-kill)))

(defun ot/parens-move-backward ()
  (interactive)
  (when (search-backward-regexp "\\s(.?" nil 'noerror)
    (goto-char (- (match-end 0) 1))))

(defun ot/parens-move-forward ()
  (interactive)
  (when (looking-at-p "\\s(\\|\\s)\\|\"")
    (forward-char))
  (while (and (not (eobp))
              (or (nth 3 (syntax-ppss (point)))
                  (not (looking-at-p "\\s(\\|\\s)\\|\""))))
    (forward-char)))

(defun ot/paredit-open-line-below ()
  (interactive)
  (let ((ppss (syntax-ppss (point))))
    (if (= 0 (nth 0 ppss))
        (newline-and-indent)
      (progn
        (when (nth 3 ppss)
          (paredit-forward-up))
        (paredit-forward-up)
        (backward-char)
        (newline-and-indent)))))

(defun ot/current-line-empty-p ()
  (save-excursion
    (beginning-of-line)
    (looking-at "[[:space:]]*$")))

(defun ot/first-char-closing-pair-p ()
  (save-excursion
    (beginning-of-line)
    (looking-at-p "[^\\s\-]+\\s)")))

;; Avy base movement macros/functions

(defmacro ot/avy-here (pt command &rest body)
  "Avy here"
  (declare (indent 1)
           (debug (form body)))
  `(progn
     (save-excursion
       (goto-char ,pt)
       (funcall ,command)
       ,@body)
     (yank)
     (if (looking-at-p "[\\s_\|\\s(]")
         (just-one-space))))

(defun ot/avy-move-here (pt command)
  "Move region from PT to PT after COMMAND to current location."
  (ot/avy-here pt command
               (kill-region pt (point))
               (if (or (ot/current-line-empty-p)
                       (ot/first-char-closing-pair-p))
                   (join-line)
                 (fixup-whitespace))))

(defun ot/avy-copy-here (pt command)
  "Copy region from PT to PT after COMMAND to current location"
  (ot/avy-here pt command
               (copy-region-as-kill pt (point))))

(defvar ot/avy-selected-pt nil)

;; Avy copy actions

(defun ot/avy-action-copy-hydra (pt)
  (setq ot/avy-selected-pt pt)
  (hydra-avy-copy-actions/body))

(defun ot/avy-action-copy-sexp-here (pt)
  "Move sexp at PT to current location"
  (ot/avy-copy-here pt 'forward-sexp))

(defun ot/avy-action-copy-symbol-here (pt)
  "Move symbol at PT to current location"
  (ot/avy-copy-here pt (lambda () (forward-symbol 1))))

(defun ot/avy-action-copy-surrounding-sexp-here (pt)
  "Move surrounding sexp at PT to current location"
  (let ((new-pt (save-excursion
                  (goto-char pt)
                  (paredit-backward-up)
                  (point))))
    (ot/avy-copy-here new-pt 'forward-sexp)))

(defun ot/avy-action-copy-sexp-forward-here (pt)
  "Move from PT to end of sexp to current location"
  (ot/avy-copy-here pt (lambda ()
                         (ot/step-out-forward)
                         (backward-char))))

(defun ot/avy-action-copy-sexp-backward-here (pt)
  "Move from PT to beginning of sexp to current location"
  (ot/avy-copy-here pt (lambda ()
                         (paredit-backward-up)
                         (forward-char))))

;; Avy move actions

(defun ot/avy-action-move-hydra (pt)
  (setq ot/avy-selected-pt pt)
  (hydra-avy-move-actions/body))

(defun ot/avy-action-move-sexp-here (pt)
  "Move sexp at PT to current location"
  (ot/avy-move-here pt 'forward-sexp))

(defun ot/avy-action-move-symbol-here (pt)
  "Move symbol at PT to current location"
  (ot/avy-move-here pt (lambda () (forward-symbol 1))))

(defun ot/avy-action-move-surrounding-sexp-here (pt)
  "Move surrounding sexp at PT to current location"
  (let ((new-pt (save-excursion
                  (goto-char pt)
                  (paredit-backward-up)
                  (point))))
    (ot/avy-move-here new-pt 'forward-sexp)))

(defun ot/avy-action-move-sexp-forward-here (pt)
  "Move from PT to end of sexp to current location"
  (ot/avy-move-here pt (lambda ()
                         (ot/step-out-forward)
                         (backward-char))))

(defun ot/avy-action-move-sexp-backward-here (pt)
  "Move from PT to beginning of sexp to current location"
  (ot/avy-move-here pt (lambda ()
                         (paredit-backward-up)
                         (forward-char))))

;; Avy goto commands

(defun ot/avy-goto-sexp (arg)
  (interactive "P")
  (avy-with ot/avy-goto-sexp
    (avy--generic-jump "\\s(\\|\\s\"[[:alnum:]]" arg avy-style)))

(defun ot/avy-goto-word-0 (arg)
  "avy-goto-word-0 with modified syntax table"
  (interactive "P")
  (let ((temp-syntax-table (make-syntax-table (syntax-table)))
        (avy-goto-word-0-regexp "\\b\\sw"))
    (modify-syntax-entry ?_ "w" temp-syntax-table)
    (modify-syntax-entry ?: "w" temp-syntax-table)
    (modify-syntax-entry ?- "w" temp-syntax-table)
    (modify-syntax-entry ?/ "w" temp-syntax-table)
    (modify-syntax-entry ?. "w" temp-syntax-table)
    (with-syntax-table temp-syntax-table
      (avy-with ot/avy-goto-word-0
        (avy--generic-jump avy-goto-word-0-regexp arg avy-style)))))

;;; lisp-defuns.el ends here
#+END_SRC
** misc-defuns
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/defuns/misc-defuns.el
;;; misc-defuns.el -*- lexical-binding: t;

;; Misc defuns go here
;; It wouldn't hurt to look for patterns and extract once in a while

(defmacro create-simple-keybinding-command (name key)
  `(defmacro ,name (&rest fns)
     (list 'global-set-key (kbd ,key) `(lambda ()
                                         (interactive)
                                         ,@fns))))

(create-simple-keybinding-command f2 "<f2>")
(create-simple-keybinding-command f5 "<f5>")
(create-simple-keybinding-command f6 "<f6>")
(create-simple-keybinding-command f7 "<f7>")
(create-simple-keybinding-command f8 "<f8>")
(create-simple-keybinding-command f9 "<f9>")
(create-simple-keybinding-command f10 "<f10>")
(create-simple-keybinding-command f11 "<f11>")
(create-simple-keybinding-command f12 "<f12>")

(defun goto-line-with-feedback ()
  "Show line numbers temporarily, while prompting for the line number input"
  (interactive)
  (unwind-protect
      (progn
        (linum-mode 1)
        (call-interactively 'goto-line))
    (linum-mode -1)))

(defun open-line-and-indent ()
  (interactive)
  (newline-and-indent)
  (end-of-line 0)
  (indent-for-tab-command))

;; start a httpd-server in current directory
(defun httpd-start-here (directory port)
  (interactive (list (read-directory-name "Root directory: " default-directory nil t)
                     (read-number "Port: " 8017)))
  (setq httpd-root directory)
  (setq httpd-port port)
  (httpd-start)
  (browse-url (concat "http://localhost:" (number-to-string port) "/")))

;; shorthand for interactive lambdas
(defmacro λ (&rest body)
  `(lambda ()
     (interactive)
     ,@body))

(global-set-key (kbd "s-l") (λ (insert "\u03bb")))

;; command to help set up magit-gh-pulls
(defun magit-gh-pulls-setup (repoid)
  (interactive "suser/repo: ")
  (shell-command "git config --add magit.extension gh-pulls")
  (shell-command (concat "git config magit.gh-pulls-repo " repoid)))

;; Increase/decrease selective display
(defun inc-selective-display (arg)
  (interactive "P")
  (if (numberp arg)
      (set-selective-display arg)
    (if (numberp selective-display)
        (set-selective-display (+ 2 selective-display))
      (set-selective-display 2)))
  (create-temp-selective-display-keymap))

(defun dec-selective-display ()
  (interactive)
  (when (and (numberp selective-display)
             (> selective-display 2))
    (set-selective-display (- selective-display 2)))
  (create-temp-selective-display-keymap))

(defun clear-selective-display ()
  (interactive)
  (when (numberp selective-display)
    (set-selective-display nil)))

(defun create-temp-selective-display-keymap ()
  (set-temporary-overlay-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "+") 'inc-selective-display)
     (define-key map (kbd "-") 'dec-selective-display)
     (define-key map (kbd "0") 'clear-selective-display)
     map))
  (message "Type + to reveal more, - for less, 0 to reset."))

;; Add spaces and proper formatting to linum-mode. It uses more room than
;; necessary, but that's not a problem since it's only in use when going to
;; lines.
(setq linum-format (lambda (line)
                     (propertize
                      (format (concat " %"
                                      (number-to-string
                                       (length (number-to-string
                                                (line-number-at-pos (point-max)))))
                                      "d ")
                              line)
                      'face 'linum)))

(defun isearch-yank-selection ()
  "Put selection from buffer into search string."
  (interactive)
  (when (region-active-p)
    (deactivate-mark))
  (isearch-yank-internal (lambda () (mark))))

(defun region-as-string ()
  (buffer-substring (region-beginning)
                    (region-end)))

(defun isearch-forward-use-region ()
  (interactive)
  (when (region-active-p)
    (add-to-history 'search-ring (region-as-string))
    (deactivate-mark))
  (call-interactively 'isearch-forward))

(defun isearch-backward-use-region ()
  (interactive)
  (when (region-active-p)
    (add-to-history 'search-ring (region-as-string))
    (deactivate-mark))
  (call-interactively 'isearch-backward))

(eval-after-load "multiple-cursors"
  '(progn
     (unsupported-cmd isearch-forward-use-region ".")
     (unsupported-cmd isearch-backward-use-region ".")))

(defun view-url ()
  "Open a new buffer containing the contents of URL."
  (interactive)
  (let* ((default (thing-at-point-url-at-point))
         (url (read-from-minibuffer "URL: " default)))
    (switch-to-buffer (url-retrieve-synchronously url))
    (rename-buffer url t)
    ;; TODO: switch to nxml/nxhtml mode
    (cond ((search-forward "<?xml" nil t) (xml-mode))
          ((search-forward "<html" nil t) (html-mode)))))

(defun linkify-region-from-kill-ring (start end)
  (interactive "r")
  (let ((text (buffer-substring start end)))
    (delete-region start end)
    (insert "<a href=\"")
    (yank)
    (insert (concat "\">" text "</a>"))))

(defun buffer-to-html (buffer)
  (with-current-buffer (htmlize-buffer buffer)
    (buffer-string)))

(defun sudo-edit (&optional arg)
  (interactive "p")
  (if (or arg (not buffer-file-name))
      (find-file (concat "/sudo:root@localhost:" (ido-read-file-name "File: ")))
    (find-alternate-file (concat "/sudo:root@localhost:" buffer-file-name))))

(defun add-file-find-hook-with-pattern (pattern fn &optional contents)
  "Add a find-file-hook that calls FN for files where PATTERN
  matches the file name, and optionally, where CONTENT matches file contents.
  Both PATTERN and CONTENTS are matched as regular expressions."
  (lexical-let ((re-pattern pattern)
                (fun fn)
                (re-content contents))
    (add-hook 'find-file-hook
              (lambda ()
                (if (and
                     (string-match re-pattern (buffer-file-name))
                     (or (null re-content)
                         (string-match re-content
                                       (buffer-substring (point-min) (point-max)))))
                    (apply fun ()))))))

;; Fix kmacro-edit-lossage, it's normal implementation
;; is bound tightly to C-h
(defun kmacro-edit-lossage ()
  "Edit most recent 300 keystrokes as a keyboard macro."
  (interactive)
  (kmacro-push-ring)
  (edit-kbd-macro 'view-lossage))

(defmacro comment (&rest ignore))

(defun what-face (pos)
  (interactive "d")
  (let ((face (or (get-char-property pos 'read-face-name)
                  (get-char-property pos 'face))))
    (if face (message "Face: %s" face) (message "No face at %d" pos))))

(defun goto-next-line-with-same-indentation ()
  (interactive)
  (back-to-indentation)
  (re-search-forward (s-concat "^" (s-repeat (current-column) " ") "[^ \t\r\n\v\f]")
                     nil nil (if (= 0 (current-column)) 2 1))
  (back-to-indentation))

(defun goto-prev-line-with-same-indentation ()
  (interactive)
  (back-to-indentation)
  (re-search-backward (s-concat "^" (s-repeat (current-column) " ") "[^ \t\r\n\v\f]"))
  (back-to-indentation))

(defun switch-to-scratch ()
  (interactive)
  (switch-to-buffer "*scratch*"))

;; Toggle whitespace
(defun tf-toggle-show-trailing-whitespace ()
  "Toggle show-trailing-whitespace between t and nil"
  (interactive)
  (setq show-trailing-whitespace (not show-trailing-whitespace)))

(defun my-insert-file-name (filename &optional args)
  "Insert name of file FILENAME into buffer after point.

    Prefixed with \\[universal-argument], expand the file name to
    its fully canocalized path.  See `expand-file-name'.

    Prefixed with \\[negative-argument], use relative path to file
    name from current directory, `default-directory'.  See
    `file-relative-name'.

    The default with no prefix is to insert the file name exactly as
    it appears in the minibuffer prompt."
  ;; Based on insert-file in Emacs -- ashawley 20080926
  (interactive "*fInsert file name: \nP")
  (cond ((eq '- args)
         (insert (file-relative-name filename)))
        ((not (null args))
         (insert (expand-file-name filename)))
        (t
         (insert filename))))

(global-set-key (kbd "C-c i") 'my-insert-file-name)

(global-set-key (kbd "C-c w") 'tf-toggle-show-trailing-whitespace)

;;; misc-defuns.el ends here
#+END_SRC
** settings
:PROPERTIES:
:header-args: :mkdirp yes :dir ~/.emacs.d/settings
:END:
** appearance.el
#+begin_src emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/appearance.el
;;; appearance.el
(setq bonz/default-font "-PfEd-DejaVu Sans Mono-medium-normal-normal-*-13-*-*-*-m-0-iso10646-1")

(add-to-list 'default-frame-alist '(font . "DejaVu Sans Mono-13"))
(setq bonface/presentation-font "-PfEd-DejaVu Sans Mono-medium-normal-normal-*-21-*-*-*-m-0-iso10646-1")

(setq ring-bell-function (lambda ()
                           (invert-face 'mode-line)
                           (run-with-timer 0.05 nil 'invert-face
                                           'mode-line)))
  
;; Set custom theme path
(create-directory-if-nonexistent
  (expand-file-name "themes" user-emacs-directory))
(setq custom-theme-directory (concat user-emacs-directory "themes"))

(dolist
    (path (directory-files custom-theme-directory t "\\w+"))
  (when (file-directory-p path)
    (add-to-list 'custom-theme-load-path path)))

;; Default theme
(defun use-presentation-theme ()
  (interactive)
  (when (boundp 'bonface/presentation-font)
    (set-face-attribute 'default nil :font bonface/presentation-font)))

;; Don't defer screen updates when performing operations
(setq redisplay-dont-pause t)

(when window-system
  (setq frame-title-format '(buffer-file-name "%f" ("%b")))
  (tooltip-mode -1)
  (blink-cursor-mode -1))

;; Nice looking themes ^_^
(use-package solarized-theme :ensure)
(use-package doom-themes :ensure)
(use-package ewal-spacemacs-themes :ensure)

(defun disable-all-themes ()
  (dolist (th custom-enabled-themes)
    (disable-theme th)))

(defun bonz/load-dark-theme ()
  (load-theme 'doom-gruvbox))

(defun bonz/load-light-theme ()
  (load-theme 'spacemacs-light))

(defun bonz/toggle-theme () "Toggle between dark and light themes."
       (interactive)
       ;; Load dark if light is top-most enabled theme, else load light.
       (if (equal (car custom-enabled-themes) 'spacemacs-light)
           (bonz/load-dark-theme)
         (bonz/load-light-theme)))

(bonz/load-dark-theme)

(use-package all-the-icons :ensure)
(use-package doom-modeline
  :ensure
  :hook (after-init . doom-modeline-mode)
  :config
  (setq doom-modeline-height 25)

  ;; How wide the mode-line bar should be. It's only respected in GUI.
  (setq doom-modeline-bar-width 3)

  ;; How to detect the project root.
  ;; The default priority of detection is `ffip' > `projectile' > `project'.
  ;; nil means to use `default-directory'.
  ;; The project management packages have some issues on detecting project root.
  ;; e.g. `projectile' doesn't handle symlink folders well, while `project' is unable
  ;; to hanle sub-projects.
  ;; You can specify one if you encounter the issue.
  (setq doom-modeline-project-detection 'project)

  ;; Determines the style used by `doom-modeline-buffer-file-name'.
  ;;
  ;; Given ~/Projects/FOSS/emacs/lisp/comint.el
  ;;   truncate-upto-project => ~/P/F/emacs/lisp/comint.el
  ;;   truncate-from-project => ~/Projects/FOSS/emacs/l/comint.el
  ;;   truncate-with-project => emacs/l/comint.el
  ;;   truncate-except-project => ~/P/F/emacs/l/comint.el
  ;;   truncate-upto-root => ~/P/F/e/lisp/comint.el
  ;;   truncate-all => ~/P/F/e/l/comint.el
  ;;   relative-from-project => emacs/lisp/comint.el
  ;;   relative-to-project => lisp/comint.el
  ;;   file-name => comint.el
  ;;   buffer-name => comint.el<2> (uniquify buffer name)
  ;;
  ;; If you are experiencing the laggy issue, especially while editing remote files
  ;; with tramp, please try `file-name' style.
  ;; Please refer to https://github.com/bbatsov/projectile/issues/657.
  (setq doom-modeline-buffer-file-name-style 'truncate-upto-project)

  ;; Whether display icons in mode-line. Respects `all-the-icons-color-icons'.
  ;; While using the server mode in GUI, should set the value explicitly.
  (setq doom-modeline-icon (display-graphic-p))

  ;; Whether display the icon for `major-mode'. Respects `doom-modeline-icon'.
  (setq doom-modeline-major-mode-icon t)

  ;; Whether display the colorful icon for `major-mode'.
  ;; Respects `doom-modeline-major-mode-icon'.
  (setq doom-modeline-major-mode-color-icon t)

  ;; Whether display the icon for the buffer state. It respects `doom-modeline-icon'.
  (setq doom-modeline-buffer-state-icon t)

  ;; Whether display the modification icon for the buffer.
  ;; Respects `doom-modeline-icon' and `doom-modeline-buffer-state-icon'.
  (setq doom-modeline-buffer-modification-icon t)

  ;; Whether to use unicode as a fallback (instead of ASCII) when not using icons.
  (setq doom-modeline-unicode-fallback nil)

  ;; Whether display the minor modes in mode-line.
  (setq doom-modeline-minor-modes nil)

  ;; If non-nil, a word count will be added to the selection-info modeline segment.
  (setq doom-modeline-enable-word-count nil)

  ;; Major modes in which to display word count continuously.
  ;; Also applies to any derived modes. Respects `doom-modeline-enable-word-count'.
  ;; If it brings the sluggish issue, disable `doom-modeline-enable-word-count' or
  ;; remove the modes from `doom-modeline-continuous-word-count-modes'.
  (setq doom-modeline-continuous-word-count-modes '(markdown-mode gfm-mode org-mode))

  ;; Whether display the buffer encoding.
  (setq doom-modeline-buffer-encoding t)

  ;; Whether display the indentation information.
  (setq doom-modeline-indent-info nil)

  ;; If non-nil, only display one number for checker information if applicable.
  (setq doom-modeline-checker-simple-format t)

  ;; The maximum number displayed for notifications.
  (setq doom-modeline-number-limit 99)

  ;; The maximum displayed length of the branch name of version control.
  (setq doom-modeline-vcs-max-length 12)

  ;; Whether display the perspective name. Non-nil to display in mode-line.
  (setq doom-modeline-persp-name t)

  ;; If non nil the default perspective name is displayed in the mode-line.
  (setq doom-modeline-display-default-persp-name nil)

  ;; Whether display the `lsp' state. Non-nil to display in mode-line.
  (setq doom-modeline-lsp t)

  ;; Whether display the GitHub notifications. It requires `ghub' package.
  ;; (setq doom-modeline-github nil)

  ;; The interval of checking GitHub.
  ;; (setq doom-modeline-github-interval (* 30 60))

  ;; Whether display the modal state icon.
  ;; Including `evil', `overwrite', `god', `ryo' and `xah-fly-keys', etc.
  (setq doom-modeline-modal-icon t)

  ;; Whether display the mu4e notifications. It requires `mu4e-alert' package.
  (setq doom-modeline-mu4e nil)

  ;; Whether display the gnus notifications.
  (setq doom-modeline-gnus nil)

  ;; Wheter gnus should automatically be updated and how often (set to nil to disable)
  (setq doom-modeline-gnus-timer nil)

  ;; Whether display the IRC notifications. It requires `circe' or `erc' package.
  (setq doom-modeline-irc t)

  ;; Function to stylize the irc buffer names.
  (setq doom-modeline-irc-stylize 'identity)

  ;; Whether display the environment version.
  (setq doom-modeline-env-version t)
  ;; Or for individual languages
  (setq doom-modeline-env-enable-python t)
  (setq doom-modeline-env-enable-ruby t)
  (setq doom-modeline-env-enable-perl t)
  (setq doom-modeline-env-enable-go t)
  (setq doom-modeline-env-enable-elixir t)
  (setq doom-modeline-env-enable-rust t)

  ;; Change the executables to use for the language version string
  (setq doom-modeline-env-python-executable "python") ; or `python-shell-interpreter'
  (setq doom-modeline-env-ruby-executable "ruby")
  (setq doom-modeline-env-perl-executable "perl")
  (setq doom-modeline-env-go-executable "go")
  (setq doom-modeline-env-elixir-executable "iex")
  (setq doom-modeline-env-rust-executable "rustc")

  ;; What to dispaly as the version while a new one is being loaded
  (setq doom-modeline-env-load-string "...")

  ;; Hooks that run before/after the modeline version string is updated
  (setq doom-modeline-before-update-env-hook nil)
  (setq doom-modeline-after-update-env-hook nil))

(setq show-paren-style 'expression)
(show-paren-mode)

;; Colour parens, and other delimiters, depending on their depth.
;; Very useful for parens heavy languages like Lisp.
(use-package rainbow-delimiters :ensure
  :config
  (add-hook 'org-mode-hook
            '(lambda () (rainbow-delimiters-mode 1)))
  (add-hook 'prog-mode-hook
            '(lambda () (rainbow-delimiters-mode 1))))

(column-number-mode t)
(use-package dimmer
  :ensure
  :config (dimmer-mode)
  (setq dimmer-fraction 0.2))

;; Remove the font size modified by the spacemacs theme.
;;  https://emacs.stackexchange.com/questions/22584/disable-enlarged-org-mode-header-appearance
(defun bonz/org-mode-hook ()
  "Stop the org-level headers from increasing in height relative to the other text."
  (dolist (face '(org-level-1
                  org-level-2
                  org-level-3
                  org-level-4
                  org-level-5))
    (set-face-attribute face nil :weight 'semi-bold :height 1.0)))

(add-hook 'org-mode-hook 'bonz/org-mode-hook)

(provide 'appearance)

;;; appearance.el ends here
#+end_src
** sane-defaults.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/sane-defaults.el
;;; sane-defaults.el

;; When popping the mark, continue popping until the cursor actually moves
;; Also, if the last command was a copy - skip past all the expand-region cruft.
(defadvice pop-to-mark-command (around ensure-new-position activate)
  (let ((p (point)))
    (when (eq last-command 'save-region-or-current-line)
      ad-do-it
      ad-do-it
      ad-do-it)
    (dotimes (i 10)
      (when (= p (point)) ad-do-it))))

(defun display-startup-echo-area-message ()
  "The message that is shown after ‘user-init-file’ is loaded."
  (message
   (concat "Welcome "      user-full-name
           "! Emacs "      emacs-version
           "; Org-mode "   org-version
           "; System "    (system-name)
           (format "; Time %.3fs"
                   (float-time (time-subtract (current-time)
                                              before-init-time))))))

(defun untabify-buffer ()
  (interactive)
  (untabify (point-min) (point-max)))

(defun indent-buffer ()
  (interactive)
  (indent-region (point-min) (point-max)))

(defun cleanup-buffer ()
  "Perform a bunch of operations on the whitespace content of a buffer."
  (interactive)
  (indent-buffer)
  (untabify-buffer)
  (delete-trailing-whitespace))

(defun cleanup-region (beg end)
  "Remove tmux artifacts from region."
  (interactive "r")
  (dolist (re '("\\\\│\·*\n" "\W*│\·*"))
    (replace-regexp re "" nil beg end)))

;; http://iqbalansari.github.io/blog/2014/12/07/automatically-create-parent-directories-on-visiting-a-new-file-in-emacs/
(defun bonz/create-non-existent-directory ()
  "Offer to create parent directories if they do not exist"
  (let ((parent-directory (file-name-directory buffer-file-name)))
    (when (and (not (file-exists-p parent-directory))
               (y-or-n-p (format "Directory `%s' does not exist! Create it?" parent-directory)))
      (make-directory parent-directory t))))

(add-to-list 'find-file-not-found-functions 'bonz/create-non-existent-directory)

(use-package autopair
  :config
  (autopair-mode 1))

(use-package browse-url
  :ensure
  :config
  (defun actuator-browse-video (url &rest _args)
    "Browse a URL with a dedicated video player.
Avoids opening a browser window."
    (start-process "mpv" nil "mpv" url))
  :custom
  (browse-url-handlers '(("youtu\\.?be" . actuator-browse-video)
                         ("twitch"      . actuator-browse-video))))

(use-package ace-window
  :config
  (add-to-list 'aw-dispatch-alist '(?w hydra-window-size/body) t)
  (add-to-list 'aw-dispatch-alist '(?r hydra-window-scroll/body) t)
  (add-to-list 'aw-dispatch-alist '(?\; hydra-window-frame/body) t)
  (setq aw-dispatch-always nil)
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (custom-set-faces
   '(aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 1.0)))))
  (ace-window-display-mode 1)
  :bind (("C-x o" . ace-window)))

(use-package avy
  :ensure
  :config
  (setq avy-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l ?q ?w ?e ?r ?t ?y ?u ?o ?p ?v ?b))
  (setq avy-dispatch-alist '((?X . avy-action-kill-move)
                             (?x . avy-action-kill-stay)
                             (?M . avy-action-mark)
                             (?m . ot/avy-action-move-hydra)
                             (?C . avy-action-copy)
                             (?c . ot/avy-action-copy-hydra)
                             (?i . avy-action-ispell)))
  (setq avy-styles-alist '((avy-goto-word-0 . pre)
                           (ot/avy-goto-word-0 . pre)
                           (ot/avy-goto-sexp . pre)))
  (setq avy-all-windows 'all-frames)
  (setq avy-style 'at-full)
  (setq avy-background nil)
  (setq avy-timeout-seconds 0.5))

;; This is the de-facto standard in-buffer completion package. In case
;; you're wondering, Company stands for Complete Anything.
(use-package company
  :ensure
  :bind (;; Replace `completion-at-point' and `complete-symbol' with
         ;; `company-manual-begin'. You might think this could be put
         ;; in the `:bind*' declaration below, but it seems that
         ;; `bind-key*' does not work with remappings.
         ([remap completion-at-point] . company-manual-begin)
         ([remap complete-symbol] . company-manual-begin)

         ;; The following are keybindings that take effect whenever
         ;; the completions menu is visible, even if the user has not
         ;; explicitly interacted with Company.

         :map company-active-map

         ;; Make TAB always complete the current selection. Note that
         ;; <tab> is for windowed Emacs and TAB is for terminal Emacs.
         ("<tab>" . company-complete-selection)
         ("TAB" . company-complete-selection)

         ;; Prevent SPC from ever triggering a completion.
         ("SPC" . nil)

         ;; The following are keybindings that only take effect if the
         ;; user has explicitly interacted with Company.

         :map company-active-map
         :filter (company-explicit-action-p)

         ;; Make RET trigger a completion if and only if the user has
         ;; explicitly interacted with Company. Note that <return> is
         ;; for windowed Emacs and RET is for terminal Emacs.
         ("<return>" . company-complete-selection)
         ("RET" . company-complete-selection)

         ;; We then do the same for the up and down arrows. Note that
         ;; we use `company-select-previous' instead of
         ;; `company-select-previous-or-abort'. I think the former
         ;; makes more sense since the general idea of this `company'
         ;; configuration is to decide whether or not to steal
         ;; keypresses based on whether the user has explicitly
         ;; interacted with `company', not based on the number of
         ;; candidates.

         ("<up>" . company-select-previous)
         ("<down>" . company-select-next))

  :bind* (;; The default keybinding for `completion-at-point' and
          ;; `complete-symbol' is M-TAB or equivalently C-M-i. Here we
          ;; make sure that no minor modes override this keybinding.
          ("M-TAB" . company-manual-begin))

  :diminish company-mode
  :config
  ;; Show completions instantly, rather than after half a second.
  (setq company-idle-delay 0)

  ;; Show completions after typing a single character, rather than
  ;; after typing three characters.
  (setq company-minimum-prefix-length 1)

  ;; Show a maximum of 10 suggestions. This is the default but I think
  ;; it's best to be explicit.
  (setq company-tooltip-limit 10)

  ;; Always display the entire suggestion list onscreen, placing it
  ;; above the cursor if necessary.
  (setq company-tooltip-minimum company-tooltip-limit)

  ;; Always display suggestions in the tooltip, even if there is only
  ;; one. Also, don't display metadata in the echo area. (This
  ;; conflicts with ElDoc.)
  (setq company-frontends '(company-pseudo-tooltip-frontend))

  ;; Show quick-reference numbers in the tooltip. (Select a completion
  ;; with M-1 through M-0.)
  (setq company-show-numbers t)

  ;; Prevent non-matching input (which will dismiss the completions
  ;; menu), but only if the user interacts explicitly with Company.
  (setq company-require-match #'company-explicit-action-p)

  ;; Company appears to override our settings in `company-active-map'
  ;; based on `company-auto-complete-chars'. Turning it off ensures we
  ;; have full control.
  (setq company-auto-complete-chars nil)

  ;; Prevent Company completions from being lowercased in the
  ;; completion menu. This has only been observed to happen for
  ;; comments and strings in Clojure.
  (setq company-dabbrev-downcase nil)

  ;; Only search the current buffer to get suggestions for
  ;; company-dabbrev (a backend that creates suggestions from text
  ;; found in your buffers). This prevents Company from causing lag
  ;; once you have a lot of buffers open.
  (setq company-dabbrev-other-buffers nil)

  ;; Make company-dabbrev case-sensitive. Case insensitivity seems
  ;; like a great idea, but it turns out to look really bad when you
  ;; have domain-specific words that have particular casing.
  (setq company-dabbrev-ignore-case nil)

  ;; Make it so that Company's keymap overrides Yasnippet's keymap
  ;; when a snippet is active. This way, you can TAB to complete a
  ;; suggestion for the current field in a snippet, and then TAB to
  ;; move to the next field. Plus, C-g will dismiss the Company
  ;; completions menu rather than cancelling the snippet and moving
  ;; the cursor while leaving the completions menu on-screen in the
  ;; same location.

  (with-eval-after-load 'yasnippet
    ;; TODO: this is all a horrible hack, can it be done with
    ;; `bind-key' instead?

    ;; This function translates the "event types" I get from
    ;; `map-keymap' into things that I can pass to `lookup-key'
    ;; and `define-key'. It's a hack, and I'd like to find a
    ;; built-in function that accomplishes the same thing while
    ;; taking care of any edge cases I might have missed in this
    ;; ad-hoc solution.
    (defun radian--normalize-event (event)
      (if (vectorp event)
          event
        (vector event)))

    ;; Here we define a hybrid keymap that delegates first to
    ;; `company-active-map' and then to `yas-keymap'.
    (setq radian--yas-company-keymap
          ;; It starts out as a copy of `yas-keymap', and then we
          ;; merge in all of the bindings from
          ;; `company-active-map'.
          (let ((keymap (copy-keymap yas-keymap)))
            (map-keymap
             (lambda (event company-cmd)
               (let* ((event (radian--normalize-event event))
                      (yas-cmd (lookup-key yas-keymap event)))
                 ;; Here we use an extended menu item with the
                 ;; `:filter' option, which allows us to
                 ;; dynamically decide which command we want to
                 ;; run when a key is pressed.
                 (define-key keymap event
                   `(menu-item
                     nil ,company-cmd :filter
                     (lambda (cmd)
                       ;; There doesn't seem to be any obvious
                       ;; function from Company to tell whether or
                       ;; not a completion is in progress (à la
                       ;; `company-explicit-action-p'), so I just
                       ;; check whether or not `company-my-keymap'
                       ;; is defined, which seems to be good
                       ;; enough.
                       (if company-my-keymap
                           ',company-cmd
                         ',yas-cmd))))))
             company-active-map)
            keymap))

    ;; The function `yas--make-control-overlay' uses the current
    ;; value of `yas-keymap' to build the Yasnippet overlay, so to
    ;; override the Yasnippet keymap we only need to dynamically
    ;; rebind `yas-keymap' for the duration of that function.
    (defun radian--advice-company-overrides-yasnippet
        (yas--make-control-overlay &rest args)
      "Allow `company' to override `yasnippet'.
This is an `:around' advice for `yas--make-control-overlay'."
      (let ((yas-keymap radian--yas-company-keymap))
        (apply yas--make-control-overlay args)))

    (advice-add #'yas--make-control-overlay :around
                #'radian--advice-company-overrides-yasnippet)))

(use-package dash :ensure)

(use-package diminish
  :ensure
  :after use-package
  :config
  (diminish 'eldoc-mode)
  (diminish 'org-indent-mode)
  (diminish 'subword-mode)
  (diminish 'visual-line-mode "")
  (diminish 'isearch-mode "?")
  (diminish 'flyspell-mode))

(use-package imenu
  :config
  (setq imenu-use-markers t)
  (setq imenu-auto-rescan t)
  (setq imenu-auto-rescan-maxout 600000)
  (setq imenu-max-item-length 100)
  (setq imenu-use-popup-menu nil)
  (setq imenu-eager-completion-buffer t)
  (setq imenu-space-replacement " ")
  (setq imenu-level-separator "/")
  :bind
  (("M-i" . imenu)))

(use-package imenu-list
  :ensure
  :after imenu
  :config
  (defun bonz/imenu-list-dwim (&optional arg)
    "Convenience wrapper for `imenu-list'.
Move between the current buffer and a dedicated window with the
contents of `imenu'.

The dedicated window is created if it does not exist, while it is
updated once it is focused again through this command.

With \\[universal-argument] toggle the display of the window."
    (interactive "P")
    (if arg
        (imenu-list-smart-toggle)
      (with-current-buffer
          (if (eq major-mode 'imenu-list-major-mode)
              (pop-to-buffer (other-buffer (current-buffer) t))
            (imenu-list)))))

  :bind (("C-," . bonz/imenu-list-dwim)))

(use-package flimenu
  :ensure
  :after imenu
  :config
  (flimenu-global-mode 1))

(use-package wgrep
  :ensure
  :commands wgrep
  :config
  (setq wgrep-auto-save-buffer t)
  (setq wgrep-change-readonly-file t))

;; guide-key
(use-package guide-key
  :config
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-x v" "C-x 8" "C-x +"))
  (setq guide-key/recursive-key-sequence-flag t)
  (setq guide-key/popup-window-position 'bottom)
  (guide-key-mode 1))

(use-package web-beautify
  :ensure
  :config
  (eval-after-load 'js2-mode
    '(define-key js2-mode-map (kbd "C-c b") 'web-beautify-js))
  (eval-after-load 'js
    '(define-key js-mode-map (kbd "C-c b") 'web-beautify-js))
  (eval-after-load 'json-mode
    '(define-key json-mode-map (kbd "C-c b") 'web-beautify-js))
  (eval-after-load 'sgml-mode
    '(define-key html-mode-map (kbd "C-c b") 'web-beautify-html))
  (eval-after-load 'web-mode
    '(define-key web-mode-map (kbd "C-c b") 'web-beautify-html))
  (eval-after-load 'css-mode
    '(define-key css-mode-map (kbd "C-c b") 'web-beautify-css)))

(use-package wordnut
  :ensure
  :bind ("C-c !" . wordnut-lookup-current-word))

;; Making it easier to discover Emacs key presses.
(use-package which-key
  :ensure
  :diminish which-key-mode
  :init (which-key-mode)
  :config (which-key-setup-side-window-bottom)
  (setq which-key-idle-delay 0.2))

;; Save point position between sessions
(use-package saveplace
  :ensure
  :config
  (setq-default save-place t)
  (setq save-place-file (expand-file-name ".places" user-emacs-directory)))

(use-package smartparens
  :ensure
  :config
  (require 'smartparens-config))

;; Highlight escape sequences
(use-package highlight-escape-sequences :ensure)

;; autocomplete
(use-package auto-complete
  :ensure
  :config
  (ac-config-default)
  (setq ac-show-menu-immediately-on-auto-complete t))

;; Flyspell
(use-package flyspell
  :ensure
  :config
  (custom-set-faces '(flyspell-incorrect ((t (:inverse-video t)))))
  (setq flyspell-issue-welcome-flag nil)
  (setq ispell-dictionary "en_GB") ;; set the default dictionary
  (setq ispell-personal-dictionary "~/.emacs.d/.aspell.en.pws")
  (setq ispell-silently-savep t)
  (setq-default ispell-list-command "list")
  (setq-default ispell-program-name "/home/bonface/.guix-profile/bin/aspell")
  :hook ((prog-mode . flyspell-prog-mode-hook)
         (text-mode . flyspell-mode-hook)
         (org-mode . flyspell-mode-hook)
         (c-mode . flyspell-prog-mode-hook)
         (python-mode . flyspell-prog-mode-hook)
         (web-mode . flyspell-prog-mode-hook)
         (emacs-lisp-mode . flyspell-prog-mode-hook)))

;; Avoid unwanted repetition
(use-package synosaurus
  :ensure
  :diminish synosaurus-mode
  :config
  (setq synosaurus-choose-method 'popup)
  (synosaurus-mode 1)
  :bind
  (("M-#" . synosaurus-choose-and-replace)))

(use-package fill-column-indicator
  :ensure
  :config
  (setq fci-rule-color "#111122"))

;; move text
(use-package move-text
  :ensure
  :config
  (move-text-default-bindings))

(use-package golden-ratio
  :ensure
  :config
  (add-to-list 'golden-ratio-inhibit-functions
               '(lambda ()
                  (if (boundp 'helm-alive-p)
                      (symbol-value 'helm-alive-p))))
  (golden-ratio-mode -1))

(use-package guix :ensure)

;; show emojis
(use-package emojify
  :ensure
  :hook
  ((after-init-hook . global-emojify-mode)))

;; add $PATH to eshell
(use-package exec-path-from-shell
  :ensure
  :init
  (when (memq window-system '(mac ns x))
    (exec-path-from-shell-initialize)))

;; open epubs
;; (use-package justify-kp)
(use-package nov
  :mode ("\\.epub$" . nov-mode)
  :ensure
  :config
  (setq nov-text-width 80)
  (setq visual-fill-column-center-text t)
  :hook
  ((visual-line-mode . nov-mode-hook)
   (visual-fill-column-mode . nov-mode-hook)))

(use-package emacs
  :init
  (auto-compression-mode 1)
  (column-number-mode t)
  (delete-selection-mode 1)
  (display-battery-mode)
  (display-time)
  (display-time-mode t)
  (fringe-mode 7)
  (global-auto-revert-mode 1)
  (global-hl-line-mode t)
  (global-subword-mode 1)
  (global-visual-line-mode)
  (hes-mode)
  (menu-bar-mode -1)
  (recentf-mode 1)
  (savehist-mode 1)
  (scroll-bar-mode -1)
  (show-paren-mode 1)
  (tool-bar-mode -1)
  (transient-mark-mode 1)
  (winner-mode 1) ; Undo/redo window configuration with C-c <left>/<right>
  :config
  (defun keyboard-quit-strong ()
    "Run `keyboard-quit' to return emacs to a more responsive state.
    If repeated twice in a row, run `top-level' instead, to also exit
    any recursive editing levels."
    (interactive)
    (when (eq last-command 'keyboard-quit-strong)
      (setq this-command 'top-level) ;dis-arm a 3rd C-g
      (ding)
      (top-level))
    ;; Not reached after `top-level'. (A rare behavior in lisp.)
    (keyboard-quit))

  (defun nolinum ()
    (global-linum-mode 0))

  (add-to-list 'auto-mode-alist '("\\.zsh$" . shell-script-mode))
  ;; conf-mode
  (add-to-list 'auto-mode-alist '("\\.gitconfig$" . conf-mode))
  (add-to-list 'auto-mode-alist '("\\.hbs$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.erb$" . web-mode))
  (add-to-list 'auto-mode-alist '("\\.html$" . web-mode))
  ;; yaml
  (add-to-list 'auto-mode-alist '("\\.yml$" . yaml-mode))
  (add-to-list 'auto-mode-alist '("\\.yaml$" . yaml-mode))
  ;; PHP
  (add-to-list 'auto-mode-alist '("\\.php$" . php-mode))
  ;; Golang
  (add-to-list 'auto-mode-alist '("\\.go\\'" . go-mode))
  (add-to-list 'auto-mode-alist '("\\info.gz$" . info-mode))
  (add-to-list 'auto-mode-alist '("\\.\\(org\\|org_archive\\)$" . org-mode))
  
  (define-key ac-mode-map (kbd "M-TAB") 'auto-complete)
  (set-default 'indent-tabs-mode nil)
  (setq auto-revert-verbose nil)
  (setq column-number-mode t)
  (setq custom-safe-themes t)
  (setq delete-by-moving-to-trash t)
  (setq display-time-day-and-date t)
  (setq display-time-default-load-average nil)
  (setq echo-keystrokes 0.1)
  (setq ediff-diff-options "-w")
  (setq ediff-split-window-function 'split-window-horizontally)
  (setq ediff-window-setup-function 'ediff-setup-windows-plain)
  (setq enable-recursive-minibuffers t)
  (setq epa-pinentry-mode 'loopback)
  (setq fill-column 80)
  (setq gc-cons-threshold 20000000)
  (setq geiser-default-implementation 'racket)
  (setq geiser-racket-binary "/home/bonface/.guix-profile/bin/racket")
  (setq global-auto-revert-non-file-buffers t)
  (setq history-length 100)
  (setq ibuffer-show-empty-filter-groups -1)
  (setq inhibit-splash-screen t)
  (setq jump-char-lazy-highlight-face -1)
  (setq line-number-mode t)
  (setq make-backup-files -1)
  (setq nov-text-width 80)
  (setq org-src-fontify-natively t)
  (setq recentf-max-menu-items 25)
  (setq recentf-max-saved-items 100)
  (setq set-mark-command-repeat-pop t)
  (setq show-trailing-whitespace 1)
  (setq shell-file-name "/usr/bin/zsh")
  (setq sp-autoescape-string-quote nil)
  (setq tramp-default-method "ssh")
  (setq undo-tree-mode-lighter "")
  (setq use-dialog-box nil)
  (setq use-file-dialog nil)
  (setq visible-bell t)
  (setq x-select-enable-clipboard t)
  (setq-default indicate-empty-lines t)
  :hook
  (;;(geiser-mode . scheme-mode-hook)
   (ibuffer-auto-mode . ibuffer-mode-hook)
   (nolim . org-mode-hook)
   (nolim . web-mode-hook)
   (php-enable-psr2-coding-style . php-mode-hook)
   (php-refactor-mode . php-mode-hook))
  :bind (("C-g" . keyboard-quit-strong)))

(use-package minibuffer
  :config
;;; General minibuffer configurations
  ;; Super-powerful completion style for out-of-order groups of matches
  ;; using a comprehensive set of matching styles.
  (use-package orderless
    :ensure
    :config
    (setq orderless-regexp-separator "[/\s_-]+")
    (setq orderless-matching-styles
          '(orderless-flex
            orderless-strict-leading-initialism
            orderless-regexp
            orderless-prefixes
            orderless-literal))

    (defun prot/orderless-literal-dispatcher (pattern _index _total)
      (when (string-suffix-p "=" pattern)
        `(orderless-literal . ,(substring pattern 0 -1))))

    (defun prot/orderless-initialism-dispatcher (pattern _index _total)
      (when (string-suffix-p "," pattern)
        `(orderless-strict-leading-initialism . ,(substring pattern 0 -1))))

    (setq orderless-style-dispatchers
          '(prot/orderless-literal-dispatcher
            prot/orderless-initialism-dispatcher))
    :bind (:map minibuffer-local-completion-map
                ("SPC" . nil)))       ; Space should never complete: use
                                      ; it for `orderless' groups.

  (setq completion-styles
        '(orderless partial-completion))
  (setq completion-category-defaults nil)
  (setq completion-cycle-threshold 3)
  (setq completion-flex-nospace nil)
  (setq completion-pcm-complete-word-inserts-delimiters t)
  (setq completion-pcm-word-delimiters "-_./:| ")
  (setq completion-show-help nil)
  (setq completion-ignore-case t)
  (setq read-buffer-completion-ignore-case t)
  (setq read-file-name-completion-ignore-case t)
  (setq completions-format 'vertical)   ; *Completions* buffer
  (setq enable-recursive-minibuffers t)
  (setq read-answer-short t)
  (setq resize-mini-windows t)

  (file-name-shadow-mode 1)
  (minibuffer-depth-indicate-mode 1)
  (minibuffer-electric-default-mode 1)

;;; General minibuffer functions
  (defun prot/focus-minibuffer ()
    "Focus the active minibuffer.

Bind this to `completion-list-mode-map' to M-v to easily jump
between the list of candidates present in the \\*Completions\\*
buffer and the minibuffer (because by default M-v switches to the
completions if invoked from inside the minibuffer."
    (interactive)
    (let ((mini (active-minibuffer-window)))
      (when mini
        (select-window mini))))

  (defun prot/focus-minibuffer-or-completions ()
    "Focus the active minibuffer or the \\*Completions\\*.

If both the minibuffer and the Completions are present, this
command will first move per invocation to the former, then the
latter, and then continue to switch between the two.

The continuous switch is essentially the same as running
`prot/focus-minibuffer' and `switch-to-completions' in
succession."
    (interactive)
    (let* ((mini (active-minibuffer-window))
           (completions (get-buffer-window "*Completions*")))
      (cond ((and mini
                  (not (minibufferp)))
             (select-window mini nil))
            ((and completions
                  (not (eq (selected-window)
                           completions)))
             (select-window completions nil)))))

;;; Completions' buffer actions
  ;; NOTE In practice I only use those while inspecting a long list
  ;; produced by C-h {f,o,v}.  To pop the Completions buffer, use
  ;; `minibuffer-completion-help', by default bound to ? from inside the
  ;; minibuffer.

  (defun prot/completions-kill-save-symbol ()
    "Add symbol-at-point to the kill ring.

Intended for use in the \\*Completions\\* buffer.  Bind this to a
key in `completion-list-mode-map'."
    (interactive)
    (kill-new (thing-at-point 'symbol)))

  (defmacro prot/completions-buffer-act (name doc &rest body)
    `(defun ,name ()
       ,doc
       (interactive)
       (let ((completions-window (get-buffer-window "*Completions*"))
             (completions-buffer (get-buffer "*Completions*"))
             (symbol (thing-at-point 'symbol)))
         (if (window-live-p completions-window)
             (with-current-buffer completions-buffer
               ,@body)
           (user-error "No live window with Completions")))))

  (prot/completions-buffer-act
   prot/completions-kill-symbol-at-point
   "Add \"Completions\" buffer symbol-at-point to the kill ring."
   (kill-new `,symbol)
   (message "Copied %s to kill-ring"
            (propertize `,symbol 'face 'success)))

  (prot/completions-buffer-act
   prot/completions-insert-symbol-at-point
   "Add \"Completions\" buffer symbol-at-point to active window."
   (let ((window (window-buffer (get-mru-window))))
     (with-current-buffer window
       (insert `,symbol)
       (message "Inserted %s"
                (propertize `,symbol 'face 'success)))))

  (prot/completions-buffer-act
   prot/completions-insert-symbol-at-point-exit
   "Like `prot/completions-insert-symbol-at-point' plus exit."
   (prot/completions-insert-symbol-at-point)
   (top-level))

;;; Miscellaneous functions and key bindings

  ;; Technically, this is not specific to the minibuffer, but I define
  ;; it here so that you can see how it is also used from inside the
  ;; "Completions" buffer
  (defun prot/describe-symbol-at-point (&optional arg)
    "Get help (documentation) for the symbol at point.

With a prefix argument, switch to the *Help* window.  If that is
already focused, switch to the most recently used window
instead."
    (interactive "P")
    (let ((symbol (symbol-at-point)))
      (when symbol
        (describe-symbol symbol)))
    (when arg
      (let ((help (get-buffer-window "*Help*")))
        (when help
          (if (not (eq (selected-window) help))
              (select-window help)
            (select-window (get-mru-window)))))))
  
  ;; Defines, among others, aliases for common minibuffer commands to
  ;; Super-KEY.  Normally these should go in individual package
  ;; declarations, but their grouping here makes things easier to
  ;; understand.  Besides, they are related to the minibuffer.
  :bind (("s-f" . find-file)
         ("s-F" . find-file-other-window)
         ("s-d" . dired)
         ("s-D" . dired-other-window)
         ("s-b" . switch-to-buffer)
         ("s-B" . switch-to-buffer-other-window)
         ("s-v" . prot/focus-minibuffer-or-completions)
         ("s-h" . prot/describe-symbol-at-point)
         ("s-H" . (lambda ()
                    (interactive)
                    (prot/describe-symbol-at-point '(4))))
         :map minibuffer-local-completion-map
         ("<return>" . minibuffer-force-complete-and-exit) ; exit with completion
         ("C-j" . exit-minibuffer)      ; force input unconditionally
         :map completion-list-mode-map
         ("h" . prot/describe-symbol-at-point)
         ("w" . prot/completions-kill-symbol-at-point)
         ("i" . prot/completions-insert-symbol-at-point)
         ("j" . prot/completions-insert-symbol-at-point-exit)
         ("n" . next-line)
         ("p" . previous-line)
         ("f" . next-completion)
         ("b" . previous-completion)
         ("M-v" . prot/focus-minibuffer)))

(use-package py-autopep8 :ensure)

(use-package elpy
  :ensure
  :init
  (elpy-enable)
  :config
  (setq python-shell-interpreter "python")
  (setq python-shell-interpreter-args "-i"))

(use-package django-mode :ensure)

(use-package smooth-scrolling :ensure)

;; Add parts of each file's directory to the buffer name if not unique
(use-package uniquify-files
  :ensure
  :config
  (setq uniquify-buffer-name-style 'forward
        uniquify-separator ":"))

(use-package undo-tree
  :ensure
  :config
  (global-undo-tree-mode))
(provide 'sane-defaults)
;;; sane-defaults.el ends here
#+END_SRC

** setup-eshell.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-eshell.el
;;; setup-eshell.el
(use-package f :ensure)

(setq eshell-visual-commands
      '("less" "tmux" "htop" "top" "bash" "zsh" "fish"))

(setq eshell-visual-subcommands
      '(("git" "log" "l" "diff" "show")))

;; Prompt with a bit of help from http://www.emacswiki.org/emacs/EshellPrompt
(defmacro with-face (str &rest properties)
  `(propertize ,str 'face (list ,@properties)))

(defun eshell/abbr-pwd ()
  (let ((home (getenv "HOME"))
	(path (eshell/pwd)))
    (cond
     ((string-equal home path) "~")
     ((f-ancestor-of? home path) (concat "~/" (f-relative path home)))
     (path))))

(defun eshell/my-prompt ()
  (let ((header-bg "#161616"))
    (concat
     (with-face (eshell/abbr-pwd) :foreground "#008700")
     (if (= (user-uid) 0)
	 (with-face "#" :foreground "red")
       (with-face "$" :foreground "#2345ba"))
     " ")))

(eval-after-load 'eshell
  '(require 'eshell-autojump nil t))

(setq eshell-prompt-function 'eshell/my-prompt)
(setq eshell-highlight-prompt nil)
(setq eshell-prompt-regexp "^[^#$\n]+[#$] ")

(setq eshell-cmpl-cycle-completions nil)

;; ref: http://pragmaticemacs.com/emacs/pop-up-a-quick-shell-with-shell-pop/
(use-package shell-pop :ensure
  :config
  (defun shell-pop-zsh ()
    (interactive)
    (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
    (setq shell-pop-term-shell "/bin/zsh")
    ;; need to do this manually or not picked up by `shell-pop'
    (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)
    (call-interactively 'shell-pop))
  (defun shell-pop-eshell ()
    (interactive)
    (let ((shell-pop-shell-type '("eshell" "*eshell*" (lambda () (eshell))))
          (shell-pop-term-shell "eshell"))
      (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)
      (call-interactively 'shell-pop)))
  ;; :bind (("C-c z" . shell-pop-zsh)
  ;;        ("C-c t" . shell-pop-eshell))
  )

(provide 'setup-eshell)
;;; setup-eshell.el ends here
#+END_SRC
** setup-exwm.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-exwm.el
;;; setup-exwm.el
;; Load exwm
(use-package exwm
  :config
  (require 'exwm-randr)
  (setq exwm-randr-workspace-output-plist '(0 "eDP1"
        				      1 "eDP1"
        				      2 "HDMI1"
        				      3 "HDMI1"))
  (setq exwm-layout-show-all-buffers 't)
  (setq exwm-workspace-show-all-buffers 't)
  ;; Set the initial workspace number.
  (setq exwm-workspace-number 4)
  ;; Line-editing shortcuts
  (setq exwm-input-simulation-keys
	'(([?\C-b] . [left])
	  ([?\C-f] . [right])
	  ([?\C-p] . [up])
	  ([?\C-n] . [down])
	  ([?\C-a] . [home])
	  ([?\C-e] . [end])
	  ([?\M-v] . [prior])
	  ([?\C-v] . [next])
	  ([?\C-d] . [delete])
	  ([?\C-k] . [S-end delete])))
  ;; Make class name the buffer name
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))
  ;; Add these hooks in a suitable place (e.g., as done in exwm-config-default)
  (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)
  ;; Make gimp floating
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
        		  (string= "gimp" exwm-instance-name))
        	(rename-buffer exwm-class-name t))))
  ;; ;; Add these hooks in a suitable place (e.g., as done in exwm-config-default)
  (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)
  (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  ;; 's-w': Switch workspace
  (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)

  (dotimes (i 10)
    (exwm-input-set-key (kbd (format "s-%d" i))
			`(lambda ()
			   (interactive)
			   (exwm-workspace-switch-create ,i))))
  ;; 's-&': Launch application
  (exwm-input-set-key (kbd "s-&")
		      (lambda (command)
			(interactive (list (read-shell-command "$ ")))
			(start-process-shell-command command nil command)))
  (exwm-input-set-key (kbd "s-s") 'exwm-workspace-next)
  (exwm-input-set-key (kbd "s-j") 'exwm-workspace-next)
  (push ?\s-j exwm-input-prefix-keys)

  (exwm-input-set-key (kbd "s-o") 'other-window)
  (exwm-input-set-key (kbd "s-k") 'other-window)

  (push ?\s-o exwm-input-prefix-keys)
  (push ?\s-k exwm-input-prefix-keys)

  (exwm-input-set-key (kbd "s-p")
		      #'background-shell-command)

  ;; Enable EXWM
  (exwm-enable)
  (exwm-randr-enable)

  
  (add-hook 'exwm-update-title-hook
	    (lambda ()
	      (when (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
			(string= "gimp" exwm-instance-name))
		(rename-buffer exwm-title t))))
  :bind (("C-x C-c" . exwm-logout)))

(defun exwm-workspace-next ()
  (interactive)
  (let ((next-numb (mod (+ 1 exwm-workspace-current-index) exwm-workspace-number)))
    (exwm-workspace-switch next-numb)))

(defmacro exwm-switch-to-workspace-key (ws-num)
  `(progn (exwm-input-set-key (kbd (concat "s-" ,(number-to-string ws-num)))
			      (lambda ()
				(interactive)
				(exwm-workspace-switch ,ws-num)))
	  (let ((key-num (if (eq 0 ,ws-num)
			     10
			   ,ws-num)))
	    (exwm-input-set-key (kbd (concat "s-<f" (number-to-string key-num) ">"))
				(lambda ()
				  (interactive)
				  (exwm-workspace-switch ,ws-num))))))

(add-to-list 'display-buffer-alist
	     `(,(rx bos " *async command*")
	       (display-buffer-no-window)))

(defun background-shell-command (command)
  (interactive (list (read-shell-command "$ ")))
  (async-shell-command command (generate-new-buffer " *async command*")))

(defun exwm-rename-buffer ()
  (interactive)
  (exwm-workspace-rename-buffer
   (concat exwm-class-name ":"
           (if (<= (length exwm-title) 7) exwm-title
             (concat (substring exwm-title 0 6) "...")))))

;; (require 'exwm-systemtray)
;; (setq exwm-systemtray-height 16)
;; (exwm-systemtray-enable)
;; (exwm-switch-to-workspace-key 1)

(provide 'setup-exwm)

;;; setup-exwm.el ends here
#+END_SRC

** setup-helm.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-helm.el
;;; setup-helm.el
(use-package helm-ag :ensure)
(use-package helm :ensure
  :config
  (setq helm-split-window-in-side-P           t ; open helm buffer inside current window, not occupy whole other window
	helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
	helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	helm-ff-file-name-history-use-recentf t
	helm-echo-input-in-header-line t)

  (setq helm-autoresize-max-height 0)
  (setq helm-autoresize-min-height 20)
  (setq helm-buffers-fuzzy-matching t
	helm-recentf-fuzzy-match    t)
  (helm-autoresize-mode 1)
  (helm-mode 1)
  :bind (("C-x b" . helm-mini)
	 ("C-c h" . helm-command-prefix)
	 ("C-c M-x" . helm-M-x)
	 ("C-x r b" . helm-filtered-bookmarks)
	 ("C-x C-f" . helm-find-files)
	 ("M-y" . helm-show-kill-ring)
	 ("M-s o" . occur)
	 :map helm-map
	 ("<tab>" . helm-execute-persistent-action)
	 ("C-i" . helm-execute-persistent-action)
	 ("C-z" . helm-select-action)))

(setq ivy-display-style 'fancy)
;;advise swiper to recenter on exit
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter))
(advice-add 'swiper :after #'bjm-swiper-recenter)

(require 'helm)
(require 'helm-config)
(when (executable-find "curl")
  (setq helm-google-suggest-use-curl-p t))

;; set up helm projectile
(use-package helm-projectile :ensure)
(projectile-global-mode)
(setq projectile-completion-system 'helm)
(helm-projectile-on)
(setq projectile-switch-project-action 'helm-projectile)
(define-key projectile-mode-map (kbd "C-c p") 'projectile-command-map)
(use-package helm-exwm :ensure)
(provide 'setup-helm)

;;; setup-helm.el ends here
#+END_SRC
** setup-hledger.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-hledger.el
;;; setup-hledger.el

;; I've used `use-package` declarations

(use-package hledger-mode :ensure t
  :after htmlize
  :mode ("\\.journal\\'" "\\.hledger\\'")
  :commands hledger-enable-reporting
  :preface
  (defun hledger/next-entry ()
    "Move to next entry and pulse."
    (interactive)
    (hledger-next-or-new-entry)
    (hledger-pulse-momentary-current-entry))

  (defface hledger-warning-face
    '((((background dark))
       :background "Red" :foreground "White")
      (((background light))
       :background "Red" :foreground "White")
      (t :inverse-video t))
    "Face for warning"
    :group 'hledger)

  (defun hledger/prev-entry ()
    "Move to last entry and pulse."
    (interactive)
    (hledger-backward-entry)
    (hledger-pulse-momentary-current-entry))

  :bind (("C-c j" . hledger-run-command)
	 :map hledger-mode-map
	 ("C-c e" . hledger-jentry)
	 ("M-p" . hledger/prev-entry)
	 ("M-n" . hledger/next-entry))
  :init

  (setq hledger-jfile "~/Self/finances/hledger.journal"
	tab-width 4)
  ;; Expanded account balances in the overall monthly report are
  ;; mostly noise for me and do not convey any meaningful information.
  (setq hledger-show-expanded-report nil)
  (when (boundp 'my-hledger-service-fetch-url)
    (setq hledger-service-fetch-url
	  my-hledger-service-fetch-url))

  :config
  (setq company-mode t)
  (add-to-list 'auto-mode-alist '("\\.journal\\'" . hledger-mode))
  ;;(add-to-list 'company-backends 'hledger-company)
  (add-hook 'hledger-view-mode-hook #'hl-line-mode)
  (add-hook 'hledger-view-mode-hook #'center-text-for-reading)
  (add-hook 'hledger-view-mode-hook
	    (lambda ()
	      (run-with-timer 1
			      nil
			      (lambda ()
				(when (equal hledger-last-run-command
					     "balancesheet")
				  ;; highlight frequently changing accounts
				  (highlight-regexp "^.*\\(Ksh\\|Expense\\).*$")
				  (highlight-regexp "^.*Liability*$"
						    'hledger-warning-face))))))
  )

(use-package hledger-input
  :pin manual
  :load-path "packages/rest/hledger-mode/"
  :bind (("C-c e" . hledger-capture)
	 :map hledger-input-mode-map
	 ("C-c C-b" . popup-balance-at-point))
  :preface
  (defun popup-balance-at-point ()
    "Show balance for account at point in a popup."
    (interactive)
    (if-let ((account (thing-at-point 'hledger-account)))
	(message (hledger-shell-command-to-string (format " balance -N %s "
							  account)))
      (message "No account at point")))

  :config
  (setq hledger-input-buffer-height 20)
  (add-hook 'hledger-input-post-commit-hook #'hledger-show-new-balances)
  (add-hook 'hledger-input-mode-hook #'auto-fill-mode)
  (add-hook 'hledger-input-mode-hook
	    (lambda ()
	      (make-local-variable 'company-idle-delay)
	      (setq-local company-idle-delay 0.1))))

(provide 'setup-hledger)

;;; setup-hledger.el ends here
#+END_SRC
** setup-hugo.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-hugo.el
;;; setup-hugo.el
(use-package ox-hugo :ensure
  :after ox)
(use-package easy-hugo :ensure
  :init
  (setq easy-hugo-basedir "~/Public/BonfaceKilz/")
  (setq easy-hugo-url "https://bonfacemunyoki.com")
  (setq easy-hugo-sshdomain "myserver")
  (setq easy-hugo-root "/home/bonface/bonfacemunyoki.com/")
  (setq easy-hugo-previewtime "300"))

(provide 'setup-hugo)
;;; setup-hugo.el ends here
#+END_SRC

** setup-hydra.el
#+begin_src emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-hydra.el
(use-package hydra :ensure)

(defhydra hydra-org-template (:color blue :hint nil)
  "
 _c_enter    _q_uote     _e_macs-lisp    _L_aTeX:
 _l_atex     _E_xample   _p_ython        _i_ndex:
 _a_scii     _v_erse     _I_NCLUDE:      _H_TML:
 _s_rc       _n_ote      plant_u_ml      _A_SCII:
 _H_askell   ^ ^         ^ ^             _S_cheme:
"
  ("s" (hot-expand "<s"))
  ("S" (hot-expand "<s" "scheme"))
  ("E" (hot-expand "<e"))
  ("q" (hot-expand "<q"))
  ("v" (hot-expand "<v"))
  ("n" (hot-expand "<not"))
  ("c" (hot-expand "<c"))
  ("l" (hot-expand "<l"))
  ("H" (hot-expand "<s" "haskell"))
  ("a" (hot-expand "<a"))
  ("L" (hot-expand "<L"))
  ("i" (hot-expand "<i"))
  ("e" (hot-expand "<s" "emacs-lisp"))
  ("p" (hot-expand "<s" "python"))
  ("u" (hot-expand "<s" "plantuml :file CHANGE.png"))
  ("I" (hot-expand "<I"))
  ("A" (hot-expand "<A"))
  ("<" self-insert-command "ins")
  ("o" nil "quit"))

(defun hot-expand (str &optional mod header)
  "Expand org template.

STR is a structure template string recognised by org like <s. MOD is a
string with additional parameters to add the begin line of the
structure element. HEADER string includes more parameters that are
prepended to the element after the #+HEADER: tag."
  (let (text)
    (when (region-active-p)
      (setq text (buffer-substring (region-beginning) (region-end)))
      (delete-region (region-beginning) (region-end))
      (deactivate-mark))
    (when header (insert "#+HEADER: " header) (forward-line))
    (insert str)
    (org-tempo-complete-tag)
    (when mod (insert mod) (forward-line))
    (when text (insert text))))

(define-key org-mode-map "<"
  (lambda () (interactive)
    (if (or (region-active-p) (looking-back "^"))
        (hydra-org-template/body)
      (self-insert-command 1))))

(eval-after-load "org"
  '(cl-pushnew
    '("not" . "note")
    org-structure-template-alist))

(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(define-key dired-mode-map "." 'hydra-dired/body)


(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
  _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
 _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
  _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
"
  ("j" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("k" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" quit-window "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                                     :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                       :after-exit
                                       (if (eq major-mode 'ibuffer-mode)
                                           (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(define-key ibuffer-mode-map "." 'hydra-ibuffer-main/body)


(define-key Info-mode-map (kbd "?") #'hydra-info/body)
(defhydra hydra-info (:color blue
                             :hint nil)
  "
Info-mode:

  ^^_]_ forward  (next logical node)       ^^_l_ast (←)        _u_p (↑)                             _f_ollow reference       _T_OC
  ^^_[_ backward (prev logical node)       ^^_r_eturn (→)      _m_enu (↓) (C-u for new window)      _i_ndex                  _d_irectory
  ^^_n_ext (same level only)               ^^_H_istory         _g_oto (C-u for new window)          _,_ next index item      _c_opy node name
  ^^_p_rev (same level only)               _<_/_t_op           _b_eginning of buffer                virtual _I_ndex          _C_lone buffer
  regex _s_earch (_S_ case sensitive)      ^^_>_ final         _e_nd of buffer                      ^^                       _a_propos

  _1_ .. _9_ Pick first .. ninth item in the node's menu.

"
  ("]"   Info-forward-node)
  ("["   Info-backward-node)
  ("n"   Info-next)
  ("p"   Info-prev)
  ("s"   Info-search)
  ("S"   Info-search-case-sensitively)

  ("l"   Info-history-back)
  ("r"   Info-history-forward)
  ("H"   Info-history)
  ("t"   Info-top-node)
  ("<"   Info-top-node)
  (">"   Info-final-node)

  ("u"   Info-up)
  ("^"   Info-up)
  ("m"   Info-menu)
  ("g"   Info-goto-node)
  ("b"   beginning-of-buffer)
  ("e"   end-of-buffer)

  ("f"   Info-follow-reference)
  ("i"   Info-index)
  (","   Info-index-next)
  ("I"   Info-virtual-index)

  ("T"   Info-toc)
  ("d"   Info-directory)
  ("c"   Info-copy-current-node-name)
  ("C"   clone-buffer)
  ("a"   info-apropos)

  ("1"   Info-nth-menu-item)
  ("2"   Info-nth-menu-item)
  ("3"   Info-nth-menu-item)
  ("4"   Info-nth-menu-item)
  ("5"   Info-nth-menu-item)
  ("6"   Info-nth-menu-item)
  ("7"   Info-nth-menu-item)
  ("8"   Info-nth-menu-item)
  ("9"   Info-nth-menu-item)

  ("?"   Info-summary "Info summary")
  ("h"   Info-help "Info help")
  ("q"   Info-exit "Info exit")
  ("C-g" nil "cancel" :color blue))

(define-key org-agenda-mode-map
  "v" 'hydra-org-agenda-view/body)

(defun org-agenda-cts ()
  (let ((args (get-text-property
               (min (1- (point-max)) (point))
               'org-last-args)))
    (nth 2 args)))

(defhydra hydra-org-agenda-view (:hint none)
  "
_d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
_w_: ?w? week       _[_: inactive      _A_: arch-files
_t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
_m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
_y_: ?y? year       _q_: quit          _L__l__c_: ?l?"
  ("SPC" org-agenda-reset-view)
  ("d" org-agenda-day-view
   (if (eq 'day (org-agenda-cts))
       "[x]" "[ ]"))
  ("w" org-agenda-week-view
   (if (eq 'week (org-agenda-cts))
       "[x]" "[ ]"))
  ("t" org-agenda-fortnight-view
   (if (eq 'fortnight (org-agenda-cts))
       "[x]" "[ ]"))
  ("m" org-agenda-month-view
   (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
  ("y" org-agenda-year-view
   (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
  ("l" org-agenda-log-mode
   (format "% -3S" org-agenda-show-log))
  ("L" (org-agenda-log-mode '(4)))
  ("c" (org-agenda-log-mode 'clockcheck))
  ("f" org-agenda-follow-mode
   (format "% -3S" org-agenda-follow-mode))
  ("a" org-agenda-archives-mode)
  ("A" (org-agenda-archives-mode 'files))
  ("r" org-agenda-clockreport-mode
   (format "% -3S" org-agenda-clockreport-mode))
  ("e" org-agenda-entry-text-mode
   (format "% -3S" org-agenda-entry-text-mode))
  ("g" org-agenda-toggle-time-grid
   (format "% -3S" org-agenda-use-time-grid))
  ("D" org-agenda-toggle-diary
   (format "% -3S" org-agenda-include-diary))
  ("!" org-agenda-toggle-deadlines)
  ("["
   (let ((org-agenda-include-inactive-timestamps t))
     (org-agenda-check-type t 'timeline 'agenda)
     (org-agenda-redo)))
  ("q" (message "Abort") :exit t))

(defhydra hydra-org-agenda (:pre (setq which-key-inhibit t)
                                 :post (setq which-key-inhibit nil)
                                 :hint none)
  "
Org agenda (_q_uit)

^Clock^      ^Visit entry^              ^Date^             ^Other^
^-----^----  ^-----------^------------  ^----^-----------  ^-----^---------
_ci_ in      _SPC_ in other window      _ds_ schedule      _gr_ reload
_co_ out     _TAB_ & go to location     _dd_ set deadline  _._  go to today
_cq_ cancel  _RET_ & del other windows  _dt_ timestamp     _gd_ go to date
_cj_ jump    _o_   link                 _+_  do later      ^^
^^           ^^                         _-_  do earlier    ^^
^^           ^^                         ^^                 ^^
^View^          ^Filter^                 ^Headline^         ^Toggle mode^
^----^--------  ^------^---------------  ^--------^-------  ^-----------^----
_vd_ day        _ft_ by tag              _ht_ set status    _tf_ follow
_vw_ week       _fr_ refine by tag       _hk_ kill          _tl_ log
_vt_ fortnight  _fc_ by category         _hr_ refile        _ta_ archive trees
_vm_ month      _fh_ by top headline     _hA_ archive       _tA_ archive files
_vy_ year       _fx_ by regexp           _h:_ set tags      _tr_ clock report
_vn_ next span  _fd_ delete all filters  _hp_ set priority  _td_ diaries
_vp_ prev span  ^^                       ^^                 ^^
_vr_ reset      ^^                       ^^                 ^^
^^              ^^                       ^^                 ^^
"
  ;; Entry
  ("hA" org-agenda-archive-default)
  ("hk" org-agenda-kill)
  ("hp" org-agenda-priority)
  ("hr" org-agenda-refile)
  ("h:" org-agenda-set-tags)
  ("ht" org-agenda-todo)
  ;; Visit entry
  ("o"   link-hint-open-link :exit t)
  ("<tab>" org-agenda-goto :exit t)
  ("TAB" org-agenda-goto :exit t)
  ("SPC" org-agenda-show-and-scroll-up)
  ("RET" org-agenda-switch-to :exit t)
  ;; Date
  ("dt" org-agenda-date-prompt)
  ("dd" org-agenda-deadline)
  ("+" org-agenda-do-date-later)
  ("-" org-agenda-do-date-earlier)
  ("ds" org-agenda-schedule)
  ;; View
  ("vd" org-agenda-day-view)
  ("vw" org-agenda-week-view)
  ("vt" org-agenda-fortnight-view)
  ("vm" org-agenda-month-view)
  ("vy" org-agenda-year-view)
  ("vn" org-agenda-later)
  ("vp" org-agenda-earlier)
  ("vr" org-agenda-reset-view)
  ;; Toggle mode
  ("ta" org-agenda-archives-mode)
  ("tA" (org-agenda-archives-mode 'files))
  ("tr" org-agenda-clockreport-mode)
  ("tf" org-agenda-follow-mode)
  ("tl" org-agenda-log-mode)
  ("td" org-agenda-toggle-diary)
  ;; Filter
  ("fc" org-agenda-filter-by-category)
  ("fx" org-agenda-filter-by-regexp)
  ("ft" org-agenda-filter-by-tag)
  ("fr" org-agenda-filter-by-tag-refine)
  ("fh" org-agenda-filter-by-top-headline)
  ("fd" org-agenda-filter-remove-all)
  ;; Clock
  ("cq" org-agenda-clock-cancel)
  ("cj" org-agenda-clock-goto :exit t)
  ("ci" org-agenda-clock-in :exit t)
  ("co" org-agenda-clock-out)
  ;; Other
  ("q" nil :exit t)
  ("gd" org-agenda-goto-date)
  ("." org-agenda-goto-today)
  ("gr" org-agenda-redo))

(define-key org-agenda-mode-map
  "e" 'hydra-org-agenda/body)


(defhydra hydra-global-org (:color blue
                                   :hint nil
                                   :body-pre (setq exwm-input-line-mode-passthrough ''t)
                                   :post (setq exwm-input-line-mode-passthrough nil))
  "
Timer^^           ^Clock^         ^Capture^         ^Other^            ^Hugo^
--------------------------------------------------------------------------------
[_C-t_]tart        _w_ clock in    _c_apture         _,_ Priority
[_C-s_]top         _o_ clock out   _l_ast capture    _s_ rifle-current
_r_eset            _j_ clock goto                  _\\_ pretty-entes
_p_rint                                         _g_ view-markdown       _e_xport-dispatch
                                              _G_ convert-markdown
"
                                        ;("t" org-timer-start)
  ("C-t"  org-timer-start)
  ("s" helm-org-rifle-current-buffer)
  ("S" helm-org-rifle)
  ("C-s"  org-timer-stop)
  ("C-S"  org-timer-stop)
  ;; Need to be at timer
  ("r" org-timer-set-timer)
  ("C-r"  org-timer-set-timer)
  ;; Print timer value to buffer
  ("p" org-timer)
  ("C-p"  org-timer)
  ("w" (org-clock-in '(4)))
  ("C-w"  (org-clock-in '(4)))
  ("o" org-clock-out)
  ("C-o"  org-clock-out)
  ;; Visit the clocked task from any buffer
  ("j" org-clock-goto)
  ("C-j"  org-clock-goto)
  ("c" helm-org-capture-templates) ;org-capture
  ("C-c"  helm-org-capture-templates) ;org-capture
  ("l" org-capture-goto-last-stored)
  ("C-l"  org-capture-goto-last-stored)
  ("," org-priority)
  ("C-,"  org-priority)
  ("e" org-export-dispatch)
  ("g" org-gfm-export-as-markdown)
  ("G" org-gfm-convert-region-to-md)
  ("\\" org-toggle-pretty-entities))

(use-package avy)

(defhydra hydra-avy-move-actions (:exit t
                                        :columns 2
                                        :after-exit (setq ot/avy-selected-pt nil)
                                        :idle 1.0)
  "Avy actions"
  ("f" (ot/avy-action-move-sexp-forward-here ot/avy-selected-pt) "Forward until end of expression")
  ("b" (ot/avy-action-move-sexp-backward-here ot/avy-selected-pt) "Backward until begin of expression")
  ("e" (ot/avy-action-move-sexp-here ot/avy-selected-pt) "Sexp")
  ("RET" (ot/avy-action-move-sexp-here ot/avy-selected-pt) "Sexp")
  ("s" (ot/avy-action-move-symbol-here ot/avy-selected-pt) "Symbol")
  ("(" (ot/avy-action-move-surrounding-sexp-here ot/avy-selected-pt) "Surrounding sexp"))

(defhydra hydra-avy-copy-actions (:exit t
                                        :columns 2
                                        :after-exit (setq ot/avy-selected-pt nil)
                                        :idle 1.0)
  "Avy actions"
  ("f" (ot/avy-action-copy-sexp-forward-here ot/avy-selected-pt) "Forward until end of expression")
  ("b" (ot/avy-action-copy-sexp-backward-here ot/avy-selected-pt) "Backward until begin of expression")
  ("e" (ot/avy-action-copy-sexp-here ot/avy-selected-pt) "Sexp")
  ("RET" (ot/avy-action-copy-sexp-here ot/avy-selected-pt) "Sexp")
  ("s" (ot/avy-action-copy-symbol-here ot/avy-selected-pt) "Symbol")
  ("(" (ot/avy-action-copy-surrounding-sexp-here ot/avy-selected-pt) "Surrounding sexp"))

(defhydra hydra-avy (:exit t :hint nil)
  "
 Line^^       Region^^        Goto                                 ^Actions^
--------------------------------------------------------------------------------
 [_y_] yank   [_Y_] yank      [_c_] timed char  [_C_] char         co_p_y-actions
 [_m_] move   [_M_] move      [_w_] word        [_W_] any word     mo_v_e-actions
 [_k_] kill   [_K_] kill      [_l_] line        [_L_] end of line"
  ("c" avy-goto-char-timer)
  ("C" avy-goto-char)
  ("w" avy-goto-word-1)
  ("W" avy-goto-word-0)
  ("l" avy-goto-line)
  ("L" avy-goto-end-of-line)
  ("m" avy-move-line)
  ("M" avy-move-region)
  ("k" avy-kill-whole-line)
  ("K" avy-kill-region)
  ("y" avy-copy-line)
  ("p" hydra-avy-copy-actions/body)
  ("v" hydra-avy-move-actions/body)
  ("Y" avy-copy-region))

(use-package ace-jump-mode :ensure)
(defhydra hydra-ace (:exit t :hint nil)
  "
 Move across windows^^
-----------------------
 [_m_] head character
 [_c_] character
 [_w_] word
 [_l_] line"
  ("m" ace-jump-mode)
  ("c" ace-jump-char-mode)
  ("w" ace-jump-word-mode)
  ("l" ace-jump-line-mode))

(require 'rect)
(defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                     :color pink
                                     :post (deactivate-mark))
  "
  ^_k_^     _d_elete    _s_tring
_h_   _l_   _o_k        _y_ank
  ^_j_^     _n_ew-copy  _r_eset
^^^^        _e_xchange  _u_ndo
^^^^        ^ ^         _x_kill
"
  ("h" rectangle-backward-char nil)
  ("l" rectangle-forward-char nil)
  ("k" rectangle-previous-line nil)
  ("j" rectangle-next-line nil)
  ("e" hydra-ex-point-mark nil)
  ("n" copy-rectangle-as-kill nil)
  ("d" delete-rectangle nil)
  ("r" (if (region-active-p)
           (deactivate-mark)
         (rectangle-mark-mode 1)) nil)
  ("y" yank-rectangle nil)
  ("u" undo nil)
  ("s" string-rectangle nil)
  ("x" kill-rectangle nil)
  ("o" nil nil))


;; Hydra - Marking
(defhydra hydra-mark (:exit t
                            :columns 3
                            :idle 1.0)
  "Mark"
  ("d" er/mark-defun "Defun / Function")
  ("f" er/mark-defun "Defun / Function")
  ("F" er/mark-clj-function-literal "Clj anonymous fn")
  ("w" er/mark-word "Word")
  ("W" er/mark-clj-word "CLJ word")
  ("u" er/mark-url "Url")
  ("e" mark-sexp "S-Expression")
  ("E" er/mark-email "Email")
  ("b" hydra-mark-buffer/body "Buffer")
  ("l" mark-line "Line")
  ("p" er/mark-text-paragraph "Paragraph")
  ("r" er/mark-clj-regexp-literal "Clj regexp")
  ("s" er/mark-symbol "Symbol")
  ("S" er/mark-symbol-with-prefix "Prefixed symbol")
  ("q" er/mark-inside-quotes "Inside quotes")
  ("Q" er/mark-outside-quotes "Outside quotes")
  ("(" er/mark-inside-pairs "Inside pairs")
  ("[" er/mark-inside-pairs "Inside pairs")
  ("{" er/mark-inside-pairs "Inside pairs")
  (")" er/mark-outside-pairs "Outside pairs")
  ("]" er/mark-outside-pairs "Outside pairs")
  ("}" er/mark-outside-pairs "Outside pairs")
  ("t" er/mark-inner-tag "Inner tag")
  ("T" er/mark-outer-tag "Outer tag")
  ("c" er/mark-comment "Comment")
  ("a" er/mark-html-attribute "HTML attribute")
  ("." er/expand-region "Expand region" :exit nil)
  ("," er/contract-region "Contract region" :exit nil)
  ("#" er/mark-clj-set-literal "Clj set")
  )

(defhydra hydra-mark-buffer (:exit t
                                   :idle 1.0)
  "Mark buffer"
  ("w" mark-whole-buffer "Whole buffer")
  ("a" mark-buffer-after-point "Buffer after point")
  ("b" mark-buffer-before-point "Buffer before point"))

;; Hydra - Yank
(defhydra hydra-yank-pop ()
  "yank"
  ("C-y" yank nil)
  ("M-y" yank-pop nil)
  ("y" (yank-pop 1) "next")
  ("Y" (yank-pop -1) "prev")
  ("l" helm-show-kill-ring "list" :exit t))   ; or browse-kill-ring

(defhydra hydra-copy (:exit t
                            :idle 1.0)
  "Copy"
  ("r" avy-copy-region "Region to point")
  ("l" avy-copy-line "Line to point")
  ("i" copy-inner "Inner")
  ("o" copy-outer "Outer"))

;; Hydra - Goto line
(defhydra hydra-goto-line (goto-map ""
                                    :pre (linum-mode 1)
                                    :post (linum-mode -1))
  "goto-line"
  ("g" goto-line "go")
  ("m" set-mark-command "mark" :bind nil)
  ("q" nil "quit"))

;; Hydra - Multiple cursors
(defhydra multiple-cursors-hydra (:columns 3
                                           :idle 1.0)
  "Multiple cursors"
  ("l" mc/edit-lines "Edit lines in region" :exit t)
  ("b" mc/edit-beginnings-of-lines "Edit beginnings of lines in region" :exit t)
  ("e" mc/edit-ends-of-lines "Edit ends of lines in region" :exit t)
  ("a" mc/mark-all-dwim "Mark all dwim" :exit t)
  ("S" mc/mark-all-symbols-like-this "Mark all symbols likes this" :exit t)
  ("w" mc/mark-all-words-like-this "Mark all words like this" :exit t)
  ("r" mc/mark-all-in-region "Mark all in region" :exit t)
  ("R" mc/mark-all-in-region-regexp "Mark all in region (regexp)" :exit t)
  ("d" mc/mark-all-like-this-in-defun "Mark all like this in defun" :exit t)
  ("s" mc/mark-all-symbols-like-this-in-defun "Mark all symbols like this in defun" :exit t)
  ("W" mc/mark-all-words-like-this-in-defun "Mark all words like this in defun" :exit t)
  ("i" mc/insert-numbers "Insert numbers" :exit t)
  ("n" mc/mark-next-like-this "Mark next like this")
  ("N" mc/skip-to-next-like-this "Skip to next like this")
  ("M-n" mc/unmark-next-like-this "Unmark next like this")
  ("p" mc/mark-previous-like-this "Mark previous like this")
  ("P" mc/skip-to-previous-like-this "Skip to previous like this")
  ("M-p" mc/unmark-previous-like-this "Unmark previous like this")
  ("q" nil "Quit" :exit t))

(defhydra hydra-paredit (:color blue
                                :columns 3
                                :idle 1.0)
  "Paredit"
  ("(" paredit-wrap-round "Wrap round")
  ("[" paredit-wrap-square "Wrap square")
  ("]" paredit-wrap-square "Wrap square")
  ("{" paredit-wrap-curly "Wrap curly")
  ("s" paredit-splice-sexp "Splice")
  ("bs" cljr-splice-sexp-killing-backward "Splice kill backward")
  ("fs" cljr-splice-sexp-killing-forward "Splice kill forward")
  ("S" paredit-split-sexp "Split")
  ("j" paredit-join-sexps "Join")
  ("J" paredit-join-with-next-list "Join next list")
  ("M-J" paredit-join-with-previous-list "Join prev list")
  ("C" paredit-convolute-sexp "Convolute")
  ("M-c" paredit-copy-as-kill "Copy as kill")
  ("r" paredit-raise-sexp "Raise s-expression")
  ("R" cljr-raise-sexp "Raise s-expression (cljr)")
  ("c" paxedit-copy "Copy explicit expression, implicit expression, or comment")
  ("d" paxedit-delete "Delete expression")
  ("tb" paxedit-transpose-backward "Transpose backward")
  ("tf" paxedit-transpose-forward "Transpose forward")
  ("k" paxedit-kill "Kill explicit expression, implicit expression, or comment")
  (";" paxedit-wrap-comment "Wrap with comment"))

(defhydra hydra-transpose (:exit t
                                 :columns 3
                                 :idle 1.0)
  "Transpose"
  ("w" transpose-words "Words")
  ("W" ace-swap-window "Windows / Buffers")
  ("b" ace-swap-window "Windows / Buffers")
  ("l" transpose-lines "Lines")
  ("e" transpose-sexps "S-expressions")
  ("s" transpose-sexps "S-expressions")
  ("p" transpose-paragraphs "Paragraphs"))


(defhydra hydra-lisp-eval (:exit t
                                 :columns 2
                                 :idle 1.0)
  "Lisp eval"
  ("r" eval-region "Region")
  ("b" eval-buffer "Buffer")
  ("e" eval-expression "S-expression")
  ("l" eval-last-sexp "Last s-expression")
  ("L" eval-last-sexp-print-value "Last s-expression and print value")
  ("d" eval-defun "Defun / Function")
  ("f" eval-defun "Defun / Function"))

(defhydra hydra-ag (:exit t
                          :columns 2
                          :idle 1.0)
  "Ag Search"
  ("c" helm-ag "Current directory")
  ("d" (lambda ()
         (interactive)
         (let ((current-prefix-arg '(4)))
           (call-interactively 'helm-ag))) "Select directory")
  ("D" helm-do-ag "Select directory (interactive)")
  ("f" helm-ag-this-file "Current file")
  ("F" helm-do-ag-this-file "Current file (interactive)")
  ("p" helm-ag-project-root "Project")
  ("b" helm-ag-buffers "Buffers")
  ("B" helm-do-ag-buffers "Buffers (interactive)"))

(defhydra hydra-yasnippet (:color blue :hint nil)
  "
              ^YASnippets^
--------------------------------------------
  Modes:    Load/Visit:    Actions:

 _g_lobal  _d_irectory    _i_nsert
 _m_inor   _f_ile         _t_ryout
 _e_xtra   _l_ist         _n_ew
         _a_ll
"
  ("d" yas-load-directory)
  ("e" yas-activate-extra-mode)
  ("i" yas-insert-snippet)
  ("f" yas-visit-snippet-file :color blue)
  ("n" yas-new-snippet)
  ("t" yas-tryout-snippet)
  ("l" yas-describe-tables)
  ("g" yas-global-mode)
  ("m" yas-minor-mode)
  ("a" yas-reload-all))

;; @see https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org
;; gnus-group-mode
(eval-after-load 'gnus-group
  '(progn
     (defhydra hydra-gnus-group (:color blue)
       "
[_A_] Remote groups (A A) [_g_] Refresh
[_L_] Local groups        [_\\^_] List servers
[_c_] Mark all read       [_m_] Compose new mail
[_G_] Search mails (G G) [_#_] Mark mail
"
       ("A" gnus-group-list-active)
       ("L" gnus-group-list-all-groups)
       ("c" gnus-topic-catchup-articles)
       ("G" dianyou-group-make-nnir-group)
       ("g" gnus-group-get-new-news)
       ("^" gnus-group-enter-server-mode)
       ("m" gnus-group-new-mail)
       ("#" gnus-topic-mark-topic)
       ("q" nil))
     ;; y is not used by default
     (define-key gnus-group-mode-map "y" 'hydra-gnus-group/body)))

;; gnus-summary-mode
(eval-after-load 'gnus-sum
  '(progn
     (defhydra hydra-gnus-summary (:color blue)
       "
[_s_] Show thread   [_F_] Forward (C-c C-f)
[_h_] Hide thread   [_e_] Resend (S D e)
[_n_] Refresh (/ N) [_r_] Reply
[_!_] Mail -> disk  [_R_] Reply with original
[_d_] Disk -> mail  [_w_] Reply all (S w)
[_c_] Read all      [_W_] Reply all with original (S W)
[_#_] Mark          [_G_] Search mails
"
       ("s" gnus-summary-show-thread)
       ("h" gnus-summary-hide-thread)
       ("n" gnus-summary-insert-new-articles)
       ("F" gnus-summary-mail-forward)
       ("!" gnus-summary-tick-article-forward)
       ("d" gnus-summary-put-mark-as-read-next)
       ("c" gnus-summary-catchup-and-exit)
       ("e" gnus-summary-resend-message-edit)
       ("R" gnus-summary-reply-with-original)
       ("r" gnus-summary-reply)
       ("W" gnus-summary-wide-reply-with-original)
       ("w" gnus-summary-wide-reply)
       ("#" gnus-topic-mark-topic)
       ("G" dianyou-group-make-nnir-group)
       ("q" nil))
     ;; y is not used by default
     (define-key gnus-summary-mode-map "y" 'hydra-gnus-summary/body)))

;; gnus-article-mode
(eval-after-load 'gnus-art
  '(progn
     (defhydra hydra-gnus-article (:color blue)
       "
[_o_] Save attachment        [_F_] Forward
[_v_] Play video/audio       [_r_] Reply
[_d_] CLI to download stream [_R_] Reply with original
[_b_] Open external browser  [_w_] Reply all (S w)
[_f_] Click link/button      [_W_] Reply all with original (S W)
[_g_] Focus link/button
"
       ("F" gnus-summary-mail-forward)
       ("r" gnus-article-reply)
       ("R" gnus-article-reply-with-original)
       ("w" gnus-article-wide-reply)
       ("W" gnus-article-wide-reply-with-original)
       ("o" gnus-mime-save-part)
       ("v" w3mext-open-with-mplayer)
       ("d" w3mext-download-rss-stream)
       ("b" w3mext-open-link-or-image-or-url)
       ("f" w3m-lnum-follow)
       ("g" w3m-lnum-goto)
       ("q" nil))
     ;; y is not used by default
     (define-key gnus-article-mode-map "y" 'hydra-gnus-article/body)))

;; message-mode
(eval-after-load 'message
  '(progn
     (defhydra hydra-message (:color blue)
  "
[_c_] Complete mail address
[_a_] Attach file
[_s_] Send mail (C-c C-c)
"
       ("c" ebdb-counsel)
       ("a" mml-attach-file)
       ("s" message-send-and-exit)
       ("i" dianyou-insert-email-address-from-received-mails)
       ("q" nil))))

(defun message-mode-hook-hydra-setup ()
  (local-set-key (kbd "C-c C-y") 'hydra-message/body))
(add-hook 'message-mode-hook 'message-mode-hook-hydra-setup)

(defhydra dumb-jump-hydra (:color blue :columns 3)
    "Dumb Jump"
    ("j" dumb-jump-go "Go")
    ("o" dumb-jump-go-other-window "Other window")
    ("e" dumb-jump-go-prefer-external "Go external")
    ("x" dumb-jump-go-prefer-external-other-window "Go external other window")
    ("i" dumb-jump-go-prompt "Prompt")
    ("l" dumb-jump-quick-look "Quick look")
    ("b" dumb-jump-back "Back"))

(provide 'setup-hydra)
;;; setup-hydra.el ends here
#+end_src
** setup-init.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-init.el
;;;; setup-init.el

;; Initial setup
(use-package emacs
  :preface
  ;; A very simple function to recreate the scratch buffer:
  ;; ( http://emacswiki.org/emacs/RecreateScratchBuffer )
  (defun scratch ()
    "create a scratch buffer"
    (interactive)
    (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
    (insert initial-scratch-message)
    (org-mode))
  :config
  (defvar bootstrap-version)
  (let ((bootstrap-file
         (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
        (bootstrap-version 5))
    (unless (file-exists-p bootstrap-file)
      (with-current-buffer
          (url-retrieve-synchronously
           "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
           'silent 'inhibit-cookies)
        (goto-char (point-max))
        (eval-print-last-sexp)))
    (load bootstrap-file nil 'nomessage)
    (setq initial-scratch-message
          (concat
           "#+Title: Persistent Scratch Buffer"
           "\n#\n # Welcome! This’ a place for trying things out. \n"))))

;; Emacs server
(use-package server
  :config
  (unless (server-running-p)
    (server-start)))

(provide 'setup-init)

;;;; setup-init.el ends here
#+END_SRC
** setup-keybindings.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-keybindings.el
;;; setup-keybindings.el
(use-package key-seq :ensure)

(key-chord-mode 1)

(key-seq-define-global ",g" 'counsel-git)

(bind-keys* ("C-s" . helm-swoop)
            ("C-c g" . counsel-git)
            ("C-c j" . counsel-git-grep)
            ("C-c k" . counsel-ag))

(global-set-key (kbd "C-S") 'helm-swoop-back-to-last-point)
(global-set-key (kbd "C-c C-s") 'helm-multi-swoop)


(global-set-key (kbd "<s-mouse-3>") 'split-window-below)
(global-set-key (kbd "<s-mouse-1>") 'split-window-right)
(global-set-key [double-mouse-3] 'delete-window)
(global-set-key [double-mouse-1] 'delete-other-windows)

;;;;;;;;;;;;;;;;
;; Appearance ;;
;;;;;;;;;;;;;;;;
(global-set-key (kbd "C-x t") 'my/toggle-theme)
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)

;; Unclutter the mode-line
;; My misc key bindings
(global-set-key (kbd "RET") 'newline-and-indent)
(global-set-key (kbd "M-/") 'hippie-expand)
(global-set-key (kbd "C-x g") 'magit-status)
(global-set-key (kbd "C-x f") 'recentf-open-files)
(global-set-key (kbd "C-x M-t") 'cleanup-region)
(use-package expand-region :ensure
  :config (global-set-key (kbd "C-=") 'er/expand-region))
(use-package zoom-window :ensure
  :config (global-set-key (kbd "C-x C-z") 'zoom-window-zoom))
;; setting up multiple cursors
(use-package multiple-cursors :ensure
  :config
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
  (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click))
;; setting up smart-forward
(use-package smart-forward :ensure
  :config
  (global-set-key (kbd "M-S-<up>") 'smart-up)
  (global-set-key (kbd "M-S-<down>") 'smart-down)
  (global-set-key (kbd "M-S-<left>") 'smart-backward)
  (global-set-key (kbd "M-S-<right>") 'smart-forward))
(use-package change-inner :ensure)
(require 'change-inner)
(global-set-key (kbd "M-S-i") 'change-inner)
(global-set-key (kbd "M-S-o") 'change-outer)



;; Map files to modes
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-x b") 'helm-buffers-list)
(global-set-key (kbd "C-x C-b") 'ibuffer)
(global-set-key (kbd "C-c C-r") 'helm-recentf)


;;;;;;;;;;
;; helm ;;
;;;;;;;;;;
;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
(global-unset-key (kbd "C-x c"))
(define-key global-map [remap find-file] 'helm-find-files)
(define-key global-map [remap list-buffers] 'helm-buffers-list)
(define-key global-map [remap dabbrev-expand] 'helm-dabbrev)
(define-key global-map [remap execute-extended-command] 'helm-M-x)

(unless (boundp 'completion-in-region-function)
  (define-key lisp-interaction-mode-map [remap completion-at-point] 'helm-lisp-completion-at-point)
  (define-key emacs-lisp-mode-map       [remap completion-at-point] 'helm-lisp-completion-at-point))
(global-set-key (kbd "C-c b") 'helm-exwm)


;;;;;;;;;;
;; hugo ;;
;;;;;;;;;;
(define-key global-map (kbd "C-c C-e") 'easy-hugo)

;;;;;;;;;;;;;
;; paredit ;;
;;;;;;;;;;;;;
(define-key paredit-mode-map (kbd "M-(") 'paredit-wrap-round)
(define-key paredit-mode-map (kbd "M-)") 'paredit-wrap-round-from-behind)
(define-key paredit-mode-map (kbd "M-s-8") 'paredit-wrap-square)
(define-key paredit-mode-map (kbd "M-s-9") 'paredit-wrap-square-from-behind)
(define-key paredit-mode-map (kbd "M-s-(") 'paredit-wrap-curly)
(define-key paredit-mode-map (kbd "M-s-)") 'paredit-wrap-curly-from-behind)

(define-key paredit-mode-map (kbd "C-w") 'paredit-kill-region-or-backward-word)
(define-key paredit-mode-map (kbd "M-C-<backspace>") 'backward-kill-sexp)

;; Change nasty paredit keybindings
(defvar my-nasty-paredit-keybindings-remappings
  '(("M-s"         "s-s"         paredit-splice-sexp)
    ("M-<up>"      "s-<up>"      paredit-splice-sexp-killing-backward)
    ("M-<down>"    "s-<down>"    paredit-splice-sexp-killing-forward)
    ("C-<right>"   "s-<right>"   paredit-forward-slurp-sexp)
    ("C-<left>"    "s-<left>"    paredit-forward-barf-sexp)
    ("C-M-<left>"  "s-S-<left>"  paredit-backward-slurp-sexp)
    ("C-M-<right>" "s-S-<right>" paredit-backward-barf-sexp)))

(define-key paredit-mode-map (kbd "s-r") 'paredit-raise-sexp)

(--each my-nasty-paredit-keybindings-remappings
  (let ((original (car it))
        (replacement (cadr it))
        (command (car (last it))))
    (define-key paredit-mode-map (read-kbd-macro original) nil)
    (define-key paredit-mode-map (read-kbd-macro replacement) command)))

;; don't hijack \ please
(define-key paredit-mode-map (kbd "\\") nil)

;;;;;;;;;;;;;;;;;
;; perspective ;;
;;;;;;;;;;;;;;;;;
(define-key persp-mode-map (kbd "C-x p -") 'custom-persp-last)
(define-key projectile-mode-map (kbd "s-w") 'projectile-persp-switch-project)

;;;;;;;;;;;;;;;;;;;
;; switch-window ;;
;;;;;;;;;;;;;;;;;;;
(use-package switch-window :ensure
  :config
  (global-set-key (kbd "M-o") 'switch-window)

  (global-set-key (kbd "C-x 1") 'switch-window-then-maximize)
  (global-set-key (kbd "C-x 2") 'switch-window-then-split-below)
  (global-set-key (kbd "C-x 3") 'switch-window-then-split-right)
  (global-set-key (kbd "C-x 0") 'switch-window-then-delete)

  (global-set-key (kbd "C-x 4 d") 'switch-window-then-dired)
  (global-set-key (kbd "C-x 4 f") 'switch-window-then-find-file)
  (global-set-key (kbd "C-x 4 m") 'switch-window-then-compose-mail)
  (global-set-key (kbd "C-x 4 r") 'switch-window-then-find-file-read-only)

  (global-set-key (kbd "C-x 4 C-f") 'switch-window-then-find-file)
  (global-set-key (kbd "C-x 4 C-o") 'switch-window-then-display-buffer)

  (global-set-key (kbd "C-x 4 0") 'switch-window-then-kill-buffer))

;;;;;;;;;
;; org ;;
;;;;;;;;;
(global-set-key (kbd "C-c C-x C-r") 'org-clock-report)




;;;;;;;;;;;
;; Hydra ;;
;;;;;;;;;;;
(global-set-key (kbd "C-x j") 'dumb-jump-hydra/body)
(global-set-key (kbd "s-g") 'hydra-avy/body)
(global-set-key (kbd "C-x SPC") 'hydra-rectangle/body)
(global-set-key (kbd "C-c o") 'hydra-global-org/body)
(global-set-key (kbd "M-g M-g") 'hydra-goto-line/body)
(global-set-key (kbd "C-c m") 'hydra-mark/body)
(key-seq-define-global "./" 'hydra-mark/body)
(key-seq-define-global ".m" 'hydra-mark-buffer/body)
(key-seq-define-global "-a" 'hydra-ag/body)
(key-seq-define emacs-lisp-mode-map "-e" 'hydra-lisp-eval/body)
(key-seq-define-global ",p" 'projectile-command-map)
(key-seq-define-global ",." 'multiple-cursors-hydra/body)
(key-seq-define-global ",," 'avy-goto-char-timer)
(key-seq-define-global ",w" 'hydra-copy/body)
(key-seq-define-global "-y" 'hydra-yasnippet/body)

(provide 'setup-keybindings)
;;; setup-keybindings.el ends here
#+END_SRC
** setup-js2-mode.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-js2-mode.el
;;; setup-js2-mode.el --- tweak js2 settings -*- lexical-binding: t; -*-

(setq-default js2-allow-rhino-new-expr-initializer nil)
(setq-default js2-auto-indent-p nil)
(setq-default js2-enter-indents-newline nil)

(setq-default js2-idle-timer-delay 0.1)
(setq-default js2-indent-on-enter-key nil)
(setq-default js2-mirror-mode nil)
(setq-default js2-strict-inconsistent-return-warning nil)
(setq-default js2-auto-indent-p t)
(setq-default js2-include-rhino-externs nil)
(setq-default js2-include-gears-externs nil)
(setq-default js2-include-node-externs t)
(setq-default js2-concat-multiline-strings 'eol)
(setq-default js2-rebind-eol-bol-keys nil)

;; Let flycheck handle parse errors
(setq-default js2-show-parse-errors nil)
(setq-default js2-strict-missing-semi-warning nil)
(setq-default js2-strict-trailing-comma-warning t) ;; jshint does not warn about this now for some reason
(use-package flycheck)
(add-hook 'js2-mode-hook (lambda () (flycheck-mode 1)))

(use-package js2-refactor)
(js2r-add-keybindings-with-prefix "C-c C-r")

(add-hook 'js2-mode-hook (lambda ()
                           (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
(setq js2-skip-preprocessor-directives t)
(js2r-add-keybindings-with-prefix "C-c C-m")

(require 'js2-imenu-extras)

(js2-imenu-extras-setup)

(defun js2r--remove-all-this-cruft-on-backward-delete ()
  (set-temporary-overlay-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "DEL") 'undo-tree-undo)
     (define-key map (kbd "C-h") 'undo-tree-undo)
     map) nil))

(defun js2r--does-not-need-semi ()
  (save-excursion
    (back-to-indentation)
    (or (looking-at "if ")
        (looking-at "function ")
        (looking-at "for ")
        (looking-at "while ")
        (looking-at "try ")
        (looking-at "} catch ")
        (looking-at "} else "))))

(defun js2r--comma-unless (delimiter)
  (if (looking-at (concat "[\n\t\r ]*" (regexp-quote delimiter)))
      ""
    ","))

(define-key js2-mode-map (kbd "C-c RET jt") 'jump-to-test-file)
(define-key js2-mode-map (kbd "C-c RET ot") 'jump-to-test-file-other-window)
(define-key js2-mode-map (kbd "C-c RET js") 'jump-to-source-file)
(define-key js2-mode-map (kbd "C-c RET os") 'jump-to-source-file-other-window)
(define-key js2-mode-map (kbd "C-c RET jo") 'jump-between-source-and-test-files)
(define-key js2-mode-map (kbd "C-c RET oo") 'jump-between-source-and-test-files-other-window)

(define-key js2-mode-map (kbd "C-c RET dp") 'js2r-duplicate-object-property-node)

(define-key js2-mode-map (kbd "C-c RET ta") 'toggle-assert-refute)

(defadvice js2r-inline-var (after reindent-buffer activate)
  (cleanup-buffer))

(defun js2-hide-test-functions ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (ignore-errors
      (while (re-search-forward "\"[^\"]+\": function (")
        (js2-mode-hide-element)))))

(define-key js2-mode-map (kbd "C-c t") 'js2-hide-test-functions)

;; js2-mode steals TAB, let's steal it back for yasnippet
(defun js2-tab-properly ()
  (interactive)
  (let ((yas-fallback-behavior 'return-nil))
    (unless (yas-expand)
      (indent-for-tab-command)
      (if (looking-back "^\s*")
          (back-to-indentation)))))

(define-key js2-mode-map (kbd "TAB") 'js2-tab-properly)

;; When renaming/deleting js-files, check for corresponding testfile
(define-key js2-mode-map (kbd "C-x C-r") 'js2r-rename-current-buffer-file)
(define-key js2-mode-map (kbd "C-x C-k") 'js2r-delete-current-buffer-file)

(define-key js2-mode-map (kbd "C-k") #'js2r-kill)

(define-key js2-mode-map (kbd "M-j") (lambda (join-line -1)))

(comment ;; avoid confusing shorthands
 ;; Use lambda for anonymous functions
 (font-lock-add-keywords
  'js2-mode `(("\\(function\\) *("
               (0 (progn (compose-region (match-beginning 1)
                                         (match-end 1) "\u0192")
                         nil)))))

 ;; Use right arrow for return in one-line functions
 (font-lock-add-keywords
  'js2-mode `(("function *([^)]*) *{ *\\(return\\) "
               (0 (progn (compose-region (match-beginning 1)
                                         (match-end 1) "\u2190")
                         nil))))))

;; After js2 has parsed a js file, we look for jslint globals decl comment ("/* global Fred, _, Harry */") and
;; add any symbols to a buffer-local var of acceptable global vars
;; Note that we also support the "symbol: true" way of specifying names via a hack (remove any ":true"
;; to make it look like a plain decl, and any ':false' are left behind so they'll effectively be ignored as
;; you can't have a symbol called "someName:false"
(add-hook 'js2-post-parse-callbacks
          (lambda ()
            (when (> (buffer-size) 0)
              (let ((btext (replace-regexp-in-string
                            ": *true" " "
                            (replace-regexp-in-string "[\n\t ]+" " " (buffer-substring-no-properties 1 (buffer-size)) t t))))
                (mapc (apply-partially 'add-to-list 'js2-additional-externs)
                      (split-string
                       (if (string-match "/\\* *global *\\(.*?\\) *\\*/" btext) (match-string-no-properties 1 btext) "")
                       " *, *" t))
                ))))

(require 'json)

(defun my-aget (key map)
  (cdr (assoc key map)))

(defun js2-fetch-autolint-externs (file)
  (let* ((settings (with-temp-buffer
                     (insert-file-literally file)
                     (javascript-mode)
                     (let (kill-ring kill-ring-yank-pointer) (kill-comment 1000))
                     (->> (buffer-substring (point-min) (point-max))
                          (s-trim)
                          (s-chop-prefix "module.exports = ")
                          (s-chop-suffix ";")
                          (json-read-from-string))))
         (predef (->> settings
                      (my-aget 'linterOptions)
                      (my-aget 'predef))))
    (--each (append predef nil)
      (add-to-list 'js2-additional-externs it))))

(defun cjsp--eldoc-innards (beg)
  (save-excursion
    (goto-char beg)
    (search-forward "=")
    (let ((start (point)))
      (search-forward "*/")
      (forward-char -2)
      (buffer-substring-no-properties start (point)))))

(defun cjsp--indentation-of-html-line (html line-number)
  (with-temp-buffer
    (insert html)
    (html-mode)
    (indent-region (point-min) (point-max))
    (goto-line line-number)
    (back-to-indentation)
    (current-column)))

(defun cjsp--line-number-in-eldoc (p beg)
  (save-excursion
    (goto-char p)
    (let ((l (line-number-at-pos)))
      (goto-char beg)
      (- l (line-number-at-pos) -1))))

(defun js2-lineup-comment (parse-status)
  "Indent a multi-line block comment continuation line."
  (let* ((beg (nth 8 parse-status))
         (first-line (js2-same-line beg))
         (p (point))
         (offset (save-excursion
                   (goto-char beg)
                   (cond

                    ((looking-at "/\\*:DOC ")
                     (+ 2 (current-column)
                        (cjsp--indentation-of-html-line
                         (cjsp--eldoc-innards beg)
                         (cjsp--line-number-in-eldoc p beg))))

                    ((looking-at "/\\*")
                     (+ 1 (current-column)))

                    (:else 0)))))
    (unless first-line
      (indent-line-to offset))))
(setq js-indent-level 2)
;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so
;; unbind it.
(define-key js-mode-map (kbd "M-.") nil)

(provide 'setup-js2-mode)

;;; setup-js2-mode.el ends here
#+END_SRC
** setup-magit.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-magit.el
;;; setup-magit.el

;; move cursor into position when entering commit message
(use-package diff-hl :ensure)

(defun magit-status-fullscreen (prefix)
  (interactive "P")
  (magit-status)
  (unless prefix
    (delete-other-windows)))

(use-package magit-todos
  :ensure
  :after magit
  :after hl-todo)

(use-package hl-todo
  :ensure
  :config
  ;; Adding a new keyword: TEST.
  (add-to-list 'hl-todo-keyword-faces '("TEST" . "#dc8cc3"))
  :init
  (add-hook 'text-mode-hook (lambda () (hl-todo-mode t))))


;; full screen magit-status
;; Efficient version control.
(use-package magit
  :ensure
  :preface
  (defun bonz/magit-cursor-fix ()
    (beginning-of-buffer)
    (when (looking-at "#")
      (forward-line 2)))
  :config
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch)
  (add-hook 'git-commit-mode-hook 'bonz/magit-cursor-fix)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  ;; don't prompt me
  (set-default 'magit-pushq-always-verify nil)
  ;; (set-default 'magit-revert-buffers 'silent)
  (set-default 'magit-no-confirm '(stage-all-changes
                                   unstage-all-changes))
  (set-default 'magit-diff-refine-hunk t)
  ;; update diff-hl
  (global-diff-hl-mode)
   :bind-keymap
  ("C-c f" . magit-file-dispatch))


(require 'magit-git)
(defun my/magit-check-file-and-popup ()
  "If the file is version controlled with git
  and has uncommitted changes, open the magit status popup."
  (let ((file (buffer-file-name)))
    (when (and file (magit-anything-modified-p t file))
      (message "This file has uncommited changes!")
      (when nil ;; Became annoying after some time.
        (split-window-below)
        (other-window 1)
        (magit-status)))))

;; I usually have local variables, so I want the message to show
;; after the locals have been loaded.
(add-hook 'find-file-hook
          '(lambda ()
             (add-hook 'hack-local-variables-hook 'my/magit-check-file-and-popup)))

;; (use-package forge
;;   :after magit
;;   :config
;;   (setq forge-topic-list-columns
;;         '(("#" 4
;;            (lambda (a b)
;;              (> (car a) (car b)))
;;            (:right-align t) number nil)
;;           ("Title" 35 t nil title  nil)
;;           ("Milestone" 9 t nil milestone nil)
;;           ("State" 6 t nil state nil)
;;           ("Updated" 10 t nill updated nil))))

(add-hook 'server-switch-hook 'magit-commit-diff)
(provide 'setup-magit)
;;; setup-magit.el ends here
#+END_SRC
** setup-markdown.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-markdown.el
;;; setup-markdown.el
(use-package markdown-mode
  :mode (("\\.yml$" . yaml-mode)
         ("\\.yaml$" . yaml-mode))
  :config
  (setq markdown-command "/usr/local/bin/pandoc")
  ;; (setq markdown-command "pandoc --smart -f markdown -t html")
  (setq markdown-imenu-generic-expression
        '(("title"  "^\\(.*\\)[\n]=+$" 1)
          ("h2-"    "^\\(.*\\)[\n]-+$" 1)
          ("h1"   "^# \\(.*\\)$" 1)
          ("h2"   "^## \\(.*\\)$" 1)
          ("h3"   "^### \\(.*\\)$" 1)
          ("h4"   "^#### \\(.*\\)$" 1)
          ("h5"   "^##### \\(.*\\)$" 1)
          ("h6"   "^###### \\(.*\\)$" 1)
          ("fn"   "^\\[\\^\\(.*\\)\\]" 1)
          ))
  (add-hook 'markdown-mode-hook
            (lambda ()
              (setq imenu-generic-expression markdown-imenu-generic-expression)))

  (add-hook 'markdown-mode-hook
	    (lambda ()
	      (visual-line-mode t)
	      (writegood-mode t)
	      (flyspell-mode t))))

(provide 'setup-markdown)

;;; setup-markdown.el ends here
#+END_SRC
** setup-elfeed.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-elfeed.el
  ;;; setup-elfeed.el

(use-package elfeed
  :ensure
  :config
  (setq elfeed-feeds
        '(("https://lexi-lambda.github.io/feeds/all.rss.xml")
          ("https://cprss.s3.amazonaws.com/denoweekly.com.xml")
          ("https://cprss.s3.amazonaws.com/javascriptweekly.com.xml")
          ("https://eli.thegreenplace.net/feeds/python.atom.xml")
          ("http://www.aaronsw.com/2002/feeds/pgessays.rss")
          ("https://updates.orgmode.org/feed/updates")
          ("https://blog.aaronbieber.com/posts/index.xml")
          ("https://www.arp242.net/feed.xml")
          ("https://emacsredux.com/atom.xml" emacs)
          ("http://emacsrocks.com/atom.xml" emacs)
          ("https://cestlaz.github.io/rss.xml" emacs)
          ("http://blog.binchen.org/rss.xml" emacs)
          ("http://www.howardism.org/index.xml" emacs)
          ("http://irreal.org/blog/?feed=rss2" emacs)
          ("http://mbork.pl/?action=rss" emacs)
          ("https://www.masteringemacs.org/feed" emacs)
          ("https://fuco1.github.io/rss.xml" emacs)
          ("https://longreads.com/feed/")
          ("https://nullprogram.com/feed/" emacs)
          ("https://scripter.co/posts/index.xml" emacs)
          ("http://pragmaticemacs.com/feed/" emacs)
          ("http://www.lunaryorn.com/feed.atom" emacs)
          ("http://endlessparentheses.com/atom.xml" emacs)
          ("https://sachachua.com/blog/feed/" emacs)
          ("https://www.drugsandwires.fail/feed/" comic)
          ("http://feeds.feedburner.com/Explosm" comic)
          ("https://www.foxtrot.com/feed/" comic)
          ("http://feeds.feedburner.com/PoorlyDrawnLines" comic)
          ("https://www.youtube.com/feeds/videos.xml?channel_id=UC0uTPqBCFIpZxlz_Lv1tk_g" emacs)
          "http://feeds.feedburner.com/HighScalability"))
  (defun actuator-elfeed-show-all ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-all"))
  (defun actuator-elfeed-show-unread ()
    (interactive)
    (bookmark-maybe-load-default-file)
    (bookmark-jump "elfeed-unread"))
  (defun actuator-elfeed-load-db-and-open ()
    "Wrapper to load the elfeed database from disk before
        opening. Taken from Pragmatic Emacs."
    (interactive)
    (window-configuration-to-register :elfeed-fullscreen)
    (delete-other-windows)
    (elfeed)
    (elfeed-db-load)
    (elfeed-search-update 1)
    (elfeed-update))

  (defun actuator-elfeed-save-db-and-bury ()
    "Wrapper to save the Elfeed database to disk before burying
    buffer. Taken from Pragmatic Emacs."
    (interactive)
    (elfeed-db-save)
    (quit-window)
    (garbage-collect)
    (jump-to-register :elfeed-fullscreen))
  (defun actuator-elfeed-mark-all-as-read ()
    "Mark all feeds in search as read. Taken from Mike Zamansky"
    (interactive)
    (mark-whole-buffer)
    (elfeed-search-untag-all-unread))

  :bind
  (("C-x w" . actuator-elfeed-load-db-and-open)
   :map elfeed-search-mode-map
   ("A" . actuator-elfeed-show-all)
   ("U" . actuator-elfeed-show-unread)
   ("q" . actuator-elfeed-save-db-and-bury)
   ("R" . actuator-elfeed-mark-all-as-read))
  :custom
  (elfeed-search-filter "@1-week-ago +unread "))

(provide 'setup-elfeed)

  ;;; end setup-elfeed.el
#+END_SRC

** setup-eshell.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-eshell.el
;;; setup-eshell.el
(use-package f)

(setq eshell-visual-commands
      '("less" "tmux" "htop" "top" "bash" "zsh" "fish"))

(setq eshell-visual-subcommands
      '(("git" "log" "l" "diff" "show")))

;; Prompt with a bit of help from http://www.emacswiki.org/emacs/EshellPrompt
(defmacro with-face (str &rest properties)
  `(propertize ,str 'face (list ,@properties)))

(defun eshell/abbr-pwd ()
  (let ((home (getenv "HOME"))
	(path (eshell/pwd)))
    (cond
     ((string-equal home path) "~")
     ((f-ancestor-of? home path) (concat "~/" (f-relative path home)))
     (path))))

(defun eshell/my-prompt ()
  (let ((header-bg "#161616"))
    (concat
     (with-face (eshell/abbr-pwd) :foreground "#008700")
     (if (= (user-uid) 0)
	 (with-face "#" :foreground "red")
       (with-face "$" :foreground "#2345ba"))
     " ")))

(eval-after-load 'eshell
  '(require 'eshell-autojump nil t))

(setq eshell-prompt-function 'eshell/my-prompt)
(setq eshell-highlight-prompt nil)
(setq eshell-prompt-regexp "^[^#$\n]+[#$] ")

(setq eshell-cmpl-cycle-completions nil)

;; ref: http://pragmaticemacs.com/emacs/pop-up-a-quick-shell-with-shell-pop/
(use-package shell-pop
  :config
  (defun shell-pop-zsh ()
    (interactive)
    (setq shell-pop-shell-type (quote ("ansi-term" "*ansi-term*" (lambda nil (ansi-term shell-pop-term-shell)))))
    (setq shell-pop-term-shell "/bin/zsh")
    ;; need to do this manually or not picked up by `shell-pop'
    (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)
    (call-interactively 'shell-pop))
  (defun shell-pop-eshell ()
    (interactive)
    (let ((shell-pop-shell-type '("eshell" "*eshell*" (lambda () (eshell))))
          (shell-pop-term-shell "eshell"))
      (shell-pop--set-shell-type 'shell-pop-shell-type shell-pop-shell-type)
      (call-interactively 'shell-pop)))
  ;; :bind (("C-c z" . shell-pop-zsh)
  ;;        ("C-c t" . shell-pop-eshell))
  )

(provide 'setup-eshell)
;;; setup-eshell.el ends here
#+END_SRC
** setup-exwm.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-exwm.el
;;; setup-exwm.el
;; Load exwm
(use-package exwm
  :config
  (require 'exwm-randr)
  (setq exwm-randr-workspace-output-plist '(0 "eDP1"
                                              1 "eDP1"
                                              2 "HDMI1"
                                              3 "HDMI1"))
  (setq exwm-layout-show-all-buffers 't)
  (setq exwm-workspace-show-all-buffers 't)
  ;; Set the initial workspace number.
  (setq exwm-workspace-number 4)

  ;; Line-editing shortcuts
  (setq exwm-input-simulation-keys
        '(([?\C-b] . [left])
          ([?\C-f] . [right])
          ([?\C-p] . [up])
          ([?\C-n] . [down])
          ([?\C-a] . [home])
          ([?\C-e] . [end])
          ([?\M-v] . [prior])
          ([?\C-v] . [next])
          ([?\C-d] . [delete])
          ([?\C-k] . [S-end delete])))
  ;; Make class name the buffer name
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (exwm-workspace-rename-buffer exwm-class-name)))
  ;; Add these hooks in a suitable place (e.g., as done in exwm-config-default)
  (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)
  ;; Make gimp floating
  (add-hook 'exwm-update-class-hook
            (lambda ()
              (unless (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                          (string= "gimp" exwm-instance-name))
                (rename-buffer exwm-class-name t))))
  ;; ;; Add these hooks in a suitable place (e.g., as done in exwm-config-default)
  (add-hook 'exwm-update-class-hook 'exwm-rename-buffer)
  (add-hook 'exwm-update-title-hook 'exwm-rename-buffer)
  (exwm-input-set-key (kbd "s-r") #'exwm-reset)
  ;; 's-w': Switch workspace
  (exwm-input-set-key (kbd "s-w") #'exwm-workspace-switch)

  (dotimes (i 10)
    (exwm-input-set-key (kbd (format "s-%d" i))
                        `(lambda ()
                           (interactive)
                           (exwm-workspace-switch-create ,i))))
  ;; 's-&': Launch application
  (exwm-input-set-key (kbd "s-&")
                      (lambda (command)
                        (interactive (list (read-shell-command "$ ")))
                        (start-process-shell-command command nil command)))
  (exwm-input-set-key (kbd "s-s") 'exwm-workspace-next)
  (exwm-input-set-key (kbd "s-j") 'exwm-workspace-next)
  (push ?\s-j exwm-input-prefix-keys)

  (exwm-input-set-key (kbd "s-o") 'other-window)
  (exwm-input-set-key (kbd "s-k") 'other-window)

  (push ?\s-o exwm-input-prefix-keys)
  (push ?\s-k exwm-input-prefix-keys)

  (exwm-input-set-key (kbd "s-p")
                      #'background-shell-command)

  ;; Enable EXWM
  (exwm-enable)
  (exwm-randr-enable)

  (add-hook 'exwm-update-title-hook
            (lambda ()
              (when (or (string-prefix-p "sun-awt-X11-" exwm-instance-name)
                        (string= "gimp" exwm-instance-name))
                (rename-buffer exwm-title t))))
  :bind (("C-x C-c" . exwm-logout)))

(defun exwm-workspace-next ()
  (interactive)
  (let ((next-numb (mod (+ 1 exwm-workspace-current-index) exwm-workspace-number)))
    (exwm-workspace-switch next-numb)))

(defmacro exwm-switch-to-workspace-key (ws-num)
  `(progn (exwm-input-set-key (kbd (concat "s-" ,(number-to-string ws-num)))
                              (lambda ()
                                (interactive)
                                (exwm-workspace-switch ,ws-num)))
          (let ((key-num (if (eq 0 ,ws-num)
                             10
                           ,ws-num)))
            (exwm-input-set-key (kbd (concat "s-<f" (number-to-string key-num) ">"))
                                (lambda ()
                                  (interactive)
                                  (exwm-workspace-switch ,ws-num))))))


(add-to-list 'display-buffer-alist
             `(,(rx bos " *async command*")
               (display-buffer-no-window)))

(defun background-shell-command (command)
  (interactive (list (read-shell-command "$ ")))
  (async-shell-command command (generate-new-buffer " *async command*")))

(defun exwm-rename-buffer ()
  (interactive)
  (exwm-workspace-rename-buffer
   (concat exwm-class-name ":"
           (if (<= (length exwm-title) 7) exwm-title
             (concat (substring exwm-title 0 6) "...")))))

(provide 'setup-exwm)

;;; setup-exwm.el ends here
#+END_SRC

** setup-helm.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-helm.el
;;; setup-helm.el
(use-package helm-ag :ensure)
(use-package helm
  :ensure
  :config
  (setq helm-split-window-in-side-P           t ; open helm buffer inside current window, not occupy whole other window
	helm-move-to-line-cycle-in-source     t ; move to end or beginning of source when reaching top or bottom of source.
	helm-ff-search-library-in-sexp        t ; search for library in `require' and `declare-function' sexp.
	helm-scroll-amount                    8 ; scroll 8 lines other window using M-<next>/M-<prior>
	helm-ff-file-name-history-use-recentf t
	helm-echo-input-in-header-line t)

  (setq helm-autoresize-max-height 0)
  (setq helm-autoresize-min-height 20)
  (setq helm-buffers-fuzzy-matching t
	helm-recentf-fuzzy-match    t)
  (helm-autoresize-mode 1)
  (helm-mode 1)
  :bind (("C-x b" . helm-mini)
	 ("C-c h" . helm-command-prefix)
	 ("C-c M-x" . helm-M-x)
	 ("C-x r b" . helm-filtered-bookmarks)
	 ("C-x C-f" . helm-find-files)
	 ("M-y" . helm-show-kill-ring)
	 ("M-s o" . occur)
	 :map helm-map
	 ("<tab>" . helm-execute-persistent-action)
	 ("C-i" . helm-execute-persistent-action)
	 ("C-z" . helm-select-action)))

(use-package ivy
  :ensure swiper
  :ensure counsel
  :config
  (ivy-mode 1)
  (setq ivy-use-virtual-buffers t)
  ;; enable this if you want `swiper' to use it
  (setq search-default-mode #'char-fold-to-regexp))

(setq ivy-display-style 'fancy)
;;advise swiper to recenter on exit
(defun bjm-swiper-recenter (&rest args)
  "recenter display after swiper"
  (recenter))
(advice-add 'swiper :after #'bjm-swiper-recenter)

(when (executable-find "curl")
  (setq helm-google-suggest-use-curl-p t))

;; set up helm projectile
(use-package helm-projectile :ensure
 :config
 (projectile-global-mode)
 (helm-projectile-on)
 (setq projectile-switch-project-action 'helm-projectile)
 (setq projectile-completion-system 'helm)
 :bind-keymap
 ("C-c p" . projectile-command-map))

(use-package helm-exwm :ensure)
(provide 'setup-helm)

;;; setup-helm.el ends here
#+END_SRC
** setup-hledger.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-hledger.el
;;; setup-hledger.el

(use-package hledger-mode
 :ensure
  :mode ("\\.journal\\'" "\\.hledger\\'")
  :preface
  (defun hledger/next-entry ()
    "Move to next entry and pulse."
    (interactive)
    (hledger-next-or-new-entry)
    (hledger-pulse-momentary-current-entry))

  (defface hledger-warning-face
    '((((background dark))
       :background "Red" :foreground "White")
      (((background light))
       :background "Red" :foreground "White")
      (t :inverse-video t))
    "Face for warning"
    :group 'hledger)

  (defun hledger/prev-entry ()
    "Move to last entry and pulse."
    (interactive)
    (hledger-backward-entry)
    (hledger-pulse-momentary-current-entry))

  (defun bonz/ledger-with-timer ()
    (run-with-timer 1
		    nil
		    (lambda ()
		      (when (equal hledger-last-run-command
				   "balancesheet")
			;; highlight frequently changing accounts
			(highlight-regexp "^.*\\(Ksh\\|Expense\\).*$")
			(highlight-regexp "^.*Liability*$"
					  'hledger-warning-face)))))
  :bind (("C-c j" . hledger-run-command)
	 :map hledger-mode-map
	 ("C-c e" . hledger-jentry)
	 ("M-p" . hledger/prev-entry)
	 ("M-n" . hledger/next-entry))
  :init
  ;; Expanded account balances in the overall monthly report are
  ;; mostly noise for me and do not convey any meaningful information.
  (setq hledger-show-expanded-report nil)
  (when (boundp 'my-hledger-service-fetch-url)
    (setq hledger-service-fetch-url
	  my-hledger-service-fetch-url))

  :config
  (setq company-mode t)
  (setq hledger-file "/home/bonface/Self/finances/hledger.journal")
  :hook ((hl-line-mode . hledger-view-mode-hook)
         (center-text-for-reading . hledger-view-mode-hook)
         (bonz/ledger-with-timer . hledger-view-mode-hook)))

(use-package hledger-input
  :pin manual
  :load-path "packages/rest/hledger-mode/"
  :bind (("C-c e" . hledger-capture)
	 :map hledger-input-mode-map
	 ("C-c C-b" . popup-balance-at-point))
  :preface
  (defun popup-balance-at-point ()
    "Show balance for account at point in a popup."
    (interactive)
    (if-let ((account (thing-at-point 'hledger-account)))
	(message (hledger-shell-command-to-string (format " balance -N %s "
							  account)))
      (message "No account at point")))
  (defun bonz/make-company-delay ()
	      (make-local-variable 'company-idle-delay)
	      (setq-local company-idle-delay 0.1))
  :config
  (setq hledger-input-buffer-height 20)
  :hook ((hledger-show-new-balances . hledger-input-post-commit-hook)
        (auto-fill-mode . hledger-input-mode-hook)
        (bonz/make-company-delay . hledger-input-mode-hook)))

(provide 'setup-hledger)

;;; setup-hledger.el ends here
#+END_SRC
** setup-hugo.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-hugo.el
;;; setup-hugo.el
(use-package ox-hugo
  :after ox)
(use-package easy-hugo
  :init
  (setq easy-hugo-basedir "~/Public/BonfaceKilz/")
  (setq easy-hugo-url "https://bonfacemunyoki.com")
  (setq easy-hugo-sshdomain "myserver")
  (setq easy-hugo-root "/home/bonface/bonfacemunyoki.com/")
  (setq easy-hugo-previewtime "300"))

(provide 'setup-hugo)
;;; setup-hugo.el ends here
#+END_SRC

** setup-hydra.el
#+begin_src emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-hydra.el
(use-package hydra)

(defhydra hydra-org-template (:color blue :hint nil)
  "
 _c_enter    _q_uote     _e_macs-lisp    _L_aTeX:
 _l_atex     _E_xample   _p_ython        _i_ndex:
 _a_scii     _v_erse     _I_NCLUDE:      _H_TML:
 _s_rc       _n_ote      plant_u_ml      _A_SCII:
 _H_askell   ^ ^         ^ ^             _S_cheme:
"
  ("s" (hot-expand "<s"))
  ("S" (hot-expand "<s" "scheme"))
  ("E" (hot-expand "<e"))
  ("q" (hot-expand "<q"))
  ("v" (hot-expand "<v"))
  ("n" (hot-expand "<not"))
  ("c" (hot-expand "<c"))
  ("l" (hot-expand "<l"))
  ("H" (hot-expand "<s" "haskell"))
  ("a" (hot-expand "<a"))
  ("L" (hot-expand "<L"))
  ("i" (hot-expand "<i"))
  ("e" (hot-expand "<s" "emacs-lisp"))
  ("p" (hot-expand "<s" "python"))
  ("u" (hot-expand "<s" "plantuml :file CHANGE.png"))
  ("I" (hot-expand "<I"))
  ("A" (hot-expand "<A"))
  ("<" self-insert-command "ins")
  ("o" nil "quit"))

(defun hot-expand (str &optional mod header)
  "Expand org template.

STR is a structure template string recognised by org like <s. MOD is a
string with additional parameters to add the begin line of the
structure element. HEADER string includes more parameters that are
prepended to the element after the #+HEADER: tag."
  (let (text)
    (when (region-active-p)
      (setq text (buffer-substring (region-beginning) (region-end)))
      (delete-region (region-beginning) (region-end))
      (deactivate-mark))
    (when header (insert "#+HEADER: " header) (forward-line))
    (insert str)
    (org-tempo-complete-tag)
    (when mod (insert mod) (forward-line))
    (when text (insert text))))

(define-key org-mode-map "<"
  (lambda () (interactive)
    (if (or (region-active-p) (looking-back "^"))
        (hydra-org-template/body)
      (self-insert-command 1))))

(eval-after-load "org"
  '(cl-pushnew
    '("not" . "note")
    org-structure-template-alist))

(defhydra hydra-dired (:hint nil :color pink)
  "
_+_ mkdir          _v_iew           _m_ark             _(_ details        _i_nsert-subdir    wdired
_C_opy             _O_ view other   _U_nmark all       _)_ omit-mode      _$_ hide-subdir    C-x C-q : edit
_D_elete           _o_pen other     _u_nmark           _l_ redisplay      _w_ kill-subdir    C-c C-c : commit
_R_ename           _M_ chmod        _t_oggle           _g_ revert buf     _e_ ediff          C-c ESC : abort
_Y_ rel symlink    _G_ chgrp        _E_xtension mark   _s_ort             _=_ pdiff
_S_ymlink          ^ ^              _F_ind marked      _._ toggle hydra   \\ flyspell
_r_sync            ^ ^              ^ ^                ^ ^                _?_ summary
_z_ compress-file  _A_ find regexp
_Z_ compress       _Q_ repl regexp

T - tag prefix
"
  ("\\" dired-do-ispell)
  ("(" dired-hide-details-mode)
  (")" dired-omit-mode)
  ("+" dired-create-directory)
  ("=" diredp-ediff)         ;; smart diff
  ("?" dired-summary)
  ("$" diredp-hide-subdir-nomove)
  ("A" dired-do-find-regexp)
  ("C" dired-do-copy)        ;; Copy all marked files
  ("D" dired-do-delete)
  ("E" dired-mark-extension)
  ("e" dired-ediff-files)
  ("F" dired-do-find-marked-files)
  ("G" dired-do-chgrp)
  ("g" revert-buffer)        ;; read all directories again (refresh)
  ("i" dired-maybe-insert-subdir)
  ("l" dired-do-redisplay)   ;; relist the marked or singel directory
  ("M" dired-do-chmod)
  ("m" dired-mark)
  ("O" dired-display-file)
  ("o" dired-find-file-other-window)
  ("Q" dired-do-find-regexp-and-replace)
  ("R" dired-do-rename)
  ("r" dired-do-rsynch)
  ("S" dired-do-symlink)
  ("s" dired-sort-toggle-or-edit)
  ("t" dired-toggle-marks)
  ("U" dired-unmark-all-marks)
  ("u" dired-unmark)
  ("v" dired-view-file)      ;; q to exit, s to search, = gets line #
  ("w" dired-kill-subdir)
  ("Y" dired-do-relsymlink)
  ("z" diredp-compress-this-file)
  ("Z" dired-do-compress)
  ("q" nil)
  ("." nil :color blue))

(define-key dired-mode-map "." 'hydra-dired/body)


(defhydra hydra-ibuffer-main (:color pink :hint nil)
  "
 ^Navigation^ | ^Mark^        | ^Actions^        | ^View^
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
  _k_:    ʌ   | _m_: mark     | _D_: delete      | _g_: refresh
 _RET_: visit | _u_: unmark   | _S_: save        | _s_: sort
  _j_:    v   | _*_: specific | _a_: all actions | _/_: filter
-^----------^-+-^----^--------+-^-------^--------+-^----^-------
"
  ("j" ibuffer-forward-line)
  ("RET" ibuffer-visit-buffer :color blue)
  ("k" ibuffer-backward-line)

  ("m" ibuffer-mark-forward)
  ("u" ibuffer-unmark-forward)
  ("*" hydra-ibuffer-mark/body :color blue)

  ("D" ibuffer-do-delete)
  ("S" ibuffer-do-save)
  ("a" hydra-ibuffer-action/body :color blue)

  ("g" ibuffer-update)
  ("s" hydra-ibuffer-sort/body :color blue)
  ("/" hydra-ibuffer-filter/body :color blue)

  ("o" ibuffer-visit-buffer-other-window "other window" :color blue)
  ("q" quit-window "quit ibuffer" :color blue)
  ("." nil "toggle hydra" :color blue))

(defhydra hydra-ibuffer-mark (:color teal :columns 5
                                     :after-exit (hydra-ibuffer-main/body))
  "Mark"
  ("*" ibuffer-unmark-all "unmark all")
  ("M" ibuffer-mark-by-mode "mode")
  ("m" ibuffer-mark-modified-buffers "modified")
  ("u" ibuffer-mark-unsaved-buffers "unsaved")
  ("s" ibuffer-mark-special-buffers "special")
  ("r" ibuffer-mark-read-only-buffers "read-only")
  ("/" ibuffer-mark-dired-buffers "dired")
  ("e" ibuffer-mark-dissociated-buffers "dissociated")
  ("h" ibuffer-mark-help-buffers "help")
  ("z" ibuffer-mark-compressed-file-buffers "compressed")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-action (:color teal :columns 4
                                       :after-exit
                                       (if (eq major-mode 'ibuffer-mode)
                                           (hydra-ibuffer-main/body)))
  "Action"
  ("A" ibuffer-do-view "view")
  ("E" ibuffer-do-eval "eval")
  ("F" ibuffer-do-shell-command-file "shell-command-file")
  ("I" ibuffer-do-query-replace-regexp "query-replace-regexp")
  ("H" ibuffer-do-view-other-frame "view-other-frame")
  ("N" ibuffer-do-shell-command-pipe-replace "shell-cmd-pipe-replace")
  ("M" ibuffer-do-toggle-modified "toggle-modified")
  ("O" ibuffer-do-occur "occur")
  ("P" ibuffer-do-print "print")
  ("Q" ibuffer-do-query-replace "query-replace")
  ("R" ibuffer-do-rename-uniquely "rename-uniquely")
  ("T" ibuffer-do-toggle-read-only "toggle-read-only")
  ("U" ibuffer-do-replace-regexp "replace-regexp")
  ("V" ibuffer-do-revert "revert")
  ("W" ibuffer-do-view-and-eval "view-and-eval")
  ("X" ibuffer-do-shell-command-pipe "shell-command-pipe")
  ("b" nil "back"))

(defhydra hydra-ibuffer-sort (:color amaranth :columns 3)
  "Sort"
  ("i" ibuffer-invert-sorting "invert")
  ("a" ibuffer-do-sort-by-alphabetic "alphabetic")
  ("v" ibuffer-do-sort-by-recency "recently used")
  ("s" ibuffer-do-sort-by-size "size")
  ("f" ibuffer-do-sort-by-filename/process "filename")
  ("m" ibuffer-do-sort-by-major-mode "mode")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(defhydra hydra-ibuffer-filter (:color amaranth :columns 4)
  "Filter"
  ("m" ibuffer-filter-by-used-mode "mode")
  ("M" ibuffer-filter-by-derived-mode "derived mode")
  ("n" ibuffer-filter-by-name "name")
  ("c" ibuffer-filter-by-content "content")
  ("e" ibuffer-filter-by-predicate "predicate")
  ("f" ibuffer-filter-by-filename "filename")
  (">" ibuffer-filter-by-size-gt "size")
  ("<" ibuffer-filter-by-size-lt "size")
  ("/" ibuffer-filter-disable "disable")
  ("b" hydra-ibuffer-main/body "back" :color blue))

(define-key ibuffer-mode-map "." 'hydra-ibuffer-main/body)


(define-key Info-mode-map (kbd "?") #'hydra-info/body)
(defhydra hydra-info (:color blue
                             :hint nil)
  "
Info-mode:

  ^^_]_ forward  (next logical node)       ^^_l_ast (←)        _u_p (↑)                             _f_ollow reference       _T_OC
  ^^_[_ backward (prev logical node)       ^^_r_eturn (→)      _m_enu (↓) (C-u for new window)      _i_ndex                  _d_irectory
  ^^_n_ext (same level only)               ^^_H_istory         _g_oto (C-u for new window)          _,_ next index item      _c_opy node name
  ^^_p_rev (same level only)               _<_/_t_op           _b_eginning of buffer                virtual _I_ndex          _C_lone buffer
  regex _s_earch (_S_ case sensitive)      ^^_>_ final         _e_nd of buffer                      ^^                       _a_propos

  _1_ .. _9_ Pick first .. ninth item in the node's menu.

"
  ("]"   Info-forward-node)
  ("["   Info-backward-node)
  ("n"   Info-next)
  ("p"   Info-prev)
  ("s"   Info-search)
  ("S"   Info-search-case-sensitively)

  ("l"   Info-history-back)
  ("r"   Info-history-forward)
  ("H"   Info-history)
  ("t"   Info-top-node)
  ("<"   Info-top-node)
  (">"   Info-final-node)

  ("u"   Info-up)
  ("^"   Info-up)
  ("m"   Info-menu)
  ("g"   Info-goto-node)
  ("b"   beginning-of-buffer)
  ("e"   end-of-buffer)

  ("f"   Info-follow-reference)
  ("i"   Info-index)
  (","   Info-index-next)
  ("I"   Info-virtual-index)

  ("T"   Info-toc)
  ("d"   Info-directory)
  ("c"   Info-copy-current-node-name)
  ("C"   clone-buffer)
  ("a"   info-apropos)

  ("1"   Info-nth-menu-item)
  ("2"   Info-nth-menu-item)
  ("3"   Info-nth-menu-item)
  ("4"   Info-nth-menu-item)
  ("5"   Info-nth-menu-item)
  ("6"   Info-nth-menu-item)
  ("7"   Info-nth-menu-item)
  ("8"   Info-nth-menu-item)
  ("9"   Info-nth-menu-item)

  ("?"   Info-summary "Info summary")
  ("h"   Info-help "Info help")
  ("q"   Info-exit "Info exit")
  ("C-g" nil "cancel" :color blue))

(define-key org-agenda-mode-map
  "v" 'hydra-org-agenda-view/body)

(defun org-agenda-cts ()
  (let ((args (get-text-property
               (min (1- (point-max)) (point))
               'org-last-args)))
    (nth 2 args)))

(defhydra hydra-org-agenda-view (:hint none)
  "
_d_: ?d? day        _g_: time grid=?g? _a_: arch-trees
_w_: ?w? week       _[_: inactive      _A_: arch-files
_t_: ?t? fortnight  _f_: follow=?f?    _r_: report=?r?
_m_: ?m? month      _e_: entry =?e?    _D_: diary=?D?
_y_: ?y? year       _q_: quit          _L__l__c_: ?l?"
  ("SPC" org-agenda-reset-view)
  ("d" org-agenda-day-view
   (if (eq 'day (org-agenda-cts))
       "[x]" "[ ]"))
  ("w" org-agenda-week-view
   (if (eq 'week (org-agenda-cts))
       "[x]" "[ ]"))
  ("t" org-agenda-fortnight-view
   (if (eq 'fortnight (org-agenda-cts))
       "[x]" "[ ]"))
  ("m" org-agenda-month-view
   (if (eq 'month (org-agenda-cts)) "[x]" "[ ]"))
  ("y" org-agenda-year-view
   (if (eq 'year (org-agenda-cts)) "[x]" "[ ]"))
  ("l" org-agenda-log-mode
   (format "% -3S" org-agenda-show-log))
  ("L" (org-agenda-log-mode '(4)))
  ("c" (org-agenda-log-mode 'clockcheck))
  ("f" org-agenda-follow-mode
   (format "% -3S" org-agenda-follow-mode))
  ("a" org-agenda-archives-mode)
  ("A" (org-agenda-archives-mode 'files))
  ("r" org-agenda-clockreport-mode
   (format "% -3S" org-agenda-clockreport-mode))
  ("e" org-agenda-entry-text-mode
   (format "% -3S" org-agenda-entry-text-mode))
  ("g" org-agenda-toggle-time-grid
   (format "% -3S" org-agenda-use-time-grid))
  ("D" org-agenda-toggle-diary
   (format "% -3S" org-agenda-include-diary))
  ("!" org-agenda-toggle-deadlines)
  ("["
   (let ((org-agenda-include-inactive-timestamps t))
     (org-agenda-check-type t 'timeline 'agenda)
     (org-agenda-redo)))
  ("q" (message "Abort") :exit t))

(defhydra hydra-org-agenda (:pre (setq which-key-inhibit t)
                                 :post (setq which-key-inhibit nil)
                                 :hint none)
  "
Org agenda (_q_uit)

^Clock^      ^Visit entry^              ^Date^             ^Other^
^-----^----  ^-----------^------------  ^----^-----------  ^-----^---------
_ci_ in      _SPC_ in other window      _ds_ schedule      _gr_ reload
_co_ out     _TAB_ & go to location     _dd_ set deadline  _._  go to today
_cq_ cancel  _RET_ & del other windows  _dt_ timestamp     _gd_ go to date
_cj_ jump    _o_   link                 _+_  do later      ^^
^^           ^^                         _-_  do earlier    ^^
^^           ^^                         ^^                 ^^
^View^          ^Filter^                 ^Headline^         ^Toggle mode^
^----^--------  ^------^---------------  ^--------^-------  ^-----------^----
_vd_ day        _ft_ by tag              _ht_ set status    _tf_ follow
_vw_ week       _fr_ refine by tag       _hk_ kill          _tl_ log
_vt_ fortnight  _fc_ by category         _hr_ refile        _ta_ archive trees
_vm_ month      _fh_ by top headline     _hA_ archive       _tA_ archive files
_vy_ year       _fx_ by regexp           _h:_ set tags      _tr_ clock report
_vn_ next span  _fd_ delete all filters  _hp_ set priority  _td_ diaries
_vp_ prev span  ^^                       ^^                 ^^
_vr_ reset      ^^                       ^^                 ^^
^^              ^^                       ^^                 ^^
"
  ;; Entry
  ("hA" org-agenda-archive-default)
  ("hk" org-agenda-kill)
  ("hp" org-agenda-priority)
  ("hr" org-agenda-refile)
  ("h:" org-agenda-set-tags)
  ("ht" org-agenda-todo)
  ;; Visit entry
  ("o"   link-hint-open-link :exit t)
  ("<tab>" org-agenda-goto :exit t)
  ("TAB" org-agenda-goto :exit t)
  ("SPC" org-agenda-show-and-scroll-up)
  ("RET" org-agenda-switch-to :exit t)
  ;; Date
  ("dt" org-agenda-date-prompt)
  ("dd" org-agenda-deadline)
  ("+" org-agenda-do-date-later)
  ("-" org-agenda-do-date-earlier)
  ("ds" org-agenda-schedule)
  ;; View
  ("vd" org-agenda-day-view)
  ("vw" org-agenda-week-view)
  ("vt" org-agenda-fortnight-view)
  ("vm" org-agenda-month-view)
  ("vy" org-agenda-year-view)
  ("vn" org-agenda-later)
  ("vp" org-agenda-earlier)
  ("vr" org-agenda-reset-view)
  ;; Toggle mode
  ("ta" org-agenda-archives-mode)
  ("tA" (org-agenda-archives-mode 'files))
  ("tr" org-agenda-clockreport-mode)
  ("tf" org-agenda-follow-mode)
  ("tl" org-agenda-log-mode)
  ("td" org-agenda-toggle-diary)
  ;; Filter
  ("fc" org-agenda-filter-by-category)
  ("fx" org-agenda-filter-by-regexp)
  ("ft" org-agenda-filter-by-tag)
  ("fr" org-agenda-filter-by-tag-refine)
  ("fh" org-agenda-filter-by-top-headline)
  ("fd" org-agenda-filter-remove-all)
  ;; Clock
  ("cq" org-agenda-clock-cancel)
  ("cj" org-agenda-clock-goto :exit t)
  ("ci" org-agenda-clock-in :exit t)
  ("co" org-agenda-clock-out)
  ;; Other
  ("q" nil :exit t)
  ("gd" org-agenda-goto-date)
  ("." org-agenda-goto-today)
  ("gr" org-agenda-redo))

(define-key org-agenda-mode-map
  "e" 'hydra-org-agenda/body)


(defhydra hydra-global-org (:color blue
                                   :hint nil
                                   :body-pre (setq exwm-input-line-mode-passthrough ''t)
                                   :post (setq exwm-input-line-mode-passthrough nil))
  "
Timer^^           ^Clock^         ^Capture^         ^Other^            ^Hugo^
--------------------------------------------------------------------------------
[_C-t_]tart        _w_ clock in    _c_apture         _,_ Priority
[_C-s_]top         _o_ clock out   _l_ast capture    _s_ rifle-current
_r_eset            _j_ clock goto                  _\\_ pretty-entes
_p_rint                                         _g_ view-markdown       _e_xport-dispatch
                                              _G_ convert-markdown
"
                                        ;("t" org-timer-start)
  ("C-t"  org-timer-start)
  ("s" helm-org-rifle-current-buffer)
  ("S" helm-org-rifle)
  ("C-s"  org-timer-stop)
  ("C-S"  org-timer-stop)
  ;; Need to be at timer
  ("r" org-timer-set-timer)
  ("C-r"  org-timer-set-timer)
  ;; Print timer value to buffer
  ("p" org-timer)
  ("C-p"  org-timer)
  ("w" (org-clock-in '(4)))
  ("C-w"  (org-clock-in '(4)))
  ("o" org-clock-out)
  ("C-o"  org-clock-out)
  ;; Visit the clocked task from any buffer
  ("j" org-clock-goto)
  ("C-j"  org-clock-goto)
  ("c" helm-org-capture-templates) ;org-capture
  ("C-c"  helm-org-capture-templates) ;org-capture
  ("l" org-capture-goto-last-stored)
  ("C-l"  org-capture-goto-last-stored)
  ("," org-priority)
  ("C-,"  org-priority)
  ("e" org-export-dispatch)
  ("g" org-gfm-export-as-markdown)
  ("G" org-gfm-convert-region-to-md)
  ("\\" org-toggle-pretty-entities))

(use-package avy)

(defhydra hydra-avy-move-actions (:exit t
                                        :columns 2
                                        :after-exit (setq ot/avy-selected-pt nil)
                                        :idle 1.0)
  "Avy actions"
  ("f" (ot/avy-action-move-sexp-forward-here ot/avy-selected-pt) "Forward until end of expression")
  ("b" (ot/avy-action-move-sexp-backward-here ot/avy-selected-pt) "Backward until begin of expression")
  ("e" (ot/avy-action-move-sexp-here ot/avy-selected-pt) "Sexp")
  ("RET" (ot/avy-action-move-sexp-here ot/avy-selected-pt) "Sexp")
  ("s" (ot/avy-action-move-symbol-here ot/avy-selected-pt) "Symbol")
  ("(" (ot/avy-action-move-surrounding-sexp-here ot/avy-selected-pt) "Surrounding sexp"))

(defhydra hydra-avy-copy-actions (:exit t
                                        :columns 2
                                        :after-exit (setq ot/avy-selected-pt nil)
                                        :idle 1.0)
  "Avy actions"
  ("f" (ot/avy-action-copy-sexp-forward-here ot/avy-selected-pt) "Forward until end of expression")
  ("b" (ot/avy-action-copy-sexp-backward-here ot/avy-selected-pt) "Backward until begin of expression")
  ("e" (ot/avy-action-copy-sexp-here ot/avy-selected-pt) "Sexp")
  ("RET" (ot/avy-action-copy-sexp-here ot/avy-selected-pt) "Sexp")
  ("s" (ot/avy-action-copy-symbol-here ot/avy-selected-pt) "Symbol")
  ("(" (ot/avy-action-copy-surrounding-sexp-here ot/avy-selected-pt) "Surrounding sexp"))

(defhydra hydra-avy (:exit t :hint nil)
  "
 Line^^       Region^^        Goto                                 ^Actions^
--------------------------------------------------------------------------------
 [_y_] yank   [_Y_] yank      [_c_] timed char  [_C_] char         co_p_y-actions
 [_m_] move   [_M_] move      [_w_] word        [_W_] any word     mo_v_e-actions
 [_k_] kill   [_K_] kill      [_l_] line        [_L_] end of line"
  ("c" avy-goto-char-timer)
  ("C" avy-goto-char)
  ("w" avy-goto-word-1)
  ("W" avy-goto-word-0)
  ("l" avy-goto-line)
  ("L" avy-goto-end-of-line)
  ("m" avy-move-line)
  ("M" avy-move-region)
  ("k" avy-kill-whole-line)
  ("K" avy-kill-region)
  ("y" avy-copy-line)
  ("p" hydra-avy-copy-actions/body)
  ("v" hydra-avy-move-actions/body)
  ("Y" avy-copy-region))

(use-package ace-jump-mode)
(defhydra hydra-ace (:exit t :hint nil)
  "
 Move across windows^^
-----------------------
 [_m_] head character
 [_c_] character
 [_w_] word
 [_l_] line"
  ("m" ace-jump-mode)
  ("c" ace-jump-char-mode)
  ("w" ace-jump-word-mode)
  ("l" ace-jump-line-mode))

(require 'rect)
(defhydra hydra-rectangle (:body-pre (rectangle-mark-mode 1)
                                     :color pink
                                     :post (deactivate-mark))
  "
  ^_k_^     _d_elete    _s_tring
_h_   _l_   _o_k        _y_ank
  ^_j_^     _n_ew-copy  _r_eset
^^^^        _e_xchange  _u_ndo
^^^^        ^ ^         _x_kill
"
  ("h" rectangle-backward-char nil)
  ("l" rectangle-forward-char nil)
  ("k" rectangle-previous-line nil)
  ("j" rectangle-next-line nil)
  ("e" hydra-ex-point-mark nil)
  ("n" copy-rectangle-as-kill nil)
  ("d" delete-rectangle nil)
  ("r" (if (region-active-p)
           (deactivate-mark)
         (rectangle-mark-mode 1)) nil)
  ("y" yank-rectangle nil)
  ("u" undo nil)
  ("s" string-rectangle nil)
  ("x" kill-rectangle nil)
  ("o" nil nil))


;; Hydra - Marking
(defhydra hydra-mark (:exit t
                            :columns 3
                            :idle 1.0)
  "Mark"
  ("d" er/mark-defun "Defun / Function")
  ("f" er/mark-defun "Defun / Function")
  ("F" er/mark-clj-function-literal "Clj anonymous fn")
  ("w" er/mark-word "Word")
  ("W" er/mark-clj-word "CLJ word")
  ("u" er/mark-url "Url")
  ("e" mark-sexp "S-Expression")
  ("E" er/mark-email "Email")
  ("b" hydra-mark-buffer/body "Buffer")
  ("l" mark-line "Line")
  ("p" er/mark-text-paragraph "Paragraph")
  ("r" er/mark-clj-regexp-literal "Clj regexp")
  ("s" er/mark-symbol "Symbol")
  ("S" er/mark-symbol-with-prefix "Prefixed symbol")
  ("q" er/mark-inside-quotes "Inside quotes")
  ("Q" er/mark-outside-quotes "Outside quotes")
  ("(" er/mark-inside-pairs "Inside pairs")
  ("[" er/mark-inside-pairs "Inside pairs")
  ("{" er/mark-inside-pairs "Inside pairs")
  (")" er/mark-outside-pairs "Outside pairs")
  ("]" er/mark-outside-pairs "Outside pairs")
  ("}" er/mark-outside-pairs "Outside pairs")
  ("t" er/mark-inner-tag "Inner tag")
  ("T" er/mark-outer-tag "Outer tag")
  ("c" er/mark-comment "Comment")
  ("a" er/mark-html-attribute "HTML attribute")
  ("." er/expand-region "Expand region" :exit nil)
  ("," er/contract-region "Contract region" :exit nil)
  ("#" er/mark-clj-set-literal "Clj set")
  )

(defhydra hydra-mark-buffer (:exit t
                                   :idle 1.0)
  "Mark buffer"
  ("w" mark-whole-buffer "Whole buffer")
  ("a" mark-buffer-after-point "Buffer after point")
  ("b" mark-buffer-before-point "Buffer before point"))

;; Hydra - Yank
(defhydra hydra-yank-pop ()
  "yank"
  ("C-y" yank nil)
  ("M-y" yank-pop nil)
  ("y" (yank-pop 1) "next")
  ("Y" (yank-pop -1) "prev")
  ("l" helm-show-kill-ring "list" :exit t))   ; or browse-kill-ring

(defhydra hydra-copy (:exit t
                            :idle 1.0)
  "Copy"
  ("r" avy-copy-region "Region to point")
  ("l" avy-copy-line "Line to point")
  ("i" copy-inner "Inner")
  ("o" copy-outer "Outer"))

;; Hydra - Goto line
(defhydra hydra-goto-line (goto-map ""
                                    :pre (linum-mode 1)
                                    :post (linum-mode -1))
  "goto-line"
  ("g" goto-line "go")
  ("m" set-mark-command "mark" :bind nil)
  ("q" nil "quit"))

;; Hydra - Multiple cursors
(defhydra multiple-cursors-hydra (:columns 3
                                           :idle 1.0)
  "Multiple cursors"
  ("l" mc/edit-lines "Edit lines in region" :exit t)
  ("b" mc/edit-beginnings-of-lines "Edit beginnings of lines in region" :exit t)
  ("e" mc/edit-ends-of-lines "Edit ends of lines in region" :exit t)
  ("a" mc/mark-all-dwim "Mark all dwim" :exit t)
  ("S" mc/mark-all-symbols-like-this "Mark all symbols likes this" :exit t)
  ("w" mc/mark-all-words-like-this "Mark all words like this" :exit t)
  ("r" mc/mark-all-in-region "Mark all in region" :exit t)
  ("R" mc/mark-all-in-region-regexp "Mark all in region (regexp)" :exit t)
  ("d" mc/mark-all-like-this-in-defun "Mark all like this in defun" :exit t)
  ("s" mc/mark-all-symbols-like-this-in-defun "Mark all symbols like this in defun" :exit t)
  ("W" mc/mark-all-words-like-this-in-defun "Mark all words like this in defun" :exit t)
  ("i" mc/insert-numbers "Insert numbers" :exit t)
  ("n" mc/mark-next-like-this "Mark next like this")
  ("N" mc/skip-to-next-like-this "Skip to next like this")
  ("M-n" mc/unmark-next-like-this "Unmark next like this")
  ("p" mc/mark-previous-like-this "Mark previous like this")
  ("P" mc/skip-to-previous-like-this "Skip to previous like this")
  ("M-p" mc/unmark-previous-like-this "Unmark previous like this")
  ("q" nil "Quit" :exit t))

(defhydra hydra-paredit (:color blue
                                :columns 3
                                :idle 1.0)
  "Paredit"
  ("(" paredit-wrap-round "Wrap round")
  ("[" paredit-wrap-square "Wrap square")
  ("]" paredit-wrap-square "Wrap square")
  ("{" paredit-wrap-curly "Wrap curly")
  ("s" paredit-splice-sexp "Splice")
  ("bs" cljr-splice-sexp-killing-backward "Splice kill backward")
  ("fs" cljr-splice-sexp-killing-forward "Splice kill forward")
  ("S" paredit-split-sexp "Split")
  ("j" paredit-join-sexps "Join")
  ("J" paredit-join-with-next-list "Join next list")
  ("M-J" paredit-join-with-previous-list "Join prev list")
  ("C" paredit-convolute-sexp "Convolute")
  ("M-c" paredit-copy-as-kill "Copy as kill")
  ("r" paredit-raise-sexp "Raise s-expression")
  ("R" cljr-raise-sexp "Raise s-expression (cljr)")
  ("c" paxedit-copy "Copy explicit expression, implicit expression, or comment")
  ("d" paxedit-delete "Delete expression")
  ("tb" paxedit-transpose-backward "Transpose backward")
  ("tf" paxedit-transpose-forward "Transpose forward")
  ("k" paxedit-kill "Kill explicit expression, implicit expression, or comment")
  (";" paxedit-wrap-comment "Wrap with comment"))

(defhydra hydra-transpose (:exit t
                                 :columns 3
                                 :idle 1.0)
  "Transpose"
  ("w" transpose-words "Words")
  ("W" ace-swap-window "Windows / Buffers")
  ("b" ace-swap-window "Windows / Buffers")
  ("l" transpose-lines "Lines")
  ("e" transpose-sexps "S-expressions")
  ("s" transpose-sexps "S-expressions")
  ("p" transpose-paragraphs "Paragraphs"))


(defhydra hydra-lisp-eval (:exit t
                                 :columns 2
                                 :idle 1.0)
  "Lisp eval"
  ("r" eval-region "Region")
  ("b" eval-buffer "Buffer")
  ("e" eval-expression "S-expression")
  ("l" eval-last-sexp "Last s-expression")
  ("L" eval-last-sexp-print-value "Last s-expression and print value")
  ("d" eval-defun "Defun / Function")
  ("f" eval-defun "Defun / Function"))

(defhydra hydra-ag (:exit t
                          :columns 2
                          :idle 1.0)
  "Ag Search"
  ("c" helm-ag "Current directory")
  ("d" (lambda ()
         (interactive)
         (let ((current-prefix-arg '(4)))
           (call-interactively 'helm-ag))) "Select directory")
  ("D" helm-do-ag "Select directory (interactive)")
  ("f" helm-ag-this-file "Current file")
  ("F" helm-do-ag-this-file "Current file (interactive)")
  ("p" helm-ag-project-root "Project")
  ("b" helm-ag-buffers "Buffers")
  ("B" helm-do-ag-buffers "Buffers (interactive)"))

(defhydra hydra-yasnippet (:color blue :hint nil)
  "
              ^YASnippets^
--------------------------------------------
  Modes:    Load/Visit:    Actions:

 _g_lobal  _d_irectory    _i_nsert
 _m_inor   _f_ile         _t_ryout
 _e_xtra   _l_ist         _n_ew
         _a_ll
"
  ("d" yas-load-directory)
  ("e" yas-activate-extra-mode)
  ("i" yas-insert-snippet)
  ("f" yas-visit-snippet-file :color blue)
  ("n" yas-new-snippet)
  ("t" yas-tryout-snippet)
  ("l" yas-describe-tables)
  ("g" yas-global-mode)
  ("m" yas-minor-mode)
  ("a" yas-reload-all))

;; @see https://github.com/redguardtoo/mastering-emacs-in-one-year-guide/blob/master/gnus-guide-en.org
;; gnus-group-mode
(eval-after-load 'gnus-group
  '(progn
     (defhydra hydra-gnus-group (:color blue)
       "
[_A_] Remote groups (A A) [_g_] Refresh
[_L_] Local groups        [_\\^_] List servers
[_c_] Mark all read       [_m_] Compose new mail
[_G_] Search mails (G G) [_#_] Mark mail
"
       ("A" gnus-group-list-active)
       ("L" gnus-group-list-all-groups)
       ("c" gnus-topic-catchup-articles)
       ("G" dianyou-group-make-nnir-group)
       ("g" gnus-group-get-new-news)
       ("^" gnus-group-enter-server-mode)
       ("m" gnus-group-new-mail)
       ("#" gnus-topic-mark-topic)
       ("q" nil))
     ;; y is not used by default
     (define-key gnus-group-mode-map "y" 'hydra-gnus-group/body)))

;; gnus-summary-mode
(eval-after-load 'gnus-sum
  '(progn
     (defhydra hydra-gnus-summary (:color blue)
       "
[_s_] Show thread   [_F_] Forward (C-c C-f)
[_h_] Hide thread   [_e_] Resend (S D e)
[_n_] Refresh (/ N) [_r_] Reply
[_!_] Mail -> disk  [_R_] Reply with original
[_d_] Disk -> mail  [_w_] Reply all (S w)
[_c_] Read all      [_W_] Reply all with original (S W)
[_#_] Mark          [_G_] Search mails
"
       ("s" gnus-summary-show-thread)
       ("h" gnus-summary-hide-thread)
       ("n" gnus-summary-insert-new-articles)
       ("F" gnus-summary-mail-forward)
       ("!" gnus-summary-tick-article-forward)
       ("d" gnus-summary-put-mark-as-read-next)
       ("c" gnus-summary-catchup-and-exit)
       ("e" gnus-summary-resend-message-edit)
       ("R" gnus-summary-reply-with-original)
       ("r" gnus-summary-reply)
       ("W" gnus-summary-wide-reply-with-original)
       ("w" gnus-summary-wide-reply)
       ("#" gnus-topic-mark-topic)
       ("G" dianyou-group-make-nnir-group)
       ("q" nil))
     ;; y is not used by default
     (define-key gnus-summary-mode-map "y" 'hydra-gnus-summary/body)))

;; gnus-article-mode
(eval-after-load 'gnus-art
  '(progn
     (defhydra hydra-gnus-article (:color blue)
       "
[_o_] Save attachment        [_F_] Forward
[_v_] Play video/audio       [_r_] Reply
[_d_] CLI to download stream [_R_] Reply with original
[_b_] Open external browser  [_w_] Reply all (S w)
[_f_] Click link/button      [_W_] Reply all with original (S W)
[_g_] Focus link/button
"
       ("F" gnus-summary-mail-forward)
       ("r" gnus-article-reply)
       ("R" gnus-article-reply-with-original)
       ("w" gnus-article-wide-reply)
       ("W" gnus-article-wide-reply-with-original)
       ("o" gnus-mime-save-part)
       ("v" w3mext-open-with-mplayer)
       ("d" w3mext-download-rss-stream)
       ("b" w3mext-open-link-or-image-or-url)
       ("f" w3m-lnum-follow)
       ("g" w3m-lnum-goto)
       ("q" nil))
     ;; y is not used by default
     (define-key gnus-article-mode-map "y" 'hydra-gnus-article/body)))

;; message-mode
(eval-after-load 'message
  '(progn
     (defhydra hydra-message (:color blue)
  "
[_c_] Complete mail address
[_a_] Attach file
[_s_] Send mail (C-c C-c)
"
       ("c" counsel-bbdb-complete-mail)
       ("a" mml-attach-file)
       ("s" message-send-and-exit)
       ("i" dianyou-insert-email-address-from-received-mails)
       ("q" nil))))

(defun message-mode-hook-hydra-setup ()
  (local-set-key (kbd "C-c C-y") 'hydra-message/body))
(add-hook 'message-mode-hook 'message-mode-hook-hydra-setup)

(defhydra dumb-jump-hydra (:color blue :columns 3)
    "Dumb Jump"
    ("j" dumb-jump-go "Go")
    ("o" dumb-jump-go-other-window "Other window")
    ("e" dumb-jump-go-prefer-external "Go external")
    ("x" dumb-jump-go-prefer-external-other-window "Go external other window")
    ("i" dumb-jump-go-prompt "Prompt")
    ("l" dumb-jump-quick-look "Quick look")
    ("b" dumb-jump-back "Back"))

(provide 'setup-hydra)
;;; setup-hydra.el ends here
#+end_src
** setup-init.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-init.el
;;;; setup-init.el

;; Initial setup

(defvar bootstrap-version)
(let ((bootstrap-file
       (expand-file-name "straight/repos/straight.el/bootstrap.el" user-emacs-directory))
      (bootstrap-version 5))
  (unless (file-exists-p bootstrap-file)
    (with-current-buffer
        (url-retrieve-synchronously
         "https://raw.githubusercontent.com/raxod502/straight.el/develop/install.el"
         'silent 'inhibit-cookies)
      (goto-char (point-max))
      (eval-print-last-sexp)))
  (load bootstrap-file nil 'nomessage))

;; Emacs server
(use-package server)
(unless (server-running-p)
  (server-start))

(use-package autopair
  :config
  (autopair-mode 1))

;; Shrinking fringes to 1 pixel
(fringe-mode 7)

(use-package ace-window
  :config
  (setq aw-keys '(?a ?s ?d ?f ?g ?h ?j ?k ?l))
  (setq aw-dispatch-always nil)
  (global-set-key (kbd "C-x o") 'ace-window)
  (custom-set-faces
   '(aw-leading-char-face
     ((t (:inherit ace-jump-face-foreground :height 1.0)))))
  (ace-window-display-mode 1))

(add-to-list 'aw-dispatch-alist '(?w hydra-window-size/body) t)
(add-to-list 'aw-dispatch-alist '(?r hydra-window-scroll/body) t)
(add-to-list 'aw-dispatch-alist '(?\; hydra-window-frame/body) t)

;; Remove security vulnerabiliyt
(eval-after-load "enriched"
  '(defun enriched-decode-display-prop (start end &optional param)
     (list start end)))


;; No splash screen
(setq inhibit-splash-screen t
      initial-major-mode 'org-mode)

(setq initial-scratch-message (concat
                               "#+Title: Persistent Scratch Buffer"
                               "\n#\n # Welcome! This’ a place for trying things out. \n"))
;; A very simple function to recreate the scratch buffer:
;; ( http://emacswiki.org/emacs/RecreateScratchBuffer )
(defun scratch ()
  "create a scratch buffer"
  (interactive)
  (switch-to-buffer-other-window (get-buffer-create "*scratch*"))
  (insert initial-scratch-message)
  (org-mode))

;; This doubles as a quick way to avoid the common formula: C-x b RET *scratch*
(use-package persistent-scratch
  :config
  (persistent-scratch-setup-default))

;; This is the de-facto standard in-buffer completion package. In case
;; you're wondering, Company stands for Complete Anything.
(use-package company
  :demand t
  :bind (;; Replace `completion-at-point' and `complete-symbol' with
         ;; `company-manual-begin'. You might think this could be put
         ;; in the `:bind*' declaration below, but it seems that
         ;; `bind-key*' does not work with remappings.
         ([remap completion-at-point] . company-manual-begin)
         ([remap complete-symbol] . company-manual-begin)

         ;; The following are keybindings that take effect whenever
         ;; the completions menu is visible, even if the user has not
         ;; explicitly interacted with Company.

         :map company-active-map

         ;; Make TAB always complete the current selection. Note that
         ;; <tab> is for windowed Emacs and TAB is for terminal Emacs.
         ("<tab>" . company-complete-selection)
         ("TAB" . company-complete-selection)

         ;; Prevent SPC from ever triggering a completion.
         ("SPC" . nil)

         ;; The following are keybindings that only take effect if the
         ;; user has explicitly interacted with Company.

         :map company-active-map
         :filter (company-explicit-action-p)

         ;; Make RET trigger a completion if and only if the user has
         ;; explicitly interacted with Company. Note that <return> is
         ;; for windowed Emacs and RET is for terminal Emacs.
         ("<return>" . company-complete-selection)
         ("RET" . company-complete-selection)

         ;; We then do the same for the up and down arrows. Note that
         ;; we use `company-select-previous' instead of
         ;; `company-select-previous-or-abort'. I think the former
         ;; makes more sense since the general idea of this `company'
         ;; configuration is to decide whether or not to steal
         ;; keypresses based on whether the user has explicitly
         ;; interacted with `company', not based on the number of
         ;; candidates.

         ("<up>" . company-select-previous)
         ("<down>" . company-select-next))

  :bind* (;; The default keybinding for `completion-at-point' and
          ;; `complete-symbol' is M-TAB or equivalently C-M-i. Here we
          ;; make sure that no minor modes override this keybinding.
          ("M-TAB" . company-manual-begin))

  :diminish company-mode
  :config

  ;; Turn on Company everywhere.
  (global-company-mode 1)

  ;; Show completions instantly, rather than after half a second.
  (setq company-idle-delay 0)

  ;; Show completions after typing a single character, rather than
  ;; after typing three characters.
  (setq company-minimum-prefix-length 1)

  ;; Show a maximum of 10 suggestions. This is the default but I think
  ;; it's best to be explicit.
  (setq company-tooltip-limit 10)

  ;; Always display the entire suggestion list onscreen, placing it
  ;; above the cursor if necessary.
  (setq company-tooltip-minimum company-tooltip-limit)

  ;; Always display suggestions in the tooltip, even if there is only
  ;; one. Also, don't display metadata in the echo area. (This
  ;; conflicts with ElDoc.)
  (setq company-frontends '(company-pseudo-tooltip-frontend))

  ;; Show quick-reference numbers in the tooltip. (Select a completion
  ;; with M-1 through M-0.)
  (setq company-show-numbers t)

  ;; Prevent non-matching input (which will dismiss the completions
  ;; menu), but only if the user interacts explicitly with Company.
  (setq company-require-match #'company-explicit-action-p)

  ;; Company appears to override our settings in `company-active-map'
  ;; based on `company-auto-complete-chars'. Turning it off ensures we
  ;; have full control.
  (setq company-auto-complete-chars nil)

  ;; Prevent Company completions from being lowercased in the
  ;; completion menu. This has only been observed to happen for
  ;; comments and strings in Clojure.
  (setq company-dabbrev-downcase nil)

  ;; Only search the current buffer to get suggestions for
  ;; company-dabbrev (a backend that creates suggestions from text
  ;; found in your buffers). This prevents Company from causing lag
  ;; once you have a lot of buffers open.
  (setq company-dabbrev-other-buffers nil)

  ;; Make company-dabbrev case-sensitive. Case insensitivity seems
  ;; like a great idea, but it turns out to look really bad when you
  ;; have domain-specific words that have particular casing.
  (setq company-dabbrev-ignore-case nil)

  ;; Make it so that Company's keymap overrides Yasnippet's keymap
  ;; when a snippet is active. This way, you can TAB to complete a
  ;; suggestion for the current field in a snippet, and then TAB to
  ;; move to the next field. Plus, C-g will dismiss the Company
  ;; completions menu rather than cancelling the snippet and moving
  ;; the cursor while leaving the completions menu on-screen in the
  ;; same location.

  (with-eval-after-load 'yasnippet
    ;; TODO: this is all a horrible hack, can it be done with
    ;; `bind-key' instead?

    ;; This function translates the "event types" I get from
    ;; `map-keymap' into things that I can pass to `lookup-key'
    ;; and `define-key'. It's a hack, and I'd like to find a
    ;; built-in function that accomplishes the same thing while
    ;; taking care of any edge cases I might have missed in this
    ;; ad-hoc solution.
    (defun radian--normalize-event (event)
      (if (vectorp event)
          event
        (vector event)))

    ;; Here we define a hybrid keymap that delegates first to
    ;; `company-active-map' and then to `yas-keymap'.
    (setq radian--yas-company-keymap
          ;; It starts out as a copy of `yas-keymap', and then we
          ;; merge in all of the bindings from
          ;; `company-active-map'.
          (let ((keymap (copy-keymap yas-keymap)))
            (map-keymap
             (lambda (event company-cmd)
               (let* ((event (radian--normalize-event event))
                      (yas-cmd (lookup-key yas-keymap event)))
                 ;; Here we use an extended menu item with the
                 ;; `:filter' option, which allows us to
                 ;; dynamically decide which command we want to
                 ;; run when a key is pressed.
                 (define-key keymap event
                   `(menu-item
                     nil ,company-cmd :filter
                     (lambda (cmd)
                       ;; There doesn't seem to be any obvious
                       ;; function from Company to tell whether or
                       ;; not a completion is in progress (à la
                       ;; `company-explicit-action-p'), so I just
                       ;; check whether or not `company-my-keymap'
                       ;; is defined, which seems to be good
                       ;; enough.
                       (if company-my-keymap
                           ',company-cmd
                         ',yas-cmd))))))
             company-active-map)
            keymap))

    ;; The function `yas--make-control-overlay' uses the current
    ;; value of `yas-keymap' to build the Yasnippet overlay, so to
    ;; override the Yasnippet keymap we only need to dynamically
    ;; rebind `yas-keymap' for the duration of that function.
    (defun radian--advice-company-overrides-yasnippet
        (yas--make-control-overlay &rest args)
      "Allow `company' to override `yasnippet'.
This is an `:around' advice for `yas--make-control-overlay'."
      (let ((yas-keymap radian--yas-company-keymap))
        (apply yas--make-control-overlay args)))

    (advice-add #'yas--make-control-overlay :around
                #'radian--advice-company-overrides-yasnippet)))

;; (use-package company
;;   :diminish
;;   :config
;;   (setq company-dabbrev-other-buffers t
;;         company-dabbrev-code-other-buffers t

;;         ;; Allow (lengthy) numbers to be eligible for completion.
;;         company-complete-number t

;;         ;; M-⟪num⟫ to select an option according to its number.
;;         company-show-numbers t

;;         ;; Only 2 letters required for completion to activate.
;;         company-minimum-prefix-length 2

;;         ;; Do not downcase completions by default.
;;         company-dabbrev-downcase nil

;;         ;; Even if I write something with the ‘wrong’ case,
;;         ;; provide the ‘correct’ casing.
;;         company-dabbrev-ignore-case t

;;         ;; Immediately activate completion.
;;         company-idle-delay 0
;;         )

;;   (global-company-mode 1)
;;   :bind (("C-c /" . company-complete)))

(menu-bar-mode -1)
(tool-bar-mode -1)
(scroll-bar-mode -1)

(provide 'setup-init)

;;;; setup-init.el ends here
#+END_SRC
** setup-keybindings.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-keybindings.el
;;; setup-keybindings.el
(use-package key-seq) 

(key-chord-mode 1)

(key-seq-define-global ",g" 'counsel-git)

(bind-keys* ("C-s" . helm-swoop)
            ("C-c g" . counsel-git)
            ("C-c j" . counsel-git-grep)
            ("C-c k" . counsel-ag))

(global-set-key (kbd "C-S") 'helm-swoop-back-to-last-point)
(global-set-key (kbd "C-c C-s") 'helm-multi-swoop)


(global-set-key (kbd "<s-mouse-3>") 'split-window-below)
(global-set-key (kbd "<s-mouse-1>") 'split-window-right)
(global-set-key [double-mouse-3] 'delete-window)
(global-set-key [double-mouse-1] 'delete-other-windows)

;;;;;;;;;;;;;;;;
;; Appearance ;;
;;;;;;;;;;;;;;;;
(global-set-key (kbd "C-x t") 'my/toggle-theme)
(global-set-key (kbd "C-+") 'text-scale-increase)
(global-set-key (kbd "C--") 'text-scale-decrease)

;; Unclutter the mode-line
;; My misc key bindings
(global-set-key (kbd "RET") 'newline-and-indent)
(global-set-key (kbd "M-/") 'hippie-expand)
(global-set-key (kbd "C-x g") 'magit-status)
(global-set-key (kbd "C-x f") 'recentf-open-files)
(global-set-key (kbd "C-x M-t") 'cleanup-region)
(global-set-key (kbd "C-c n") 'cleanup-buffer)
(use-package expand-region
  :config (global-set-key (kbd "C-=") 'er/expand-region))
(use-package zoom-window
  :config (global-set-key (kbd "C-x C-z") 'zoom-window-zoom))
;; setting up multiple cursors
(use-package multiple-cursors
  :config
  (global-set-key (kbd "C-S-c C-S-c") 'mc/edit-lines)
  (global-set-key (kbd "C->") 'mc/mark-next-like-this)
  (global-set-key (kbd "C-<") 'mc/mark-previous-like-this)
  (global-set-key (kbd "C-c C-<") 'mc/mark-all-like-this)
  (global-set-key (kbd "C-S-<mouse-1>") 'mc/add-cursor-on-click))
;; setting up smart-forward
(use-package smart-forward
  :config
  (global-set-key (kbd "M-S-<up>") 'smart-up)
  (global-set-key (kbd "M-S-<down>") 'smart-down)
  (global-set-key (kbd "M-S-<left>") 'smart-backward)
  (global-set-key (kbd "M-S-<right>") 'smart-forward))
(use-package change-inner)
(require 'change-inner)
(global-set-key (kbd "M-S-i") 'change-inner)
(global-set-key (kbd "M-S-o") 'change-outer)

;; Bind Imenu M-i
(global-set-key (kbd "M-i") 'imenu)

;; guide-key
(use-package guide-key
  :config
  (setq guide-key/guide-key-sequence '("C-x r" "C-x 4" "C-x v" "C-x 8" "C-x +"))
  (setq guide-key/recursive-key-sequence-flag t)
  (setq guide-key/popup-window-position 'bottom)
  (guide-key-mode 1))
(global-set-key (kbd "M-#") 'synosaurus-choose-and-replace)
(use-package wordnut
  :ensure t
  :bind ("C-c !" . wordnut-lookup-current-word))

;; Map files to modes
(global-set-key (kbd "M-y") 'helm-show-kill-ring)
(global-set-key (kbd "C-x b") 'helm-buffers-list)
(global-set-key (kbd "C-x C-b") 'ibuffer)
(global-set-key (kbd "C-c C-r") 'helm-recentf)


;;;;;;;;;;
;; helm ;;
;;;;;;;;;;
;; The default "C-x c" is quite close to "C-x C-c", which quits Emacs.
;; Changed to "C-c h". Note: We must set "C-c h" globally, because we
;; cannot change `helm-command-prefix-key' once `helm-config' is loaded.
(global-unset-key (kbd "C-x c"))
(define-key global-map [remap find-file] 'helm-find-files)
(define-key global-map [remap list-buffers] 'helm-buffers-list)
(define-key global-map [remap dabbrev-expand] 'helm-dabbrev)
(define-key global-map [remap execute-extended-command] 'helm-M-x)

(unless (boundp 'completion-in-region-function)
  (define-key lisp-interaction-mode-map [remap completion-at-point] 'helm-lisp-completion-at-point)
  (define-key emacs-lisp-mode-map       [remap completion-at-point] 'helm-lisp-completion-at-point))
(global-set-key (kbd "C-c b") 'helm-exwm)


;;;;;;;;;;
;; hugo ;;
;;;;;;;;;;
(define-key global-map (kbd "C-c C-e") 'easy-hugo)

;;;;;;;;;;;;;
;; paredit ;;
;;;;;;;;;;;;;
(define-key paredit-mode-map (kbd "M-(") 'paredit-wrap-round)
(define-key paredit-mode-map (kbd "M-)") 'paredit-wrap-round-from-behind)
(define-key paredit-mode-map (kbd "M-s-8") 'paredit-wrap-square)
(define-key paredit-mode-map (kbd "M-s-9") 'paredit-wrap-square-from-behind)
(define-key paredit-mode-map (kbd "M-s-(") 'paredit-wrap-curly)
(define-key paredit-mode-map (kbd "M-s-)") 'paredit-wrap-curly-from-behind)

(define-key paredit-mode-map (kbd "C-w") 'paredit-kill-region-or-backward-word)
(define-key paredit-mode-map (kbd "M-C-<backspace>") 'backward-kill-sexp)

;; Change nasty paredit keybindings
(defvar my-nasty-paredit-keybindings-remappings
  '(("M-s"         "s-s"         paredit-splice-sexp)
    ("M-<up>"      "s-<up>"      paredit-splice-sexp-killing-backward)
    ("M-<down>"    "s-<down>"    paredit-splice-sexp-killing-forward)
    ("C-<right>"   "s-<right>"   paredit-forward-slurp-sexp)
    ("C-<left>"    "s-<left>"    paredit-forward-barf-sexp)
    ("C-M-<left>"  "s-S-<left>"  paredit-backward-slurp-sexp)
    ("C-M-<right>" "s-S-<right>" paredit-backward-barf-sexp)))

(define-key paredit-mode-map (kbd "s-r") 'paredit-raise-sexp)

(--each my-nasty-paredit-keybindings-remappings
  (let ((original (car it))
        (replacement (cadr it))
        (command (car (last it))))
    (define-key paredit-mode-map (read-kbd-macro original) nil)
    (define-key paredit-mode-map (read-kbd-macro replacement) command)))

;; don't hijack \ please
(define-key paredit-mode-map (kbd "\\") nil)

;;;;;;;;;;;;;;;;;
;; perspective ;;
;;;;;;;;;;;;;;;;;
(define-key persp-mode-map (kbd "C-x p -") 'custom-persp-last)
(define-key projectile-mode-map (kbd "s-w") 'projectile-persp-switch-project)

;;;;;;;;;;;;;;;;;;;
;; switch-window ;;
;;;;;;;;;;;;;;;;;;;
(use-package switch-window
  :config
  (global-set-key (kbd "M-o") 'switch-window)

  (global-set-key (kbd "C-x 1") 'switch-window-then-maximize)
  (global-set-key (kbd "C-x 2") 'switch-window-then-split-below)
  (global-set-key (kbd "C-x 3") 'switch-window-then-split-right)
  (global-set-key (kbd "C-x 0") 'switch-window-then-delete)

  (global-set-key (kbd "C-x 4 d") 'switch-window-then-dired)
  (global-set-key (kbd "C-x 4 f") 'switch-window-then-find-file)
  (global-set-key (kbd "C-x 4 m") 'switch-window-then-compose-mail)
  (global-set-key (kbd "C-x 4 r") 'switch-window-then-find-file-read-only)

  (global-set-key (kbd "C-x 4 C-f") 'switch-window-then-find-file)
  (global-set-key (kbd "C-x 4 C-o") 'switch-window-then-display-buffer)

  (global-set-key (kbd "C-x 4 0") 'switch-window-then-kill-buffer))

;;;;;;;;;
;; org ;;
;;;;;;;;;
(global-set-key (kbd "C-c C-x C-r") 'org-clock-report)




;;;;;;;;;;;
;; Hydra ;;
;;;;;;;;;;;
(global-set-key (kbd "C-x j") 'dumb-jump-hydra/body)
(global-set-key (kbd "s-g") 'hydra-avy/body)
(global-set-key (kbd "C-x SPC") 'hydra-rectangle/body)
(global-set-key (kbd "C-c o") 'hydra-global-org/body)
(global-set-key (kbd "M-g M-g") 'hydra-goto-line/body)
(global-set-key (kbd "C-c m") 'hydra-mark/body)
(key-seq-define-global "./" 'hydra-mark/body)
(key-seq-define-global ".m" 'hydra-mark-buffer/body)
(key-seq-define-global "-a" 'hydra-ag/body)
(key-seq-define emacs-lisp-mode-map "-e" 'hydra-lisp-eval/body)
(key-seq-define-global ",p" 'projectile-command-map)
(key-seq-define-global ",." 'multiple-cursors-hydra/body)
(key-seq-define-global ",," 'avy-goto-char-timer)
(key-seq-define-global ",w" 'hydra-copy/body)
(key-seq-define-global "-y" 'hydra-yasnippet/body)

(provide 'setup-keybindings)
;;; setup-keybindings.el ends here
#+END_SRC
** setup-js2-mode.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-js2-mode.el
;;; setup-js2-mode.el --- tweak js2 settings -*- lexical-binding: t; -*-

(setq-default js2-allow-rhino-new-expr-initializer nil)
(setq-default js2-auto-indent-p nil)
(setq-default js2-enter-indents-newline nil)

(setq-default js2-idle-timer-delay 0.1)
(setq-default js2-indent-on-enter-key nil)
(setq-default js2-mirror-mode nil)
(setq-default js2-strict-inconsistent-return-warning nil)
(setq-default js2-auto-indent-p t)
(setq-default js2-include-rhino-externs nil)
(setq-default js2-include-gears-externs nil)
(setq-default js2-include-node-externs t)
(setq-default js2-concat-multiline-strings 'eol)
(setq-default js2-rebind-eol-bol-keys nil)

;; Let flycheck handle parse errors
(setq-default js2-show-parse-errors nil)
(setq-default js2-strict-missing-semi-warning nil)
(setq-default js2-strict-trailing-comma-warning t) ;; jshint does not warn about this now for some reason
(add-hook 'js2-mode-hook (lambda () (flycheck-mode 1)))

(use-package js2-refactor)
(js2r-add-keybindings-with-prefix "C-c C-r")

(add-hook 'js2-mode-hook (lambda ()
                           (add-hook 'xref-backend-functions #'xref-js2-xref-backend nil t)))
(setq js2-skip-preprocessor-directives t)
(js2r-add-keybindings-with-prefix "C-c C-m")

(require 'js2-imenu-extras)

(js2-imenu-extras-setup)

(defun js2r--remove-all-this-cruft-on-backward-delete ()
  (set-temporary-overlay-map
   (let ((map (make-sparse-keymap)))
     (define-key map (kbd "DEL") 'undo-tree-undo)
     (define-key map (kbd "C-h") 'undo-tree-undo)
     map) nil))

(defun js2r--does-not-need-semi ()
  (save-excursion
    (back-to-indentation)
    (or (looking-at "if ")
        (looking-at "function ")
        (looking-at "for ")
        (looking-at "while ")
        (looking-at "try ")
        (looking-at "} catch ")
        (looking-at "} else "))))

(defun js2r--comma-unless (delimiter)
  (if (looking-at (concat "[\n\t\r ]*" (regexp-quote delimiter)))
      ""
    ","))

(define-key js2-mode-map (kbd "C-c RET jt") 'jump-to-test-file)
(define-key js2-mode-map (kbd "C-c RET ot") 'jump-to-test-file-other-window)
(define-key js2-mode-map (kbd "C-c RET js") 'jump-to-source-file)
(define-key js2-mode-map (kbd "C-c RET os") 'jump-to-source-file-other-window)
(define-key js2-mode-map (kbd "C-c RET jo") 'jump-between-source-and-test-files)
(define-key js2-mode-map (kbd "C-c RET oo") 'jump-between-source-and-test-files-other-window)

(define-key js2-mode-map (kbd "C-c RET dp") 'js2r-duplicate-object-property-node)

(define-key js2-mode-map (kbd "C-c RET ta") 'toggle-assert-refute)

(defadvice js2r-inline-var (after reindent-buffer activate)
  (cleanup-buffer))

(defun js2-hide-test-functions ()
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (ignore-errors
      (while (re-search-forward "\"[^\"]+\": function (")
        (js2-mode-hide-element)))))

(define-key js2-mode-map (kbd "C-c t") 'js2-hide-test-functions)

;; js2-mode steals TAB, let's steal it back for yasnippet
(defun js2-tab-properly ()
  (interactive)
  (let ((yas-fallback-behavior 'return-nil))
    (unless (yas-expand)
      (indent-for-tab-command)
      (if (looking-back "^\s*")
          (back-to-indentation)))))

(define-key js2-mode-map (kbd "TAB") 'js2-tab-properly)

;; When renaming/deleting js-files, check for corresponding testfile
(define-key js2-mode-map (kbd "C-x C-r") 'js2r-rename-current-buffer-file)
(define-key js2-mode-map (kbd "C-x C-k") 'js2r-delete-current-buffer-file)

(define-key js2-mode-map (kbd "C-k") #'js2r-kill)

(define-key js2-mode-map (kbd "M-j") (lambda (join-line -1)))

(comment ;; avoid confusing shorthands
 ;; Use lambda for anonymous functions
 (font-lock-add-keywords
  'js2-mode `(("\\(function\\) *("
               (0 (progn (compose-region (match-beginning 1)
                                         (match-end 1) "\u0192")
                         nil)))))

 ;; Use right arrow for return in one-line functions
 (font-lock-add-keywords
  'js2-mode `(("function *([^)]*) *{ *\\(return\\) "
               (0 (progn (compose-region (match-beginning 1)
                                         (match-end 1) "\u2190")
                         nil))))))

;; After js2 has parsed a js file, we look for jslint globals decl comment ("/* global Fred, _, Harry */") and
;; add any symbols to a buffer-local var of acceptable global vars
;; Note that we also support the "symbol: true" way of specifying names via a hack (remove any ":true"
;; to make it look like a plain decl, and any ':false' are left behind so they'll effectively be ignored as
;; you can't have a symbol called "someName:false"
(add-hook 'js2-post-parse-callbacks
          (lambda ()
            (when (> (buffer-size) 0)
              (let ((btext (replace-regexp-in-string
                            ": *true" " "
                            (replace-regexp-in-string "[\n\t ]+" " " (buffer-substring-no-properties 1 (buffer-size)) t t))))
                (mapc (apply-partially 'add-to-list 'js2-additional-externs)
                      (split-string
                       (if (string-match "/\\* *global *\\(.*?\\) *\\*/" btext) (match-string-no-properties 1 btext) "")
                       " *, *" t))
                ))))

(require 'json)

(defun my-aget (key map)
  (cdr (assoc key map)))

(defun js2-fetch-autolint-externs (file)
  (let* ((settings (with-temp-buffer
                     (insert-file-literally file)
                     (javascript-mode)
                     (let (kill-ring kill-ring-yank-pointer) (kill-comment 1000))
                     (->> (buffer-substring (point-min) (point-max))
                          (s-trim)
                          (s-chop-prefix "module.exports = ")
                          (s-chop-suffix ";")
                          (json-read-from-string))))
         (predef (->> settings
                      (my-aget 'linterOptions)
                      (my-aget 'predef))))
    (--each (append predef nil)
      (add-to-list 'js2-additional-externs it))))

(defun cjsp--eldoc-innards (beg)
  (save-excursion
    (goto-char beg)
    (search-forward "=")
    (let ((start (point)))
      (search-forward "*/")
      (forward-char -2)
      (buffer-substring-no-properties start (point)))))

(defun cjsp--indentation-of-html-line (html line-number)
  (with-temp-buffer
    (insert html)
    (html-mode)
    (indent-region (point-min) (point-max))
    (goto-line line-number)
    (back-to-indentation)
    (current-column)))

(defun cjsp--line-number-in-eldoc (p beg)
  (save-excursion
    (goto-char p)
    (let ((l (line-number-at-pos)))
      (goto-char beg)
      (- l (line-number-at-pos) -1))))

(defun js2-lineup-comment (parse-status)
  "Indent a multi-line block comment continuation line."
  (let* ((beg (nth 8 parse-status))
         (first-line (js2-same-line beg))
         (p (point))
         (offset (save-excursion
                   (goto-char beg)
                   (cond

                    ((looking-at "/\\*:DOC ")
                     (+ 2 (current-column)
                        (cjsp--indentation-of-html-line
                         (cjsp--eldoc-innards beg)
                         (cjsp--line-number-in-eldoc p beg))))

                    ((looking-at "/\\*")
                     (+ 1 (current-column)))

                    (:else 0)))))
    (unless first-line
      (indent-line-to offset))))
(setq js-indent-level 2)
;; js-mode (which js2 is based on) binds "M-." which conflicts with xref, so
;; unbind it.
(define-key js-mode-map (kbd "M-.") nil)

(provide 'setup-js2-mode)

;;; setup-js2-mode.el ends here
#+END_SRC
** setup-magit.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-magit.el
;;; setup-magit.el

;; move cursor into position when entering commit message
(use-package diff-hl :ensure)

(defun my/magit-cursor-fix ()
 (beginning-of-buffer)
 (when (looking-at "#")
   (forward-line 2)))

(defun magit-status-fullscreen (prefix)
  (interactive "P")
  (magit-status)
  (unless prefix
    (delete-other-windows)))

(use-package magit-todos :ensure
  :after magit
  :after hl-todo)

(use-package hl-todo :ensure
  :config
  ;; Adding a new keyword: TEST.
  (add-to-list 'hl-todo-keyword-faces '("TEST" . "#dc8cc3"))
  :init
  (add-hook 'text-mode-hook (lambda () (hl-todo-mode t))))


;; full screen magit-status
;; Efficient version control.
(use-package magit :ensure
  :config
  (global-set-key (kbd "C-x g") 'magit-status)
  (global-set-key (kbd "C-x M-g") 'magit-dispatch)
  (add-hook 'git-commit-mode-hook 'my/magit-cursor-fix)
  (add-hook 'magit-post-refresh-hook 'diff-hl-magit-post-refresh)
  ;; don't prompt me
  (set-default 'magit-pushq-always-verify nil)
  ;; (set-default 'magit-revert-buffers 'silent)
  (set-default 'magit-no-confirm '(stage-all-changes
                                   unstage-all-changes))
  (set-default 'magit-diff-refine-hunk t)
  ;; update diff-hl
  (global-diff-hl-mode))

(define-key magit-file-mode-map
  (kbd "C-c g") 'magit-file-dispatch)

(require 'magit-git)
(defun my/magit-check-file-and-popup ()
  "If the file is version controlled with git
  and has uncommitted changes, open the magit status popup."
  (let ((file (buffer-file-name)))
    (when (and file (magit-anything-modified-p t file))
      (message "This file has uncommited changes!")
      (when nil ;; Became annoying after some time.
        (split-window-below)
        (other-window 1)
        (magit-status)))))

;; I usually have local variables, so I want the message to show
;; after the locals have been loaded.
(add-hook 'find-file-hook
          '(lambda ()
             (add-hook 'hack-local-variables-hook 'my/magit-check-file-and-popup)))

;; (use-package forge
;;   :after magit
;;   :config
;;   (setq forge-topic-list-columns
;;         '(("#" 4
;;            (lambda (a b)
;;              (> (car a) (car b)))
;;            (:right-align t) number nil)
;;           ("Title" 35 t nil title  nil)
;;           ("Milestone" 9 t nil milestone nil)
;;           ("State" 6 t nil state nil)
;;           ("Updated" 10 t nill updated nil))))

(add-hook 'server-switch-hook 'magit-commit-diff)
(provide 'setup-magit)
;;; setup-magit.el ends here
#+END_SRC
** setup-markdown.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-markdown.el
;;; setup-markdown.el
(use-package markdown-mode :ensure
  :mode (("\\.yml$" . yaml-mode)
         ("\\.yaml$" . yaml-mode))
  :config
  (setq markdown-command "/usr/local/bin/pandoc")
  ;; (setq markdown-command "pandoc --smart -f markdown -t html")
  (setq markdown-imenu-generic-expression
        '(("title"  "^\\(.*\\)[\n]=+$" 1)
          ("h2-"    "^\\(.*\\)[\n]-+$" 1)
          ("h1"   "^# \\(.*\\)$" 1)
          ("h2"   "^## \\(.*\\)$" 1)
          ("h3"   "^### \\(.*\\)$" 1)
          ("h4"   "^#### \\(.*\\)$" 1)
          ("h5"   "^##### \\(.*\\)$" 1)
          ("h6"   "^###### \\(.*\\)$" 1)
          ("fn"   "^\\[\\^\\(.*\\)\\]" 1)
          ))
  (add-hook 'markdown-mode-hook
            (lambda ()
              (setq imenu-generic-expression markdown-imenu-generic-expression)))

  (add-hook 'markdown-mode-hook
	    (lambda ()
	      (visual-line-mode t)
	      (writegood-mode t)
	      (flyspell-mode t))))

(provide 'setup-markdown)

;;; setup-markdown.el ends here
#+END_SRC
** setup-org.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-org.el
;;; setup-org.el

;; Org-mode

(defun org-clock-select-task (&optional prompt)
  "Select a task that was recently associated with clocking.
  If `org-select-task-completing', use a completing-read to select.
  Otherwise use the custom orgmode menus."
  (interactive)
  (let (och chl sel-list rpl (i 0) s)
    ;; Remove successive dups from the clock history to consider
    (mapc (lambda (c) (if (not (equal c (car och))) (push c och)))
          org-clock-history)
    (setq och (reverse och) chl (length och))
    (if (zerop chl)
        (user-error "No recent clock")
      ;; Completing read (e.g. Helm)
      (if org-select-task-completing
          (let ((crlist (org-select-task-table och i)))
            (cdr (gethash (completing-read "Clock Task Select:" crlist nil t) crlist)))
        ;; Orgmode menus
        (save-window-excursion
          (org-switch-to-buffer-other-window
           (get-buffer-create "*Clock Task Select*"))
          (erase-buffer)
          (when (marker-buffer org-clock-default-task)
            (insert (org-add-props "Default Task\n" nil 'face 'bold))
            (setq s (org-clock-insert-selection-line ?d org-clock-default-task))
            (push s sel-list))
          (when (marker-buffer org-clock-interrupted-task)
            (insert (org-add-props "The task interrupted by starting the last one\n" nil 'face 'bold))
            (setq s (org-clock-insert-selection-line ?i org-clock-interrupted-task))
            (push s sel-list))
          (when (org-clocking-p)
            (insert (org-add-props "Current Clocking Task\n" nil 'face 'bold))
            (setq s (org-clock-insert-selection-line ?c org-clock-marker))
            (push s sel-list))
          (insert (org-add-props "Recent Tasks\n" nil 'face 'bold))
          (mapc
           (lambda (m)
             (when (marker-buffer m)
               (setq i (1+ i)
                     s (org-clock-insert-selection-line
                        (if (< i 10)
                            (+ i ?0)
                          (+ i (- ?A 10))) m))
               (if (fboundp 'int-to-char) (setf (car s) (int-to-char (car s))))
               (push s sel-list)))
           och)
          (run-hooks 'org-clock-before-select-task-hook)
          (goto-char (point-min))
          ;; Set min-height relatively to circumvent a possible but in
          ;; `fit-window-to-buffer'
          (fit-window-to-buffer nil nil (if (< chl 10) chl (+ 5 chl)))
          (message (or prompt "Select task for clocking:"))
          (setq cursor-type nil rpl (read-char-exclusive))
          (cond
           ((eq rpl ?q) nil)
           ((eq rpl ?x) nil)
           ((assoc rpl sel-list) (message (cdr (assoc rpl sel-list))))
           (t (user-error "Invalid task choice %c" rpl)))))))
  )

(defun org-clock-get-selection-line (marker)
  "Return the string for a line for the clock selection list,
  for use in a completing-read"
  (when (marker-buffer marker)
    (let (file cat task heading prefix)
      (with-current-buffer (org-base-buffer (marker-buffer marker))
        (save-excursion
          (save-restriction
            (widen)
            (ignore-errors
              (goto-char marker)
              (setq file (buffer-file-name (marker-buffer marker))
                    cat (org-get-category)
                    heading (org-get-heading 'notags)
                    prefix (save-excursion
                             (org-back-to-heading t)
                             (looking-at org-outline-regexp)
                             (match-string 0))
                    task (substring
                          (org-fontify-like-in-org-mode
                           (concat prefix heading)
                           org-odd-levels-only)
                          (length prefix)))))))
      (when (and cat task)
        (format "%s\t%s" cat task)
        ))))

(defun org-select-task-table (och i)
  "Return a hash table equivalent to the
  regular clock task selection list, associating
  task-name with (char, marker)"
  (let ((crlist (make-hash-table :test #'equal)))
    (mapc (lambda (l) (puthash
                       (org-clock-get-selection-line l)
                       (cons (if (< i 10)
                                 (+ i ?0)
                               (+ i (- ?A 10)))
                             l) crlist)) och)
    crlist))

;; From Jason
(defun clone-and-narrow-org-element ()
  (interactive)
  (setq current-prefix-arg '(4)) ; C-u
  (call-interactively 'clone-indirect-buffer)
  (org-narrow-to-element))

(defun bh/is-project-p ()
  "Any task with a todo keyword subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task has-subtask))))

(defun bh/is-task-p ()
  "Any task with a todo keyword and no subtask"
  (save-restriction
    (widen)
    (let ((has-subtask)
          (subtree-end (save-excursion (org-end-of-subtree t)))
          (is-a-task (member (nth 2 (org-heading-components)) org-todo-keywords-1)))
      (save-excursion
        (forward-line 1)
        (while (and (not has-subtask)
                    (< (point) subtree-end)
                    (re-search-forward "^\*+ " subtree-end t))
          (when (member (org-get-todo-state) org-todo-keywords-1)
            (setq has-subtask t))))
      (and is-a-task (not has-subtask)))))

(defun clock-in-to-inprogress (kw)
  "Switch a task from NEXT to INPROGRESS when clocking in.
   Skips capture tasks, projects, and subprojects.
    Switch projects and subprojects from NEXT back to TODO"
  (when (not (and (boundp 'org-capture-mode) org-capture-mode))
    (cond
     ((and (member (org-get-todo-state) (list "TODO" "WAITING" "ON_HOLD"))
           (bh/is-task-p))
      "STARTED")
     ((and (member (org-get-todo-state) (list "TODO" "WAITING" "ON_HOLD"))
           (bh/is-project-p))
      "STARTED"))))

(defun pinentry-emacs (desc prompt ok error)
  (let ((str (read-passwd (concat (replace-regexp-in-string "%22" "\"" (replace-regexp-in-string "%0A" "\n" desc)) prompt ": "))))
    str))

(defun find-project-task ()
  "Move point to the parent (project) task if any"
  (save-restriction
    (widen)
    (let ((parent-task (save-excursion (org-back-to-heading 'invisible-ok) (point))))
      (while (org-up-heading-safe)
        (when (member (nth 2 (org-heading-components)) org-todo-keywords-1)
          (setq parent-task (point))))
      (goto-char parent-task)
      parent-task)))


(use-package ob-async :ensure)
(use-package ob-elm :ensure)
(use-package ob-go :ensure)
(use-package  ob-restclient :ensure)
(use-package toc-org
  :ensure
  :hook
  ((toc-org-mode . org-mode-hook)))

(use-package magit-org-todos
  :ensure
  :config
  (magit-org-todos-autoinsert))

(use-package writegood-mode :ensure)
(use-package org-pomodoro :ensure)

(use-package ol
  :config
  (setq org-link-keep-stored-after-insertion t)
  :bind (:map org-mode-map
              ("C-c l" . org-store-link)
              ("C-c S-l" . org-toggle-link-display)

              ("C-c C-S-l" . org-insert-last-stored-link)))

(use-package org
  :ensure
  :hook (org-mode . writegood-mode)
  :config
  ;; (require 'ox-extra)
  ;; (require 'ob)

  (cl-defun my/make/org-capture-template
      (shortcut heading &optional (no-todo nil) (description heading) (category heading))
    "Quickly produce an org-capture-template.

      After adding the result of this function to ‘org-capture-templates’,
      we will be able perform a capture with “C-c c ‘shortcut’”
      which will have description ‘description’.
      It will be added to the tasks file under heading ‘heading’
      and be marked with category  ‘category’.

      ‘no-todo’ omits the ‘TODO’ tag from the resulting item; e.g.,
      when it's merely an interesting note that needn't be acted upon.
      ─Probably a bad idea─

      Defaults for ‘description’ and ‘category’ are set to the same as
      the ‘heading’. Default for ‘no-todo’ is ‘nil’.
      "
    `(,shortcut ,description entry
                (file+headline org-default-notes-file
                               ,(concat heading "\n#+CATEGORY: " category))
                , (concat "*" (unless no-todo " TODO") " %?\n:PROPERTIES:\n:CREATED: %U\n:END:\n\n")
                :empty-lines 1))
  (setq alert-default-style 'libnotify)
  (setq epa-pinentry-mode 'loopback)
  (setq org-agenda-files '("/home/bonface/Self/org/journal.org" "/home/bonface/Self/org/notes.org"))
  (setq org-agenda-ndays 7)
  (setq org-agenda-show-all-dates t)
  (setq org-agenda-skip-deadline-if-done t)
  (setq org-agenda-skip-scheduled-if-done t)
  (setq org-agenda-start-on-weekday nil)
  (setq org-agenda-text-search-extra-files (quote (agenda-archives)))
  (setq org-archive-location "%s_archive::* Archived Tasks")
  (setq org-catch-invisible-edits 'show)
  (setq org-clock-history-length 23)
  (setq org-clock-in-resume t)
  (setq org-clock-in-switch-to-state 'clock-in-to-inprogress)
  (setq org-clock-out-remove-zero-time-clocks t)
  (setq org-clock-out-when-done t)
  (setq org-clock-persist t)
  (setq org-clock-report-include-clocking-task t)
  (setq org-crypt-key "D4F09EB110177E03C28E2FE1F5BBAE1E0392253F")
  (setq org-deadline-warning-days 14)
  (setq org-default-notes-file "~/Self/org/journal.org")
  (setq org-ellipsis " ⤵")
  (setq org-fontify-quote-and-verse-blocks t)
  (setq org-hide-block-startup t)
  (setq org-imenu-depth 7)
  (setq org-log-done t)
  (setq org-log-into-drawer t)
  (setq org-log-note-clock-out t)
  (setq org-plantuml-jar-path (expand-file-name "/home/bonface/.guix-profile/bin/plantuml"))
  (setq org-return-follows-link t)
  (setq org-reverse-note-order nil)
  (setq org-select-task-completing t)
  ;; Reset the org-template expnsion system, this is need after upgrading to org 9 for some reason
  (setq org-structure-template-alist (eval (car (get 'org-structure-template-alist 'standard-value))))
  (setq org-special-ctrl-a/e t)
  (setq org-src-preserve-indentation t)
  (setq org-src-tab-acts-natively t)
  (setq org-startup-indented t)
  (setq org-tags-exclude-from-inheritance (quote ("crypt")))
  (setq org-timer-default-timer 45)
  (setq org-use-fast-todo-selection t)
  (setq org-use-speed-commands t)
  (setq org-yank-adjusted-subtrees t)
  (setq org-todo-keywords (quote ((sequence "TODO(t)" "STARTED(s@/!)" "|" "DONE(d/!)")
                                  (sequence "WAITING(w@/!)" "ON_HOLD(h@/!)" "|" "CANCELLED(c@/!)")
                                  (sequence "MEETING(m)" "IN_PROGRESS(i@/!)" "FINISHED(f/!)" "|" "DROPPED(d@/!)"))))
  (setq org-todo-keyword-faces (quote (("TODO" :foreground "green" :weight bold)
                                       ("STARTED" :foreground "yellow" :weight bold)
                                       ("DONE" :foreground "orange" :weight bold)
                                       ("WAITING" :foreground "brown" :weight bold)
                                       ("ON_HOLD" :foreground "grey" :weight bold)
                                       ("CANCELLED" :foreground "red" :weight bold))))
  (setq org-capture-templates
        `(
          ,(my/make/org-capture-template "t" "Tasks, Getting Things Done")
          ,(my/make/org-capture-template "r" "Research")
          ,(my/make/org-capture-template "m" "Email")
          ,(my/make/org-capture-template "e" "Emacs (•̀ᴗ•́)و")
          ,(my/make/org-capture-template "b" "Blog")
          ,(my/make/org-capture-template "a" "Arbitrary Reading and Learning")
          ,(my/make/org-capture-template "p" "Personal Matters")
          ,(my/make/org-capture-template "i" "Meetings, Interviews or Zoom Calls")
          ,(my/make/org-capture-template "c" "Chores, Repetitive tasks")
          ("n" "Note" entry (file "~/Self/org/notes.org")
           "* %? :NOTE:\n%U\n%a\n" :clock-in t :clock-resume t)))
  (setq org-capture-templates-contexts
        '(("r" ((in-mode . "gnus-summary-mode")
                (in-mode . "gnus-article-mode")
                (in-mode . "message-mode")))))
  (org-clock-persistence-insinuate)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((shell . t)
     (emacs-lisp . t)
     (lisp . t)
     (ditaa . t)
     (plantuml . t)
     (scheme . t)
     (dot . t)
     (elm . t)
     (haskell . t)
     (go .t )
     (plantuml . t)
     (ruby . t)
     (js . t)
     (python . t)
     (restclient . t)
     (sql . t)
     (C . t)))

  (add-hook 'org-mode-hook '(lambda ()
                              (local-set-key (kbd "<return>") 'org-return-indent))
            (local-set-key (kbd "C-M-<return>") 'electric-indent-just-newline))
  (add-hook 'org-clock-in-hook 'org-pomodoro)
  (eval-after-load "org-present"
    '(progn
       (add-hook 'org-present-mode-hook
                 (lambda ()
                   (org-present-big)
                   (org-display-inline-images)
                   (org-present-hide-cursor)
                   (org-present-read-only)))
       (add-hook 'hide-line-hook
                 (lambda ()
                   (hide-line-mode)))
       (add-hook 'org-present-mode-quit-hook
                 (lambda ()
                   (org-present-small)
                   (org-remove-inline-images)
                   (org-present-show-cursor)
                   (org-present-read-write)))))
  (org-agenda "a" "a")
  (require 'org-crypt)
  (org-crypt-use-before-save-magic)
  (setenv "GPG_AGENT_INFO" nil)

  (add-to-list 'org-agenda-custom-commands
               '("c" todo "DONE|ON_HOLD|CANCELLED" nil))
  (add-to-list 'org-agenda-custom-commands
               '("%" "Appointments" agenda* "Today's appointments"
                 ((org-agenda-span 1)
                  (org-agenda-max-entries 3))))
  (add-to-list 'org-src-lang-modes '("plantuml" . plantuml))
  (add-to-list 'org-agenda-custom-commands
               '("u" alltodo ""
                 ((org-agenda-skip-function
                   (lambda ()
                     (org-agenda-skip-entry-if 'scheduled 'deadline 'regexp  "\n]+>")))
                  (org-agenda-overriding-header "Unscheduled TODO entries: "))))

  :bind (("C-c C-x n" . clone-and-narrow-org-element)
         ("C-c l" . org-store-link)
         ("C-c a" . org-agenda)
         ("C-c b" . org-switchb)
         ("C-c c" . org-capture);; Tasks get a 25 minute count down timer
         :map org-mode-map
         ("C-c C-m" . helm-org-rifle)
         ("C-;" . avy-goto-char)
         ("C-'" . avy-goto-char-timer)
         ("s-p" . org-babel-previous-src-block)
         ("s-n" . org-babel-next-src-block)
         ("s-e" . org-edit-src-block)
         :map org-src-mode-map
         ("s-e" . org-edit-src-block)))

(use-package org-journal
  :bind (("C-c j" . org-journal-new-entry))
  :config
  (setq org-journal-dir "~/Self/org/journal/")
  (setq org-journal-file-type 'yearly))


(use-package org-tanglesync
  :hook (org-mode . org-tanglesync-mode)
  :bind
  (( "C-c M-i" . org-tanglesync-process-buffer-interactive))
  ( "C-c M-a" . org-tanglesync-process-buffer-automatic))

(setq org-tanglesync-skip-user-check nil)

;; src: https://pank.eu/blog/pretty-babel-src-blocks.html#coderef-symbol
(with-eval-after-load 'org
  (defvar-local rasmus/org-at-src-begin -1
    "Variable that holds whether last position was a ")

  (defvar rasmus/ob-header-symbol ?☰
    "Symbol used for babel headers")

  (defun rasmus/org-prettify-src--update ()
    (let ((case-fold-search t)
          (re "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*")
          found)
      (save-excursion
        (goto-char (point-min))
        (while (re-search-forward re nil t)
          (goto-char (match-end 0))
          (let ((args (org-trim
                       (buffer-substring-no-properties (point)
                                                       (line-end-position)))))
            (when (org-string-nw-p args)
              (let ((new-cell (cons args rasmus/ob-header-symbol)))
                (cl-pushnew new-cell prettify-symbols-alist :test #'equal)
                (cl-pushnew new-cell found :test #'equal)))))
        (setq prettify-symbols-alist
              (cl-set-difference prettify-symbols-alist
                                 (cl-set-difference
                                  (cl-remove-if-not
                                   (lambda (elm)
                                     (eq (cdr elm) rasmus/ob-header-symbol))
                                   prettify-symbols-alist)
                                  found :test #'equal)))
        ;; Clean up old font-lock-keywords.
        (font-lock-remove-keywords nil prettify-symbols--keywords)
        (setq prettify-symbols--keywords (prettify-symbols--make-keywords))
        (font-lock-add-keywords nil prettify-symbols--keywords)
        (while (re-search-forward re nil t)
          (font-lock-flush (line-beginning-position) (line-end-position))))))

  (defun rasmus/org-prettify-src ()
    "Hide src options via `prettify-symbols-mode'.

      `prettify-symbols-mode' is used because it has uncollapsing. It's
      may not be efficient."
    (let* ((case-fold-search t)
           (at-src-block (save-excursion
                           (beginning-of-line)
                           (looking-at "^[ \t]*#\\+begin_src[ \t]+[^ \f\t\n\r\v]+[ \t]*"))))
      ;; Test if we moved out of a block.
      (when (or (and rasmus/org-at-src-begin
                     (not at-src-block))
                ;; File was just opened.
                (eq rasmus/org-at-src-begin -1))
        (rasmus/org-prettify-src--update))
      ;; Remove composition if at line; doesn't work properly.
      ;; (when at-src-block
      ;;   (with-silent-modifications
      ;;     (remove-text-properties (match-end 0)
      ;;                             (1+ (line-end-position))
      ;;                             '(composition))))
      (setq rasmus/org-at-src-begin at-src-block)))

  (defun rasmus/org-prettify-symbols ()
    (mapc (apply-partially 'add-to-list 'prettify-symbols-alist)
          (cl-reduce 'append
                     (mapcar (lambda (x) (list x (cons (upcase (car x)) (cdr x))))
                             `(("#+begin_src" . ?✎) ;; ➤ 🖝 ➟ ➤ ✎
                               ("#+end_src"   . ?□) ;; ⏹
                               ("#+header:" . ,rasmus/ob-header-symbol)
                               ("#+begin_quote" . ?»)
                               ("#+end_quote" . ?«)))))
    (turn-on-prettify-symbols-mode)
    (add-hook 'post-command-hook 'rasmus/org-prettify-src t t))
  (add-hook 'org-mode-hook #'rasmus/org-prettify-symbols))

(global-prettify-symbols-mode -1)

(defvar my-prettify-alist nil
  "Musa's personal prettifications.")

(push '("<=" . ?≤) my-prettify-alist)
(push '("#+begin_example" . (?ℰ (Br . Bl) ?⇒)) my-prettify-alist) ;; ℰ⇒
(push '("#+end_example" . ?⇐) my-prettify-alist)                  ;; ⇐

(-let [modify (lambda ()
                (setq prettify-symbols-alist
                      (append my-prettify-alist prettify-symbols-alist)))]

  (add-hook 'text-mode-hook modify)
  (add-hook 'prog-mode-hook modify)
  ;; For org-example blocks, “C-c '” to see the prettifications of language constructs.
  ;; Or alter the particular hook directly.
  )

(use-package ox-reveal :ensure t
  :config (setq org-reveal-root "https://cdn.jsdelivr.net/reveal.js/3.0.0/"))

(use-package ox-gfm :ensure
  :config
  (eval-after-load "org"
    '(require 'ox-gfm nil t)))

;; FIX: https://github.com/syl20bnr/spacemacs/issues/11798
(when (version<= "9.2" (org-version))
  (require 'org-tempo))


;; src: https://emacs.stackexchange.com/questions/35784/org-edit-src-code-do-not-pop-a-new-window-use-the-current-one/35808#35808
;; The idea is to open the src block in the current window
(setq org-src-window-setup 'current-window)
(setq auto-save-default t)

(setq prettify-symbols-unprettify-at-point 'right-edge)

;; src: https://bzg.fr/en/some-emacs-org-mode-features-you-may-not-know.html/
(setq org-tag-alist
      '((:startgroup)
        ("HandsOn" . ?o) ;; The grouping tag
        (:grouptags)
        ("Write" . ?w) ("Code" . ?c) ("Mail" . ?@) ("Homechow" . ?h)
        (:endgroup)
        (:startgroup)
        ("Handsoff" . ?f) ;; The grouping tag
        (:grouptags)
        ("Read" . ?r) ("View" . ?v) ("Listen" . ?l)
        (:endgroup)
        ;; Off groups
        ("Print" . ?P) ("Buy" . ?B) ("Patch" . ?p) ("Bug" . ?b)))
(setq org-agenda-compact-blocks t)

;; src: https://emacs.stackexchange.com/a/21128
(defun my-org-confirm-babel-evaluate (lang body)
  (not (member lang '("scheme" "python" "sh" "bash"))))

(setq org-confirm-babel-evaluate 'my-org-confirm-babel-evaluate)

(use-package el-patch :ensure)

(use-package deft
  :ensure
  :after org
  :custom
  (deft-recursive t)
  (deft-use-filter-string-for-filename t)
  (deft-default-extension "org")
  (deft-directory "~/Self/org-roam/")
  :config/el-patch
  (defun deft-parse-title (file contents)
    "Parse the given FILE and CONTENTS and determine the title.
  If `deft-use-filename-as-title' is nil, the title is taken to
  be the first non-empty line of the FILE.  Else the base name of the FILE is
  used as title."
    (el-patch-swap (if deft-use-filename-as-title
                       (deft-base-filename file)
                     (let ((begin (string-match "^.+$" contents)))
                       (if begin
                           (funcall deft-parse-title-function
                                    (substring contents begin (match-end 0))))))
                   (org-roam--get-title-or-slug file))))


(use-package org-download
  :after org
  :bind
  (:map org-mode-map
        (("s-Y" . org-download-screenshot)
         ("s-y" . org-download-yank))))

(use-package org-fc
  :ensure
  :straight (org-fc :type git :host github :repo "l3kn/org-fc")
  :custom
  (org-fc-directories '("~/Self/org-roam/")))

(global-set-key (kbd "C-c f") 'org-fc-hydra/body)
(setq org-journal-dir "/home/bonface/Self/org/journal/")

(use-package org-roam
  :ensure
  :hook
  (after-init . org-roam-mode)
  :custom
  (org-roam-directory "~/Self/org-roam/")
  :config
  (setq org-roam-graph-exclude-matcher '("archive" "report" "work_log"))
  (setq org-roam-completion-system 'helm)
  :bind (:map org-roam-mode-map
              (("C-c n l" . org-roam)
               ("C-c n f" . org-roam-find-file)
               ("C-c n j" . org-roam-jump-to-index)
               ("C-c n b" . org-roam-switch-to-buffer)
               ("C-c n d" . deft)
               ("C-c n j" . org-journal-new-entry)
               ("C-c n g" . org-roam-graph))
              :map org-mode-map
              (("C-c n i" . org-roam-insert))))

(require 'time-stamp)

(setq org-pomodoro-length 45)
(add-hook 'write-file-functions 'time-stamp)


;; allow for export=>beamer by placing

;; #+LaTeX_CLASS: beamer in org files
(unless (boundp 'org-export-latex-classes)
  (setq org-export-latex-classes nil))
(add-to-list 'org-export-latex-classes
             ;; beamer class, for presentations
             '("beamer"
               "\\documentclass[11pt]{beamer}\n
      \\mode<{{{beamermode}}}>\n
      \\usetheme{{{{beamertheme}}}}\n
      \\usecolortheme{{{{beamercolortheme}}}}\n
      \\beamertemplateballitem\n
      \\setbeameroption{show notes}
      \\usepackage[utf8]{inputenc}\n
      \\usepackage[T1]{fontenc}\n
      \\usepackage{hyperref}\n
      \\usepackage{color}
      \\usepackage{listings}
      \\lstset{numbers=none,language=[ISO]C++,tabsize=4,
  frame=single,
  basicstyle=\\small,
  showspaces=false,showstringspaces=false,
  showtabs=false,
  keywordstyle=\\color{blue}\\bfseries,
  commentstyle=\\color{red},
  }\n
      \\usepackage{verbatim}\n
      \\institute{{{{beamerinstitute}}}}\n
       \\subject{{{{beamersubject}}}}\n"

               ("\\section{%s}" . "\\section*{%s}")

               ("\\begin{frame}[fragile]\\frametitle{%s}"
                "\\end{frame}"
                "\\begin{frame}[fragile]\\frametitle{%s}"
                "\\end{frame}")))

;; letter class, for formal letters



(provide 'setup-org)
;;; setup-org.el ends here
#+END_SRC
** setup-package.el
#+begin_src emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-package.el
;;; setup-package.el
(require 'package)

;; Internet repos for new packages
(setq package-archives '(("org"       . "https://orgmode.org/elpa/")
                         ("gnu"       . "http://elpa.gnu.org/packages/")
                         ("melpa"     . "https://melpa.org/packages/")))
;; Initialise the packages, avoiding a re-initialisation.
(unless (bound-and-true-p package--initialized)
  (setq package-enable-at-startup nil)
  (package-initialize))

;; Make sure `use-package' is available.
(unless (package-installed-p 'use-package)
  (package-refresh-contents)
  (package-install 'use-package))

;; Configure `use-package' prior to loading it.
(eval-and-compile
  (setq use-package-always-ensure nil)
  (setq use-package-always-defer nil)
  (setq use-package-always-demand nil)
  (setq use-package-expand-minimally nil)
  (setq use-package-enable-imenu-support t)
  (setq use-package-compute-statistics t)
  ;; The following is VERY IMPORTANT.  Write hooks using their real name
  ;; instead of a shorter version: after-init ==> `after-init-hook'.
  ;;
  ;; This is to empower help commands with their contextual awareness,
  ;; such as `describe-symbol'.
  (setq use-package-hook-name-suffix nil))

(eval-when-compile
  (require 'use-package))

(provide 'setup-package)

;;; setup-package.el
#+end_src
** setup-paredit.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-paredit.el
;;; setup-paredit.el

;; My keybindings for paredit
(use-package paredit :ensure)

(defun paredit-wrap-round-from-behind ()
  (interactive)
  (forward-sexp -1)
  (paredit-wrap-round)
  (insert " ")
  (forward-char -1))

(defun paredit-wrap-square-from-behind ()
  (interactive)
  (forward-sexp -1)
  (paredit-wrap-square))

(defun paredit-wrap-curly-from-behind ()
  (interactive)
  (forward-sexp -1)
  (paredit-wrap-curly))

(defun paredit-kill-region-or-backward-word ()
  (interactive)
  (if (region-active-p)
      (kill-region (region-beginning) (region-end))
    (paredit-backward-kill-word)))

(add-hook 'clojure-mode-hook (lambda () (paredit-mode 1)))
(add-hook 'cider-repl-mode-hook (lambda () (paredit-mode 1)))
(add-hook 'emacs-lisp-mode-hook (lambda () (paredit-mode 1)))

;; Enable `paredit-mode' in the minibuffer, during `eval-expression'.
(defun conditionally-enable-paredit-mode ()
  (if (eq this-command 'eval-expression)
      (paredit-mode 1)))

(add-hook 'minibuffer-setup-hook 'conditionally-enable-paredit-mode)

;; making paredit work with delete-selection-mode
(put 'paredit-forward-delete 'delete-selection 'supersede)
(put 'paredit-backward-delete 'delete-selection 'supersede)
(put 'paredit-newline 'delete-selection t)

;; functions in smartparens that do not have an equivalent in paredit - take a look at them
(when nil
  '(sp-beginning-of-sexp
    sp-end-of-sexp
    sp-next-sexp
    sp-previous-sexp
    sp-kill-sexp
    sp-unwrap-sexp
    sp-backward-unwrap-sexp
    sp-select-next-thing-exchange
    sp-select-next-thing
    sp-forward-symbol
    sp-backward-symbol))

(provide 'setup-paredit)
;;; setup-paredit.el ends here
#+END_SRC
** setup-perspective.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-perspective.el
;;; setup-perspective.el

;; Load Perspective
(use-package perspective :ensure)

;; Enable perspective mode
(use-package persp-mode :ensure
  :config
  (setq persp-autokill-buffer-on-remove 'kill-weak)
  ;; :hook after-init  ;; <--- offending line
  ;; :bind-keymap
  ;; ("C-c p" . persp-key-map)
  )


(use-package persp-projectile :ensure)

;; TODO: implement persp-last as before-advice on persp-switch (?)
(defmacro custom-persp (name &rest body)
  `(let ((initialize (not (gethash ,name (perspectives-hash))))
         (current-perspective (persp-curr)))
     (persp-switch ,name)
     (when initialize ,@body)
     (set-frame-parameter nil 'persp--last current-perspective)))

;; Jump to last perspective
(defun custom-persp-last ()
  (interactive)
  (persp-switch (persp-name persp-last)))

(provide 'setup-perspective)

;;; setup-perspective.el ends here
#+END_SRC

** setup-rcirc.el
#+BEGIN_SRC emacs-lisp :tangle ~/.emacs.d/settings/setup-rcirc.el
;;; setup-rcirc.el

(use-package rcirc
  :config
  (setq rcirc-debug-flag t)

  ;; Adjust the colours of one of the faces.
  (set-face-foreground 'rcirc-my-nick "red" nil)

  ;; Include date in time stamp.
  (setq rcirc-time-format "%Y-%m-%d %H:%M ")

  ;; Change user info
  (setq rcirc-default-nick "bonz060")
  (setq rcirc-default-user-name "bonz060")
  (setq rcirc-default-full-name "bonz060")

  ;; Join these channels at startup.
  (setq rcirc-startup-channels-alist
	'(("\\.freenode\\.net$" "#emacs" "#nairobilug" "#lisp")))

  ;; Turn on spell checking.
  (add-hook 'rcirc-mode-hook (lambda ()
			       (flyspell-mode 1)))

  ;; Keep input line at bottom.
  (add-hook 'rcirc-mode-hook
	    (lambda ()
	      (set (make-local-variable 'scroll-conservatively)
		   8192)))

  (add-hook 'rcirc-mode-hook
	    (lambda ()
	      (rcirc-track-minor-mode 1)))
  )

;; Set typeface for rcirc buffers; this example uses variable-width Monospace size 10
;; (dolist (rcirc-face (remove-if-not
;;                      (lambda (elt) (equal (cadr elt) 'custom-face))
;;                      (get 'rcirc-faces 'custom-group)))
;;   (set-face-font (car rcirc-face) "Monospace-10"))

;; Don't print /away messages.
;; This does not require rcirc to be loaded already,
;; since rcirc doesn't define a 301 handler (yet).
(defun rcirc-handler-301 (process cmd sender args)
  "/away message handler.")

(provide 'setup-rcirc)
;;; setup-rcirc.el ends here
#+END_SRC

** setup-slime.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-slime.el
;;; setup-slime.el
;; Set your lisp system and, optionally, some contribs
;; (setq inferior-lisp-program "/usr/bin/sbcl")
(use-package slime :ensure
  :config
  (setq inferior-lisp-program "clisp")
  (setq slime-contribs '(slime-fancy))
  (slime-setup))

(provide 'setup-slime)

;;; setup-slime.el ends here
#+END_SRC

** setup-yasnippet.el
#+BEGIN_SRC emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/settings/setup-yasnippet.el
;;; setup-yasnippet.el

(use-package yasnippet :ensure
  :diminish yas-minor-mode
  :config
  (yas-global-mode 1)
  ;; respect the spacing in my snippet declarations
  (setq yas-indent-line 'fixed))

(use-package php-auto-yasnippets :ensure
  :config
  (defun bonz/php-mode-hook ()
    "My PHP-mode hook."
    (flycheck-mode t))
  :hook
  ((bonz/php-mode-hook . php-mode-hook)))

;; Nice “interface” to said program
(use-package yankpad :ensure
  ;; :if company-mode ;; load & initialise only if company-mode is defined
  :demand t
  :config
  (require 'company)
  (setq yankpad-file "~/.emacs.d/yankpad.org")
  (setq yankpad-category "Category: Default")
  ;; If you want to complete snippets using company-mode
  (add-to-list 'company-backends #'company-yankpad)
  ;; If you want to expand snippets with hippie-expand
  (add-to-list 'hippie-expand-try-functions-list #'yankpad-expand)
  ;; Load the snippet templates -- useful after yankpad is altered
  (add-hook 'after-init-hook 'yankpad-reload))

(use-package yasnippet-snippets :ensure)

(provide 'setup-yasnippet)
;;; setup-yasnippet.el ends here
#+END_SRC
* Email
** Initial setup

#+NAME: gnus
#+BEGIN_SRC elisp :tangle ~/.emacs.d/settings/setup-email.el
(use-package auth-source
  :ensure
  :config
  (setq auth-sources '("~/.authinfo.gpg"))
  (setq user-full-name "Bonface M. K.")
  (setq user-mail-address "bonfacemunyoki@gmail.com")

  (defun bonz/auth-get-field (host prop)
    "Find PROP in `auth-sources' for HOST entry."
    (let* ((source (auth-source-search :host host))
           (field (plist-get
                   (flatten-list source)
                   prop)))
      (if source
          field
        (user-error "No entry in auth sources")))))

(use-package mm-encode
  :config
  (setq mm-encrypt-option 'guided)
  (setq mm-sign-option 'guided))

(use-package mml-sec
  :config
  (setq mml-secure-openpgp-encrypt-to-self t)
  (setq mml-secure-openpgp-sign-with-sender t)
  (setq mml-secure-smime-encrypt-to-self t)
  (setq mml-secure-smime-sign-with-sender t))

(use-package epa-file
  :config
  (setq epa-file-cache-passphrase-for-symmetric-encryption nil))

(use-package message
  :config
  (setq message-default-charset 'utf-8)
  (add-to-list 'mm-body-charset-encoding-alist '(utf-8 . base64))
  :hook ((message-setup-hook . message-sort-headers)))

(use-package w3m :ensure)
(use-package notmuch :ensure)
(defun w3m-copy-url-at-point ()
    (interactive)
    (let ((url (w3m-anchor)))
      (if (w3m-url-valid url)
          (kill-new (w3m-anchor))
        (message "No URL at point!"))))

(add-hook 'w3m-mode-hook
            (lambda ()
              (local-set-key "\M-W" 'w3m-copy-url-at-point)))

(setq mm-text-html-renderer 'w3m) ; OPTIONAL  

(use-package gnus
  :ensure
  :config
  (defun my-gnus-group-list-subscribed-groups ()
    "List all subscribed groups with or without un-read messages"
    (interactive)
    (gnus-group-list-all-groups 7))
  (define-key gnus-group-mode-map
    ;; list all the subscribed groups even they contain zero un-read messages
    (kbd "o") 'my-gnus-group-list-subscribed-groups)

  (add-hook
   'gnus-summary-mode-hook
   (lambda ()
     (define-key gnus-summary-mode-map (kbd ";") 'ebdb-edit-field)))
  (add-hook 'message-mode-hook
            '(lambda ()
               (flyspell-mode t)
               (local-set-key (kbd "TAB") 'ebdb-complete-mail)))


  (setq gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]")
  (eval-after-load 'gnus-topic
    '(progn
       (setq gnus-message-archive-group '((format-time-string "sent.%Y")))
       (setq gnus-server-alist '(("archive" nnfolder "archive" (nnfolder-directory "~/Mail/archive")
                                  (nnfolder-active-file "~/Mail/archive/active")
                                  (nnfolder-get-new-mail nil)
                                  (nnfolder-inhibit-expiry t))))))
  ;; accounts
  (setq gnus-select-method
        '(nnimap "gmail"
                 (nnimap-address "imap.gmail.com")
                 (nnimap-server-port "imaps")
                 (nnimap-stream ssl)))
  (setq gnus-secondary-select-methods
        '((nntp "news.gwene.org")
          ))
  (setq nnir-method-default-engines
        '((nnmaildir . notmuch)))
    
  (setq gnus-gcc-mark-as-read t)
  (setq gnus-agent t)
  (setq gnus-novice-user t)
  ;; checking sources
  (setq gnus-check-new-newsgroups 'ask-server)
  (setq gnus-read-active-file 'some)
  ;; dribble
  (setq gnus-use-dribble-file t)
  (setq gnus-always-read-dribble-file t)
  ;; demon
  (gnus-demon-add-scanmail)
  (gnus-demon-add-handler 'gnus-demon-scan-news nil 60)
  :bind ("C-c m" . gnus))

(use-package nnmail
  :config
  (setq nnmail-expiry-wait 30))

(use-package gnus-agent
  :after gnus
  :config
  (setq gnus-agent-article-alist-save-format 1)  ; uncompressed
  (setq gnus-agent-cache t)
  (setq gnus-agent-confirmation-function 'y-or-n-p)
  (setq gnus-agent-consider-all-articles nil)
  (setq gnus-agent-directory "~/News/agent/")
  (setq gnus-agent-enable-expiration 'ENABLE)
  (setq gnus-agent-expire-all nil)
  (setq gnus-agent-expire-days 30)
  (setq gnus-agent-mark-unread-after-downloaded t)
  (setq gnus-agent-queue-mail t)        ; queue if unplugged
  (setq gnus-agent-synchronize-flags nil))

(use-package gnus-art
  :after gnus
  :demand
  :config
  (setq gnus-article-browse-delete-temp 'ask)
  (setq gnus-article-over-scroll nil)
  (setq gnus-article-show-cursor t)
  (setq gnus-article-sort-functions
        '((not gnus-article-sort-by-number)
          (not gnus-article-sort-by-date)))
  (setq gnus-article-truncate-lines nil)
  (setq gnus-html-frame-width 80)
  (setq gnus-html-image-automatic-caching t)
  (setq gnus-inhibit-images t)
  (setq gnus-max-image-proportion 0.7)
  (setq gnus-treat-display-smileys nil)
  (setq gnus-article-mode-line-format "%G %S %m")
  (setq gnus-visible-headers
        '("^From:" "^Subject:" "^To:" "^Cc:" "^Newsgroups:" "^Date:"
          "Followup-To:" "Reply-To:" "^Organization:" "^X-Newsreader:"
          "^X-Mailer:"))
  (setq gnus-sorted-header-list gnus-visible-headers)
  :hook (gnus-article-mode-hook . (lambda ()
                                    (setq-local fill-column 80)))
  :bind (:map gnus-article-mode-map
              ("i" . gnus-article-show-images)
              ("s" . gnus-mime-save-part)
              ("o" . gnus-mime-copy-part)))

(use-package gnus-async
  :after gnus
  :config
  (setq gnus-asynchronous t)
  (setq gnus-use-article-prefetch 15))

(use-package gnus-group
  :after gnus
  :demand
  :config
  (setq gnus-level-subscribed 6)
  (setq gnus-level-unsubscribed 7)
  (setq gnus-level-zombie 8)
  (setq gnus-activate-level 2)
  (setq gnus-list-groups-with-ticked-articles nil)
  (setq gnus-group-sort-function
        '((gnus-group-sort-by-unread)
          (gnus-group-sort-by-alphabet)
          (gnus-group-sort-by-rank)))
  (setq gnus-group-line-format "%M%p%P%5y:%B%(%g%)\n")
  (setq gnus-group-mode-line-format "%%b")
  :hook ((gnus-group-mode-hook . hl-line-mode)
         (gnus-select-group-hook . gnus-group-set-timestamp))
  :bind (:map gnus-group-mode-map
              ("M-n" . gnus-topic-goto-next-topic)
              ("M-p" . gnus-topic-goto-previous-topic)))

(use-package gnus-topic
  :after (gnus gnus-group)
  :config
  (setq gnus-topic-display-empty-topics t)
  :hook (gnus-group-mode-hook . gnus-topic-mode))

(use-package gnus-sum
  :after (gnus gnus-group)
  :demand
  :config
  (setq gnus-auto-select-first nil)
  (setq gnus-summary-ignore-duplicates t)
  (setq gnus-suppress-duplicates t)
  (setq gnus-save-duplicate-list t)
  (setq gnus-summary-goto-unread nil)
  (setq gnus-summary-make-false-root 'adopt)
  (setq gnus-summary-thread-gathering-function
        'gnus-gather-threads-by-subject)
  (setq gnus-summary-gather-subject-limit 'fuzzy)
  (setq gnus-thread-sort-functions
        '((not gnus-thread-sort-by-date)
          (not gnus-thread-sort-by-number)))
  (setq gnus-subthread-sort-functions
        'gnus-thread-sort-by-date)
  (setq gnus-thread-hide-subtree nil)
  (setq gnus-thread-ignore-subject nil)
  (setq gnus-user-date-format-alist
        '(((gnus-seconds-today) . "Today at %R")
          ((+ (* 60 60 24) (gnus-seconds-today)) . "Yesterday, %R")
          (t . "%Y-%m-%d %R")))

  ;; When the %f specifier in `gnus-summary-line-format' matches my
  ;; name, this will use the contents of the "To:" field, prefixed by
  ;; the string I specify.  Useful when checking your "Sent" summary.
  (setq gnus-ignored-from-addresses "Bonface M. K.")
  (setq gnus-summary-to-prefix "To: ")

  (setq gnus-summary-line-format "%U%R  %-16,16&user-date;  %4L:%-25,25f  %B%s\n")
  (setq gnus-summary-mode-line-format "%p")
  (setq gnus-sum-thread-tree-false-root "─┬> ")
  (setq gnus-sum-thread-tree-indent " ")
  (setq gnus-sum-thread-tree-single-indent "")
  (setq gnus-sum-thread-tree-leaf-with-other "├─> ")
  (setq gnus-sum-thread-tree-root "")
  (setq gnus-sum-thread-tree-single-leaf "└─> ")
  (setq gnus-sum-thread-tree-vertical "│")

  (defun bonz/gnus-summary-save-parts-all ()
    "Save relevant message MIME parts to a desired directory.
EXPERIMENTAL"
    (interactive)
    (let ((dir "~/Downloads/mail-attachments"))
      (if major-mode 'gnus-summary-mode
        (progn
          (unless (file-directory-p dir)
            (make-directory dir))
          (gnus-summary-save-parts "text/.*" dir nil t))
        (user-error "Not in a `gnus' summary buffer"))))

  :hook (gnus-summary-mode-hook . hl-line-mode)
  :bind (:map gnus-summary-mode-map
              ("X x" . bonz/gnus-summary-save-parts-all)
              ("<delete>" . gnus-summary-delete-article)
              ("n" . gnus-summary-next-article)
              ("p" . gnus-summary-prev-article)
              ("N" . gnus-summary-next-unread-article)
              ("P" . gnus-summary-prev-unread-article)
              ("M-n" . gnus-summary-next-thread)
              ("M-p" . gnus-summary-prev-thread)
              ("C-M-n" . gnus-summary-next-group)
              ("C-M-p" . gnus-summary-prev-group)
              ("C-M-^" . gnus-summary-refer-thread)))

(use-package gnus-srvr
  :after gnus
  :hook ((gnus-browse-mode-hook gnus-server-mode-hook) . hl-line-mode))

(use-package gnus-win
  :config
  (gnus-add-configuration
   '(article
     (horizontal 1.0
                 (vertical 40 (group 1.0))
                 (vertical 1.0
                           (summary 0.16 point)
                           (article 1.0)))))

  (gnus-add-configuration
   '(summary
     (horizontal 1.0
                 (vertical 40 (group 1.0))
                 (vertical 1.0 (summary 1.0 point))))))

(use-package gnus-dired
  :after (gnus dired)
  :hook (dired-mode-hook . gnus-dired-mode))

(use-package smtpmail
  :ensure
  :init
  (setq smtpmail-default-smtp-server "smtp.gmail.com")
  :config
  (setq message-send-mail-function 'smtpmail-send-it
        smtpmail-starttls-credentials '(("smtp.gmail.com" 587 nil nil))
        smtpmail-auth-credentials '(("smtp.gmail.com" 587
                                     "bonfacemunyoki@gmail.com" nil))
        smtpmail-default-smtp-server "smtp.gmail.com"
        smtpmail-smtp-server "smtp.gmail.com"
        smtpmail-smtp-service 587
        gnus-ignored-newsgroups "^to\\.\\|^[0-9. ]+\\( \\|$\\)\\|^[\"]\"[#'()]"))

;; (use-package smtpmail-async
;;   :after smtpmail
;;   :config
;;   (setq send-mail-function 'async-smtpmail-send-it)
;;   (setq message-send-mail-function 'async-smtpmail-send-it))

(use-package ebdb
  :ensure
  :pin gnu                              ; Prefer ELPA version
  :config
  (use-package ebdb-gnus)
  (use-package ebdb-message)
  (setq ebdb-default-window-size 0.2)
  (setq ebdb-mua-pop-up t)

  (defun bonz/ebdb-auto-update ()
    "Conditions for updating EBDB records."
    (if (ebdb-mua-message-header "Newsgroups")
        'query
      'existing))

  (setq ebdb-mua-auto-update-p #'bonz/ebdb-auto-update)
  (setq ebdb-mua-sender-update-p #'bonz/ebdb-auto-update)
  (setq ebdb-mua-reader-update-p #'bonz/ebdb-auto-update)
  (setq ebdb-add-aka t)
  (setq ebdb-add-name nil)
  (setq ebdb-add-mails 'query)
  (setq ebdb-complete-mail 'capf)
  (setq ebdb-mail-avoid-redundancy nil)
  (setq ebdb-complete-mail-allow-cycling 3))

(provide 'setup-email)
#+END_SRC
** Password                                                           :crypt:
-----BEGIN PGP MESSAGE-----

hQIMA7yEhhvnouawARAAjPS9kkpjdybCsFgoIRyRzsyvNW4oshLF6qC6IgPXyLRZ
hjYW5Qsf+ZYD+NcGhBMWLNpudaZmuzjX6/5HHTDVMfd9yVntnN5ZwnaLR7AZA4r6
glSQAj7aWI/sU0HNHQLiccw8yKuBytls0mGKRFxnr1lapug7jAb4BTYYCXV9xS4O
f43bNX/UWFHkU9QGmO0KGfQKOFYwJJL+rMSLkLqajIBhhOU5/SkgL3Y3CUzwJk//
1VE7jZapahbFAkkCc+Jf52Ver7ztSXCBvfOgll6Wp6vCKoRkhWZXFyDTrvxurUdV
zqceFXUwIyTXNWolofiaq4jtjdi6DBiAxGBeID6lwos8DloQsJ262eAYO3CWPXuT
uKjh/pNpnfzYGGkRjpoclo06iHBJjzgf1tts0aSC4ROQ4HZ31KHX/kSjjLDwm79a
G8HxFArOd1jiJJgqYYiancphGZQqN2Lqpd7owebpFhg241iPKgHcfNf5yID1pZJh
ALSMVO1sejoenLQt3M9BDrYgehu3Kl6LKxf1cXhx9oD3j9W41Uwq+uyXN1C1VN0F
1++araa9pNoF1I3MNdhIwiLA+Qcj0U0+2EOB24RA37BQMlRweYzfFLzFdPR3LsrH
fjD1VayRhVWHnHvEeVfv27AfjrZ6bmU6wL96Eu+4R/0CeQ2oxm8BXA0Zy5hhqTLS
wBYBn9ty1mMZLKV35CKIR70EF4iwPdw6aGL7ukGoEEVDmCgFwjZ10VUAcAx4geT9
V3jkU6F2o8AmwEFBHdk9VLv2kg4vlz6veyMHILF/5MGspLus2DO37mda/CSujU2p
BxABzjzrCzjIaB13IJI9V/GOirmWDMq6wSZ3BkvUGBSrL31aPBqYUxVZy9DDKb4W
+sODSUjpdiNG/xcjFzdQN/bYAJKUTvs0+BW6taka9wWxSUia4I0WYJ1rdgifjGtX
zU5v9uBkpXBn/apHFbMhkAAlvuA8YQ0/
=Drv/
-----END PGP MESSAGE-----

** mbysnc
#+BEGIN_SRC elisp :tangle ~/.mbsyncrc :noweb yes
IMAPAccount gmail
Host imap.gmail.com
User bonfacemunyoki@gmail.com
PassCmd "gpg2 -q --for-your-eyes-only --decrypt ~/.authinfo.gpg | awk -F ' ' '/gmail/ { print $6; exit; }'"
SSLType IMAPS

IMAPStore gmail-remote
Account gmail

MaildirStore gmail-local
Subfolders Verbatim
# The trailing "/" is important
Path ~/.mail/gmail/
Inbox ~/.mail/gmail/Inbox

Channel gmail
Master :gmail-remote:
Slave :gmail-local:
# Include everything
Patterns *

Create Both
# Expunge Both
SyncState *
#+END_SRC
* site-lisp
#+begin_src emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/site-lisp/frame-cmds.el
  ;;; frame-cmds.el --- Frame and window commands (interactive functions).
  ;;
  ;; Filename: frame-cmds.el
  ;; Description: Frame and window commands (interactive functions).
  ;; Author: Drew Adams
  ;; Maintainer: Drew Adams
  ;; Copyright (C) 1996-2011, Drew Adams, all rights reserved.
  ;; Created: Tue Mar  5 16:30:45 1996
  ;; Version: 21.0
  ;; Last-Updated: Mon Jul 25 10:56:57 2011 (-0700)
  ;;           By: dradams
  ;;     Update #: 2642
  ;; URL: http://www.emacswiki.org/cgi-bin/wiki/frame-cmds.el
  ;; Keywords: internal, extensions, mouse, frames, windows, convenience
  ;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x
  ;;
  ;; Features that might be required by this library:
  ;;
  ;;   `avoid', `frame-fns', `misc-fns', `strings', `thingatpt',
  ;;   `thingatpt+'.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Commentary:
  ;;
  ;;    Frame and window commands (interactive functions).
  ;;
  ;;
  ;;  Summary:
  ;;
  ;;    Load this library from your init file (~/.emacs or _emacs).
  ;;    Add the suggested key bindings (below) to  your init file.
  ;;    Use `M-up|down|left|right' to move frames around.
  ;;    Use `C-M-up|down|left|right' to resize frames.
  ;;    Use `C-M-z' or `C-x C-z' to iconify/hide all frames.
  ;;    Use `C-M-z' in a lone frame to restore all frames.
  ;;    Use `C-mouse-1' in the minibuffer to restore all frames.
  ;;    Use `C-mouse-1' in Dired to mark/unmark a file.
  ;;    Use `C-mouse-3' on the mode line to remove window from frame.
  ;;    Use `tile-frames-horizontally', `-vertically' to tile frames.
  ;;    Use `C-x o' to select `other-window' or `other-frame'.
  ;;
  ;;  Commands to incrementally resize frames are `enlarge-frame' and
  ;;  `enlarge-frame-horizontally'.  Sarir Khamsi
  ;;  [sarir.khamsi@raytheon.com] originally wrote `enlarge-frame',
  ;;  which he called `sk-grow-frame'.
  ;;
  ;;  Note on saving changes made with the commands defined here:
  ;;
  ;;    Some of the commands defined here change frame properties.
  ;;    You can save any changes you have made, by using Customize.
  ;;    To visit a Customize buffer of all unsaved changes you have
  ;;    made, use command `customize-customized'.
  ;;
  ;;    Frame parameter changes, such as background color, can be saved
  ;;    for future use by all frames or all frames of a certain
  ;;    kind.  For that, you must change the frame parameters of the
  ;;    correponding frame-alist variable.
  ;;
  ;;    There is no single variable for saving changes to parameters of
  ;;    the current frame.  Instead, there are several different
  ;;    frame-alist variables, which you can use to define different
  ;;    kinds of frames.  These include: `default-frame-alist',
  ;;    `initial-frame-alist', and `special-display-frame-alist'.  The
  ;;    complete list of such frame alist variables is available using
  ;;    function `frame-alist-var-names', defined here.
  ;;
  ;;    Example: Suppose you change the background color of a frame and
  ;;    want to make that the default background color for new frames in
  ;;    the future.  You will need to update the value of variable
  ;;    `default-frame-alist' to use the `background-color' parameter
  ;;    setting of the changed frame.
  ;;
  ;;    You can easily copy one or all parameter values from any given
  ;;    frame to any frame alist (such as `default-frame-alist'), by
  ;;    using the commands `set-frame-alist-parameter-from-frame' and
  ;;    `set-all-frame-alist-parameters-from-frame'.  Those commands are
  ;;    defined here.
  ;;
  ;;  NOTE: If you also use library `fit-frame.el', and you are on MS
  ;;  Windows, then load that library before `frame-cmds.el'.  The
  ;;  commands `maximize-frame' and `restore-frame' defined here are
  ;;  more general and non-Windows-specific than the commands of the
  ;;  same name defined in `fit-frame.el'.
  ;;
  ;;
  ;;  User options defined here:
  ;;
  ;;    `available-screen-pixel-bounds', `enlarge-font-tries',
  ;;    `frame-config-register', `frame-parameters-to-exclude',
  ;;    `move-frame-wrap-within-display-flag'
  ;;    `rename-frame-when-iconify-flag', `show-hide-show-function',
  ;;    `window-mgr-title-bar-pixel-height'.
  ;;
  ;;  Commands defined here:
  ;;
  ;;    `delete-1-window-frames-on', `delete/iconify-window',
  ;;    `delete/iconify-windows-on', `delete-other-frames',
  ;;    `delete-windows-for', `enlarge-font', `enlarge-frame',
  ;;    `enlarge-frame-horizontally', `hide-everything', `hide-frame',
  ;;    `iconify-everything', `iconify/map-frame',
  ;;    `jump-to-frame-config-register', `maximize-frame',
  ;;    `maximize-frame-horizontally', `maximize-frame-vertically',
  ;;    `mouse-iconify/map-frame', `mouse-remove-window',
  ;;    `mouse-show-hide-mark-unmark', `move-frame-down',
  ;;    `move-frame-left', `move-frame-right', `move-frame-up',
  ;;    `other-window-or-frame', `remove-window', `remove-windows-on',
  ;;    `rename-frame', `rename-non-minibuffer-frame', `restore-frame',
  ;;    `restore-frame-horizontally', `restore-frame-vertically',
  ;;    `save-frame-config',
  ;;    `set-all-frame-alist-parameters-from-frame',
  ;;    `set-frame-alist-parameter-from-frame', `show-*Help*-buffer',
  ;;    `show-a-frame-on', `show-buffer-menu', `show-frame',
  ;;    `show-hide', `shrink-frame', `shrink-frame-horizontally',
  ;;    `tell-customize-var-has-changed', `tile-frames',
  ;;    `tile-frames-horizontally', `tile-frames-vertically',
  ;;    `toggle-max-frame', `toggle-max-frame-horizontally',
  ;;    `toggle-max-frame-vertically'.
  ;;
  ;;  Non-interactive functions defined here:
  ;;
  ;;    `assq-delete-all' (Emacs 20), `available-screen-pixel-bounds',
  ;;    `available-screen-pixel-height', `available-screen-pixel-width',
  ;;    `effective-screen-pixel-bounds', `enlarged-font-name',
  ;;    `frame-alist-var-names', `frame-iconified-p',
  ;;    `frame-parameter-names', `new-frame-position',
  ;;    `read-args-for-tile-frames', `read-buffer-for-delete-windows',
  ;;    `smart-tool-bar-pixel-height'.
  ;;
  ;;
  ;;
  ;;  ***** NOTE: The following EMACS PRIMITIVES have been REDEFINED HERE:
  ;;
  ;;  `delete-window' - If only one window in frame, `delete-frame'.
  ;;  `delete-windows-on' -
  ;;     1) Reads buffer differently.  Only buffers showing windows are candidates.
  ;;     2) Calls `delete-window', so this also deletes frames where
  ;;        window showing the BUFFER is the only window.
  ;;        (That's true also for vanilla Emacs 23+, but not before.)
  ;;
  ;;
  ;;  Suggested key bindings:
  ;;
  ;;   (global-set-key [(meta up)] 'move-frame-up)
  ;;   (global-set-key [(meta down)] 'move-frame-down)
  ;;   (global-set-key [(meta left)] 'move-frame-left)
  ;;   (global-set-key [(meta right)] 'move-frame-right)
  ;;   (global-set-key [(control meta down)] 'enlarge-frame)
  ;;   (global-set-key [(control meta right)] 'enlarge-frame-horizontally)
  ;;   (global-set-key [(control meta up)] 'shrink-frame)
  ;;   (global-set-key [(control meta left)] 'shrink-frame-horizontally)
  ;;   (global-set-key [(control ?x) (control ?z)] 'iconify-everything)
  ;;   (global-set-key [vertical-line S-down-mouse-1] 'iconify-everything)
  ;;   (global-set-key [(control ?z)] 'iconify/map-frame)
  ;;   (global-set-key [mode-line mouse-3] 'mouse-iconify/map-frame)
  ;;   (global-set-key [mode-line C-mouse-3] 'mouse-remove-window)
  ;;   (global-set-key [(control meta ?z)] 'show-hide)
  ;;   (global-set-key [vertical-line C-down-mouse-1] 'show-hide)
  ;;   (global-set-key [C-down-mouse-1] 'mouse-show-hide-mark-unmark)
  ;;   (substitute-key-definition 'delete-window 'remove-window global-map)
  ;;   (define-key ctl-x-map "o" 'other-window-or-frame)
  ;;   (define-key ctl-x-4-map "1" 'delete-other-frames)
  ;;   (define-key ctl-x-5-map "h" 'show-*Help*-buffer)
  ;;   (substitute-key-definition 'delete-window 'delete-windows-for global-map)
  ;;   (define-key global-map "\C-xt." 'save-frame-config)
  ;;   (define-key ctl-x-map "o" 'other-window-or-frame)
  ;;
  ;;   (defalias 'doremi-prefix (make-sparse-keymap))
  ;;   (defvar doremi-map (symbol-function 'doremi-prefix) "Keymap for Do Re Mi commands.")
  ;;   (define-key global-map "\C-xt" 'doremi-prefix)
  ;;   (define-key doremi-map "." 'save-frame-config)
  ;;
  ;;  Customize the menu.  Uncomment this to try it out.
  ;;
  ;;   (defvar menu-bar-frames-menu (make-sparse-keymap "Frames"))
  ;;   (define-key global-map [menu-bar frames]
  ;;     (cons "Frames" menu-bar-frames-menu)))
  ;;   (define-key menu-bar-frames-menu [set-all-params-from-frame]
  ;;     '(menu-item "Set All Frame Parameters from Frame" set-all-frame-alist-parameters-from-frame
  ;;       :help "Set frame parameters of a frame to their current values in frame"))
  ;;   (define-key menu-bar-frames-menu [set-params-from-frame]
  ;;     '(menu-item "Set Frame Parameter from Frame..." set-frame-alist-parameter-from-frame
  ;;       :help "Set parameter of a frame alist to its current value in frame"))
  ;;   (define-key menu-bar-frames-menu [separator-frame-1] '("--"))
  ;;   (define-key menu-bar-frames-menu [tile-frames-vertically]
  ;;     '(menu-item "Tile Frames Vertically..." tile-frames-vertically
  ;;       :help "Tile all visible frames vertically"))
  ;;   (define-key menu-bar-frames-menu [tile-frames-horizontally]
  ;;     '(menu-item "Tile Frames Horizontally..." tile-frames-horizontally
  ;;       :help "Tile all visible frames horizontally"))
  ;;   (define-key menu-bar-frames-menu [separator-frame-2] '("--"))
  ;;   (define-key menu-bar-frames-menu [toggle-max-frame-vertically]
  ;;     '(menu-item "Toggle Max Frame Vertically" toggle-max-frame-vertically
  ;;       :help "Maximize or restore the selected frame vertically"
  ;;       :enable (frame-parameter nil 'restore-height)))
  ;;   (define-key menu-bar-frames-menu [toggle-max-frame-horizontally]
  ;;     '(menu-item "Toggle Max Frame Horizontally" toggle-max-frame-horizontally
  ;;       :help "Maximize or restore the selected frame horizontally"
  ;;       :enable (frame-parameter nil 'restore-width)))
  ;;   (define-key menu-bar-frames-menu [toggle-max-frame]
  ;;     '(menu-item "Toggle Max Frame" toggle-max-frame
  ;;       :help "Maximize or restore the selected frame (in both directions)"
  ;;       :enable (or (frame-parameter nil 'restore-width) (frame-parameter nil 'restore-height))))
  ;;   (define-key menu-bar-frames-menu [maximize-frame-vertically]
  ;;     '(menu-item "Maximize Frame Vertically" maximize-frame-vertically
  ;;       :help "Maximize the selected frame vertically"))
  ;;   (define-key menu-bar-frames-menu [maximize-frame-horizontally]
  ;;     '(menu-item "Maximize Frame Horizontally" maximize-frame-horizontally
  ;;       :help "Maximize the selected frame horizontally"))
  ;;   (define-key menu-bar-frames-menu [maximize-frame]
  ;;     '(menu-item "Maximize Frame" maximize-frame
  ;;       :help "Maximize the selected frame (in both directions)"))
  ;;   (define-key menu-bar-frames-menu [separator-frame-3] '("--"))
  ;;   (define-key menu-bar-frames-menu [iconify-everything]
  ;;     '(menu-item "Iconify All Frames" iconify-everything
  ;;       :help "Iconify all frames of session at once"))
  ;;   (define-key menu-bar-frames-menu [show-hide]
  ;;     '(menu-item "Hide Frames / Show Buffers" show-hide
  ;;       :help "Show, if only one frame visible; else hide.")))
  ;;
  ;;   (defvar menu-bar-doremi-menu (make-sparse-keymap "Do Re Mi"))
  ;;   (define-key global-map [menu-bar doremi]
  ;;     (cons "Do Re Mi" menu-bar-doremi-menu))
  ;;   (define-key menu-bar-doremi-menu [doremi-font+]
  ;;     '("Save Frame Configuration" . save-frame-config))
  ;;
  ;;  See also these files for other frame commands:
  ;;
  ;;     `autofit-frame.el' - Automatically fit each frame to its
  ;;                          selected window.  Uses `fit-frame.el'.
  ;;
  ;;     `fit-frame.el'     - 1) Fit a frame to its selected window.
  ;;                          2) Incrementally resize a frame.
  ;;
  ;;     `doremi-frm.el'    - Incrementally adjust frame properties
  ;;                          using arrow keys and/or mouse wheel.
  ;;
  ;;     `thumb-frm.el'     - Shrink frames to a thumbnail size and
  ;;                          restore them again.
  ;;
  ;;     `zoom-frm.el'      - Zoom a frame, so that its font becomes
  ;;                          larger or smaller.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Change log:
  ;;
  ;; 2011/07/25 dadams
  ;;     save-frame-config: Use fboundp, not featurep.
  ;; 2011/01/04 dadams
  ;;     Removed autoload cookie from non-interactive function.
  ;; 2010/10/19 dadams
  ;;     enlarge-font: Only do frame-update-faces if Emacs 20 (obsolete in 21).
  ;; 2010/06/04 dadams
  ;;     Added: (toggle-max|restore)-frame(-horizontally|-vertically).  Thx to Uday Reddy for suggestion.
  ;;     Renamed max-frame to maximize-frame.
  ;;     maximize-frame: Save original location & position params for later restoration.
  ;; 2010/05/25 dadams
  ;;     Added: max-frame, maximize-frame-horizontally, maximize-frame-vertically.
  ;; 2009/10/02 dadams
  ;;     delete-windows-on: Return nil.  Make BUFFER optional: default is current buffer.
  ;; 2009/08/03 dadams
  ;;     delete-window: Wrap with save-current-buffer.  Thx to Larry Denenberg.
  ;; 2009/05/17 dadams
  ;;     Updated to reflect thumb-frm.el name changes.
  ;; 2009/01/30 dadams
  ;;     enlarge-font, enlarged-font-name, enlarge-font-tries:
  ;;       Removed temporary workaround - Emacs 23 bug #119 was finally fixed.
  ;; 2009/01/01 dadams
  ;;     Removed compile-time require of doremi-frm.el to avoid infinite recursion.
  ;; 2008/12/13 dadams
  ;;     enlarge-font: Redefined for Emacs 23 - just use :height face attribute.
  ;;     enlarge-font-tries, enlarged-font-name: Not used for Emacs 23.
  ;; 2008/10/31 dadams
  ;;     Updated frame-parameter-names for Emacs 23.
  ;; 2008/07/29 dadams
  ;;     Option available-screen-pixel-bounds: Use nil as default value.
  ;;     available-screen-pixel-bounds: Redefined as the code that defined the option's default value.
  ;;     Added: effective-screen-pixel-bounds - code taken from old available-screen-pixel-bounds,
  ;;            but also convert frame geom value to numeric.
  ;;     Everywhere:
  ;;       Use effective-screen-pixel-bounds in place of available-screen-pixel-bounds function.
  ;;       Use available-screen-pixel-bounds function instead of option.
  ;;     available-screen-pixel-(width|height): Added optional INCLUDE-MINI-P arg.
  ;;     new-frame-position: Call available-screen-pixel-(width|height) with arg.
  ;;     save-frame-config: push-current-frame-config -> doremi-push-current-frame-config.
  ;;     Soft-require doremi-frm.el when byte-compile.
  ;; 2008/06/02 dadams
  ;;     Added: available-screen-pixel-bounds (option and function).
  ;;     tile-frames, available-screen-pixel-(width|height):
  ;;       Redefined to use available-screen-pixel-bounds.  Thx to Nathaniel Cunningham for input.
  ;; 2008/05/29 dadams
  ;;     Fixes for Mac by Nathaniel Cunningham and David Reitter:
  ;;       window-mgr-title-bar-pixel-height, tile-frames, smart-tool-bar-pixel-height (added).
  ;; 2007/12/27 dadams
  ;;      tile-frames: Restored border calculation, but using only external border.
  ;;      Renamed window-mgr-*-width to window-mgr-*-height and changed default value from 32 to 27.
  ;; 2007/12/20 dadams
  ;;      Added: frame-extra-pixels(width|height).  Use in tile-frames.  Thx to David Reitter.
  ;;      frame-horizontal-extra-pixels: Changed default value from 30 to 32.
  ;; 2007/10/11 dadams
  ;;      Added: assq-delete-all (for Emacs 20).
  ;; 2007/09/02 dadams
  ;;      Added: available-screen-pixel-(width|height).  Use in tile-frames, new-frame-position.
  ;; 2007/06/12 dadams
  ;;      tile-frames: Corrected use of fboundp for thumbnail-frame-p.
  ;; 2007/05/27 dadams
  ;;      enlarged-font-name:
  ;;        Do nothing if null assq of ascii.  Not sure what this means, but gets around Emacs 23 bug.
  ;; 2006/08/22 dadams
  ;;      Added: delete-windows-for, read-buffer-for-delete-windows.
  ;;      delete-windows-on: Use read-buffer-for-delete-windows.
  ;;      Removed old-delete-windows-on (not used).
  ;; 2006/05/30 dadams
  ;;      delete-windows-on: Return nil if buffer arg is nil. Thanks to Slawomir Nowaczyk.
  ;; 2006/01/07 dadams
  ;;      Added :link for sending bug report.
  ;; 2006/01/06 dadams
  ;;      Renamed group.  Added :link.
  ;; 2006/01/04 dadams
  ;;     Added: other-window-or-frame.
  ;; 2005/12/29 dadams
  ;;     mouse-show-hide-mark-unmark: dired-mouse-mark/unmark -> diredp-mouse-mark/unmark.
  ;; 2005/12/13 dadams
  ;;     Added: delete-other-frames.
  ;; 2005/11/18 dadams
  ;;     enlarge-font: Try to increment or decrment further, testing for an existing font.
  ;;     Added: enlarge-font-tries, enlarged-font-name.
  ;; 2005/10/03 dadams
  ;;     Removed require of icomplete+.el (no longer redefines read-from-minibuffer).
  ;; 2005/07/03 dadams
  ;;     Renamed: args-for-tile-frames to read-args-for-tile-frames.
  ;; 2005/06/19 dadams
  ;;     tile-frames: Don't tile thumbnail frames.
  ;; 2005/05/29 dadams
  ;;     Moved here from frame+.el and fit-frame.el: enlarge-frame*, shrink-frame*.
  ;;     Added: move-frame-up|down|left|right, move-frame-wrap-within-display-flag,
  ;;            new-frame-position.
  ;; 2005/05/28 dadams
  ;;     show-a-frame-on: Use another-buffer as default for read-buffer, if available.
  ;; 2005/05/15 dadams
  ;;     Renamed: minibuffer-frame to 1on1-minibuffer-frame.
  ;; 2005/05/10 dadams
  ;;     remove-window: Removed definition; just defalias it to delete-window.
  ;;     delete-window: (one-window-p) -> (one-window-p t).
  ;;     set-frame-alist-parameter-from-frame: No longer use destructive fns.
  ;; 2005/01/19 dadams
  ;;     set-all-frame-alist-parameters-from-frame:
  ;;            Added really-all-p and use frame-parameters-to-exclude.
  ;;     Added: frame-parameters-to-exclude, tell-customize-var-has-changed.
  ;; 2005/01/18 dadams
  ;;     Added: set-all-frame-alist-parameters-from-frame, set-frame-alist-parameter-from-frame,
  ;;            frame-alist-var-names, frame-parameter-names.
  ;;     Added Note on saving changes.
  ;; 2005/01/08 dadams
  ;;     Moved enlarge-font here from doremi-frm.el, where it was called doremi-grow-font.
  ;; 2005/01/04 dadams
  ;;     Added rename-frame-when-iconify-flag.
  ;;       Use it in iconify-everything, (mouse-)iconify/map-frame.
  ;;     Added (defgroup frame-cmds).
  ;; 2004/12/23 dadams
  ;;     frame-config-register, show-hide-show-function, window-mgr-title-bar-pixel-width:
  ;;         Changed defvar to defcustom.
  ;; 2004/12/21 dadams
  ;;     hide-everything, iconify-everything: bind thumbify-instead-of-iconify-flag to nil.
  ;; 2004/12/10 dadams
  ;;     tile-frames: Change 15 to (frame-char-height fr) for scroll-bar-width.
  ;;     tile-frames-*: Corrected doc strings for non-interactive case.
  ;; 2004/12/09 dadams
  ;;     Changed compile-time require of strings to a soft require.
  ;; 2004/10/11 dadams
  ;;     args-for-tile-frames: Fixed bug when non-existant frame in name history.
  ;;     tile-frames: show-frame at end (for case where use prefix arg)
  ;; 2004/09/11 dadams
  ;;     Moved to doremi-frm.el: frame-config-ring*, frame-config-wo-parameters,
  ;;                             push-frame-config.
  ;; 2004/09/07 dadams
  ;;     Added: jump-to-frame-config-register, push-frame-config, save-frame-config.
  ;; 2004/09/01 dadams
  ;;     Added: frame-config-register, show-hide-show-function,
  ;;            jump-to-frame-config-register.
  ;;     Rewrote to record frame config: iconify-everything, hide-everything.
  ;;     Rewrote to use show-hide-show-function: show-hide.
  ;; 2004/03/22 dadams
  ;;     Added: tile-frames, tile-frames-vertically, args-for-tile-frames.
  ;;     Rewrote tile-frames-horizontally to use tile-frames.
  ;; 2004/03/19 dadams
  ;;     Added tile-frames-horizontally.
  ;; 2000/11/27 dadams
  ;;     hide-frame: fixed bug: Added get-a-frame for frame name read.
  ;; 2000/09/27 dadams
  ;;     1. Added: frame-iconified-p.
  ;;     2. remove-window: only make-frame-invisible if not iconified (HACK).
  ;; 1999/10/05 dadams
  ;;     rename-frame: fixed bug if only 1 frame and old-name was a frame.
  ;; 1999/08/25 dadams
  ;;     Added: hide-everything, show-buffer-menu, show-hide.
  ;; 1999/03/17 dadams
  ;;     delete-1-window-frames-on: ensure a buffer object (not a name).
  ;; 1996/04/26 dadams
  ;;     delete/iconify-windows-on, show-a-frame-on: Do nothing if null buffer.
  ;; 1996/03/12 dadams
  ;;     delete/iconify-window: Unless one-window-p, do old-delete-window outside of
  ;;                            save-window-excursion.
  ;; 1996/03/08 dadams
  ;;     1. delete-windows-on: a. Fixed incorrect interactive spec (bad paren).
  ;;                           b. Second arg FRAME also provided interactively now.
  ;;     2. Added: delete/iconify-window, delete/iconify-windows-on.
  ;; 1996/02/27 dadams
  ;;     show-frame: Call make-frame-visible.
  ;; 1996/02/09 dadams
  ;;     Added show-*Help*-buffer.
  ;; 1996/01/30 dadams
  ;;     1. show-frame: Don't make-frame-visible.  Done by raise-frame anyway.
  ;;     2. Added show-a-frame-on.
  ;; 1996/01/09 dadams
  ;;     Added delete-windows-on and made it interactive.
  ;; 1996/01/08 dadams
  ;;     Added rename-non-minibuffer-frame.  Use in iconify-everything,
  ;;           iconify/map-frame, mouse-iconify/map-frame.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 2, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program; see the file COPYING.  If not, write to
  ;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  ;; Floor, Boston, MA 02110-1301, USA.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Code:

  (eval-when-compile (require 'cl-lib)) ;; butlast, case, incf, set-difference
                                    ;; (plus, for Emacs 20: dolist and, for Emacs <20: when, unless)
  (require 'frame-fns) ;; frame-geom-value-numeric, frames-on, get-frame-name, get-a-frame, read-frame
  (require 'strings nil t) ;; (no error if not found) read-buffer
  (require 'misc-fns nil t) ;; (no error if not found) another-buffer

  ;; Don't require even to byte-compile, because doremi-frm.el soft-requires frame-cmds.el
  ;; (eval-when-compile (require 'doremi-frm nil t)) ;; (no error if not found)
  ;;                                                 ;; doremi-push-current-frame-config

  ;; Not required here, because this library requires `frame-cmds.el': `thumb-frm.el'.
  ;; However, `frame-cmds.el' soft-uses `thumfr-thumbnail-frame-p', which is defined
  ;; in `thumb-frm.el'.

  ;; Quiet byte-compiler.
  (defvar mac-tool-bar-display-mode)

  ;;;;;;;;;;;;;;;;;;;;;;;




  ;;; USER OPTIONS (VARIABLES) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (defgroup Frame-Commands nil
    "Miscellaneous frame and window commands."
    :group 'frames
    :link `(url-link :tag "Send Bug Report"
            ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
  frame-cmds.el bug: \
  &body=Describe bug here, starting with `emacs -q'.  \
  Don't forget to mention your Emacs and library versions."))
    :link '(url-link :tag "Other Libraries by Drew"
            "http://www.emacswiki.org/cgi-bin/wiki/DrewsElispLibraries")
    :link '(url-link :tag "Download"
            "http://www.emacswiki.org/cgi-bin/wiki/frame-cmds.el")
    :link '(url-link :tag "Description - `delete-window'"
            "http://www.emacswiki.org/cgi-bin/wiki/FrameModes")
    :link '(url-link :tag "Description - Frame Renaming"
            "http://www.emacswiki.org/cgi-bin/wiki/FrameTitle")
    :link '(url-link :tag "Description - Frame Resizing"
            "http://www.emacswiki.org/cgi-bin/wiki/Shrink-Wrapping_Frames")
    :link '(url-link :tag "Description - Frame Customization"
            "http://www.emacswiki.org/cgi-bin/wiki/CustomizingAndSaving")
    :link '(url-link :tag "Description - Frame Tiling"
            "http://www.emacswiki.org/cgi-bin/wiki/Frame_Tiling_Commands")
    :link '(url-link :tag "Description - General"
            "http://www.emacswiki.org/cgi-bin/wiki/FrameModes")
    :link '(emacs-commentary-link :tag "Commentary" "frame-cmds")
    )

  (defcustom rename-frame-when-iconify-flag t
    "*Non-nil means frames are renamed when iconified.
  The new name is the name of the current buffer."
    :type 'boolean :group 'Frame-Commands)

  (defcustom frame-config-register ?\C-l  ; Control-L is the name of the register.
    "*Character naming register for saving/restoring frame configuration."
    :type 'character :group 'Frame-Commands)

  (defcustom show-hide-show-function 'jump-to-frame-config-register
    "*Function to show stuff that is hidden or iconified by `show-hide'.
  Candidates include `jump-to-frame-config-register' and `show-buffer-menu'."
    :type '(choice (const :tag "Restore frame configuration" jump-to-frame-config-register)
                   (function :tag "Another function"))
    :group 'Frame-Commands)

  (defcustom window-mgr-title-bar-pixel-height (if (eq window-system 'mac) 22 27)
    "*Height of frame title bar provided by the window manager, in pixels.
  You might alternatively call this constant the title-bar \"width\" or
  \"thickness\".  There is no way for Emacs to determine this, so you
  must set it."
    :type 'integer :group 'Frame-Commands)

  (defcustom enlarge-font-tries 100
    "*Number of times to try to change font-size, when looking for a font.
  The font-size portion of a font name is incremented or decremented at
  most this many times, before giving up and raising an error."
    :type 'integer :group 'Frame-Commands)

  (defcustom frame-parameters-to-exclude '((window-id) (buffer-list) (name) (title) (icon-name))
    "*Parameters to exclude in `set-all-frame-alist-parameters-from-frame'.
  An alist of the same form as that returned by `frame-parameters'.
  The cdr of each alist element is ignored.
  These frame parameters are not copied to the target alist."
    :type '(repeat (cons symbol sexp)) :group 'Frame-Commands)

  (defcustom move-frame-wrap-within-display-flag t
    "*Non-nil means wrap frame movements within the display.
  Commands `move-frame-up', `move-frame-down', `move-frame-left', and
  `move-frame-right' then move the frame back onto the display when it
  moves off of it.
  If nil, you can move the frame as far off the display as you like."
    :type 'boolean :group 'Frame-Commands)

  (defcustom available-screen-pixel-bounds nil
    "*Upper left and lower right of available screen space for tiling frames.
  Integer list: (x0 y0 x1 y1), where (x0, y0) is the upper left position
  and (x1, y1) is the lower right position.  Coordinates are in pixels,
  measured from the screen absolute origin, (0, 0), at the upper left.
  If this is nil, then the available space is calculated.  That should
  give good results in most cases."
    :type '(list
            (integer :tag "X0 (upper left) - pixels from screen left")
            (integer :tag "Y0 (upper left) - pixels from screen top")
            (integer :tag "X1 (lower right) - pixels from screen left" )
            (integer :tag "Y1 (lower right) - pixels from screen top"))
    :group 'Frame-Commands)



  ;;; FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;


  ;;;###autoload
  (defun save-frame-config ()
    "Save current frame configuration.
  You can restore it with \\[jump-to-frame-config-register]."
    (interactive)
    (frame-configuration-to-register frame-config-register)
    (when (fboundp 'doremi-push-current-frame-config) ; In `doremi-frm.el'.
      (doremi-push-current-frame-config))
    (message
     (substitute-command-keys
      (if (fboundp 'doremi-frame-configs) ; In `doremi-frm.el'.
          (format "Use `\\[jump-to-frame-config-register]' (`C-x r j %c') or \
  `\\[doremi-frame-configs]' to restore frames as before (undo)." frame-config-register)
        "Use `\\[jump-to-frame-config-register]' to restore frames as before (undo)."))))

  ;;;###autoload
  (defun jump-to-frame-config-register ()
    "Restore frame configuration saved in `frame-config-register'."
    (interactive)
    (jump-to-register frame-config-register))

  ;;;###autoload
  (defun iconify-everything ()
    "Iconify all frames of session at once.
  Remembers frame configuration in register `C-l' (Control-L).
  To restore this frame configuration, use `\\[jump-to-register] C-l'."
    (interactive)
    (frame-configuration-to-register frame-config-register)
    (let ((thumfr-thumbify-dont-iconify-flag  nil)) ; Defined in `thumb-frm.el'.
      (dolist (frame  (visible-frame-list))
        (when rename-frame-when-iconify-flag (rename-non-minibuffer-frame frame))
        (iconify-frame frame))))

  ;;;###autoload
  (defun hide-everything ()
    "Hide all frames of session at once.
  Iconify minibuffer frame; make all others invisible.
  Remembers frame configuration in register `C-l' (Control-L).
  To restore this frame configuration, use `\\[jump-to-register] C-l'."
    (interactive)
    (frame-configuration-to-register frame-config-register)
    (let ((minibuf-frame-name
           (and (boundp '1on1-minibuffer-frame)
                (cdr (assq 'name (frame-parameters 1on1-minibuffer-frame)))))
          (thumfr-thumbify-dont-iconify-flag  nil)) ; Defined in `thumb-frm.el'.
      (dolist (frame  (frame-list))
        (if (eq minibuf-frame-name (cdr (assq 'name (frame-parameters frame))))
            (iconify-frame frame)         ; minibuffer frame
          (make-frame-invisible frame t))))) ; other frames

  ;;;###autoload
  (defun show-hide ()
    "1 frame visible: `show-hide-show-function'; else: `hide-everything'.
  This acts as a toggle between showing all frames and showing only an
  iconified minibuffer frame."
    (interactive)
    (if (< (length (visible-frame-list)) 2)
        (funcall show-hide-show-function)
      (hide-everything)))

  ;;;###autoload
  (defun show-buffer-menu ()
    "Call `buffer-menu' after making all frames visible.
  Useful after using `hide-everything' because of a Windows bug that
  doesn't let you display frames that have been made visible after
  being made invisible."
    (interactive)
    (let ((minibuf-frame-name
           (and (boundp '1on1-minibuffer-frame)
                (cdr (assq 'name (frame-parameters 1on1-minibuffer-frame))))))
      (dolist (frame (frame-list))
        (if (eq minibuf-frame-name
                (cdr (assq 'name (frame-parameters frame))))
            (make-frame-visible frame)    ; minibuffer frame
          (iconify-frame frame)))         ; other frames
      (buffer-menu)))

  ;;;###autoload
  (defun mouse-show-hide-mark-unmark (event)
    "In minibuffer: `show-hide'.  In dired: mark/unmark; else: buffer menu."
    (interactive "e")
    (if (window-minibuffer-p (posn-window (event-start event)))
        (show-hide)
      (or (and (memq major-mode '(dired-mode vc-dired-mode))
               (fboundp 'diredp-mouse-mark/unmark)
               (diredp-mouse-mark/unmark event)) ; Return nil if not on a file or dir.
          (mouse-buffer-menu event))))

  ;;;###autoload
  (defun iconify/map-frame (&optional iconify-all)
    "Iconify selected frame if now mapped.  Map it if now iconified.
  With non-nil prefix arg ICONIFY-ALL, iconify all visible frames."
    (interactive "P")
    (if iconify-all
        (iconify-everything)
      (when rename-frame-when-iconify-flag (rename-non-minibuffer-frame))
      (iconify-or-deiconify-frame)))

  ;;;###autoload
  (defun mouse-iconify/map-frame (event)
    "Iconify frame clicked on, if now mapped.  Map it if now iconified."
    (interactive "e")
    (select-window (posn-window (event-start event)))
    (when rename-frame-when-iconify-flag (rename-non-minibuffer-frame))
    (iconify-or-deiconify-frame))


  (or (fboundp 'old-delete-window)
      (fset 'old-delete-window (symbol-function 'delete-window)))


  ;; REPLACES ORIGINAL (built-in):
  ;; If WINDOW is the only one in its frame, `delete-frame'.
  ;;;###autoload
  (defun delete-window (&optional window)
    "Remove WINDOW from the display.  Default is `selected-window'.
  If WINDOW is the only one in its frame, then `delete-frame' too."
    (interactive)
    (save-current-buffer
      (setq window (or window (selected-window)))
      (select-window window)
      (if (one-window-p t) (delete-frame) (old-delete-window (selected-window)))))

  ;;;###autoload
  (defun delete-windows-for (&optional buffer)
    "`delete-window' or prompt for buffer and delete its windows.
  With no prefix arg, delete the selected window.
  With a prefix arg, prompt for a buffer and delete all windows, on any
    frame, that show that buffer."
    (interactive (list (and current-prefix-arg (read-buffer-for-delete-windows))))
    (if buffer (delete-windows-on buffer) (delete-window)))


  ;; REPLACES ORIGINAL (built-in):
  ;; 1) Use `read-buffer' in interactive spec.
  ;; 2) Do not raise an error if BUFFER is a string that does not name a buffer.
  ;; 3) Call `delete-window', so if you use my `delete-window' then this also deletes
  ;;    frames where window showing the BUFFER is the only window.
  ;;;###autoload
  (defun delete-windows-on (&optional buffer frame)
    "Delete windows showing BUFFER.
  Optional arg BUFFER defaults to the current buffer.
  Optional second arg FRAME controls which frames are considered.
    If nil or omitted, delete all windows showing BUFFER in any frame.
    If t, delete only windows showing BUFFER in the selected frame.
    If `visible', delete all windows showing BUFFER in any visible frame.
    If a frame, delete only windows showing BUFFER in that frame.
  Interactively, FRAME depends on the prefix arg, as follows:
    Without a prefix arg (prefix = nil), FRAME is nil (all frames).
    With prefix arg >= 0, FRAME is t (this frame only).
    With prefix arg < 0,  FRAME is `visible' (all visible frames)."
    (interactive
     (list (read-buffer-for-delete-windows)
           (and current-prefix-arg
                (or (natnump (prefix-numeric-value current-prefix-arg))
                    'visible))))
    (unless buffer (setq buffer  (current-buffer))) ; Like Emacs 23+ - unlike Emacs 21-22.

    ;; `get-buffer-window' interprets FRAME oppositely for t and nil, so switch.
    (setq frame (if (eq t frame) nil (if (eq nil frame) t frame)))
    (let (win)
      ;; Vanilla Emacs version raises an error if BUFFER is a string that does not name a buffer.
      ;; We do not raise an error - we do nothing.
      (and (get-buffer buffer)
           (while (setq win (get-buffer-window buffer frame))
             (delete-window win))
           nil)))                         ; Return nil always, like vanilla Emacs.

  (defun read-buffer-for-delete-windows ()
    "Read buffer name for delete-windows commands.
  Only displayed buffers are completion candidates."
    (completing-read "Delete windows on buffer: "
                     (let ((all-bufs   (buffer-list))
                           (cand-bufs  ()))
                       (dolist (buf  all-bufs)
                         (when (get-buffer-window buf t)
                           (push (list (buffer-name buf)) cand-bufs)))
                       cand-bufs)
                     nil t nil 'minibuffer-history (buffer-name (current-buffer)) t))

  (defsubst frame-iconified-p (frame)
    "Return non-nil if FRAME is `frame-live-p' and `frame-visible-p'."
    (and (frame-live-p frame) (eq (frame-visible-p frame) 'icon)))

  ;; (defun remove-window (&optional window)
  ;;   "Remove WINDOW from the display.  Default is `selected-window'.
  ;; If WINDOW is the only one in its frame, then:
  ;;    If WINDOW is dedicated to its buffer, then make its frame invisible.
  ;;    Otherwise, delete its frame (as well as the window)."
  ;;   (interactive)
  ;;   (setq window (or window (selected-window)))
  ;;   (select-window window)
  ;;   (if (and (window-dedicated-p (selected-window))
  ;;            (one-window-p t))
  ;;       (let ((fr (selected-frame)))
  ;;         ;; HACK because of Emacs bug: `raise-frame' won't raise a frame
  ;;         ;; that was first iconified and then made invisible.
  ;;         ;; So, here we don't make an iconified frame invisible.
  ;;         (unless (frame-iconified-p fr)
  ;;           (make-frame-invisible fr)))
  ;;     (delete-window)))

  ;; REMOVED old definition, above, because of problems with invisible
  ;; *Completions* frame when use completion window with subsequent args
  ;; to a command.  Just use `delete-window' now, which deletes frame if
  ;; `one-window-p'.  Use a `defalias' because its easier than replacing
  ;; all my calls to `remove-window' with `delete-window'.
  ;;
  ;;;###autoload
  (defalias 'remove-window 'delete-window)

  ;;;###autoload
  (defun remove-windows-on (buffer)
    "Remove all windows showing BUFFER.  This calls `remove-window'
  on each window showing BUFFER."
    (interactive
     (list (read-buffer "Remove all windows showing buffer: " (current-buffer) 'existing)))
    (setq buffer (get-buffer buffer))     ; Convert to buffer.
    (when buffer                          ; Do nothing if null BUFFER.
      (dolist (fr (frames-on buffer t))
        (remove-window (get-buffer-window buffer t)))))

  ;;;###autoload
  (defun mouse-remove-window (event)
    "Remove the window you click on.  (This calls `remove-window'.)
  This command must be bound to a mouse click."
    (interactive "e")
    (mouse-minibuffer-check event)
    (remove-window (posn-window (event-start event))))

  ;;;###autoload
  (defun delete/iconify-window (&optional window frame-p)
    "Delete or iconify WINDOW (default: `selected-window').
  If WINDOW is the only one in its frame (`one-window-p'), then optional
  arg FRAME-P determines the behavior regarding the frame, as follows:
    If FRAME-P is nil, then the frame is deleted (with the window).
    If FRAME-P is t, then the frame is iconified.
    If FRAME-P is a symbol naming a function, the function is applied
               to WINDOW as its only arg.
               If the result is nil, then the frame is deleted.
               If the result is non-nil, then the frame is iconified.
    If FRAME-P is anything else, then behavior is as if FRAME-P were the
               symbol `window-dedicated-p': the frame is iconified if
               WINDOW is dedicated, otherwise the frame is deleted.
  Interactively, FRAME-P depends on the prefix arg, as follows:
    Without a prefix arg (prefix = nil), FRAME-P is `window-dedicated-p'.
    With prefix arg < 0, FRAME-P is t.  The frame is iconified.
    With prefix arg >= 0, FRAME-P is nil.  The frame is deleted."
    (interactive
     (list nil (if current-prefix-arg
                   (not (natnump (prefix-numeric-value current-prefix-arg)))
                 'window-dedicated-p)))
    (setq window (or window (selected-window)))
    (let ((one-win-p t))
      (save-window-excursion
        (select-window window)
        (if (one-window-p)
            (if frame-p
                (if (eq t frame-p)
                    (iconify-frame)
                  (unless (and (symbolp frame-p) (fboundp frame-p))
                    (setq frame-p 'window-dedicated-p))
                  (if (funcall frame-p window) (iconify-frame) (delete-frame)))
              (delete-frame))             ; Default.
          (setq one-win-p nil)))
      ;; Do this outside `save-window-excursion'.
      (unless one-win-p (old-delete-window window))))

  ;;;###autoload
  (defun delete/iconify-windows-on (buffer &optional frame frame-p)
    "For each window showing BUFFER: delete it or iconify its frame.
  \(This calls `delete/iconify-window' on each window showing BUFFER.)
  Optional second arg FRAME controls which frames are considered.
    If nil or omitted, treat all windows showing BUFFER in any frame.
    If t, treat only windows showing BUFFER in the selected frame.
    If `visible', treat all windows showing BUFFER in any visible frame.
    If a frame, treat only windows showing BUFFER in that frame.
  Optional third arg FRAME-P controls what to do with one-window frames.
    If FRAME-P is nil, then one-window frames showing BUFFER are deleted.
    If FRAME-P is t, then one-window frames are iconified.
    If FRAME-P is a symbol naming a function, the function is applied
               to each window showing buffer in a frame by itself.
               If the result is nil, then the frame is deleted.
               If the result is non-nil, then the frame is iconified.
    If FRAME-P is anything else, then behavior is as if FRAME-P were the
               symbol `window-dedicated-p': One-window frames are
               iconified if window is dedicated, else they are deleted.
  Interactively, FRAME is nil, and FRAME-P depends on the prefix arg:
    Without a prefix arg (prefix = nil), FRAME-P is `window-dedicated-p'.
    With prefix arg < 0, FRAME-P is t.  The frame is iconified.
    With prefix arg >= 0, FRAME-P is nil.  The frame is deleted."
    (interactive
     (list (read-buffer "Delete windows on buffer: " (current-buffer) 'existing)
           nil
           (if current-prefix-arg
               (not (natnump (prefix-numeric-value current-prefix-arg)))
             'window-dedicated-p)))
    (setq buffer (get-buffer buffer))     ; Convert to buffer.
    (when buffer                          ; Do nothing if null BUFFER.
      ;; `get-buffer-window' interprets FRAME oppositely for t and nil,
      ;; so switch.
      (setq frame (if (eq t frame) nil (if (eq nil frame) t frame)))
      (dolist (fr (frames-on buffer frame))
        (delete/iconify-window (get-buffer-window buffer frame) frame-p))))

  ;;;###autoload
  (defun rename-frame (&optional old-name new-name all-named)
    "Rename a frame named OLD-NAME to NEW-NAME.
  Prefix arg ALL-NAMED non-nil means rename all frames named FRAME to NEWNAME.
  OLD-NAME may be a frame, its name, or nil.  Default is `selected-frame'.
  NEW-NAME is a string or nil.  Default NEW-NAME is current `buffer-name'."
    (interactive
     (list (read-frame (concat "Rename " (and current-prefix-arg "all ")
                               "frame" (and current-prefix-arg "s named") ": ")
                       nil t)             ; Default = selected.  Must exist.
           (read-from-minibuffer "Rename to (new name): " (cons (buffer-name) 1))
           current-prefix-arg))
    (setq old-name (or old-name (get-frame-name))) ; Batch default: current.
    (setq new-name (or new-name (buffer-name))) ; Batch default: buffer name.
    ;; Convert to frame if string.
    (let ((fr (get-a-frame old-name)))
      (if all-named
          (while fr
            (modify-frame-parameters fr (list (cons 'name new-name)))
            (setq fr (get-a-frame old-name))) ; Get another.
        (when (string= (get-frame-name fr) (get-frame-name))
          (setq fr (selected-frame)))
        (modify-frame-parameters fr (list (cons 'name new-name))))))

  ;;;###autoload
  (defun rename-non-minibuffer-frame (&optional old-name new-name all-named)
    "Unless OLD-NAME names the minibuffer frame, use `rename-frame'
  to rename a frame named OLD-NAME to NEW-NAME.
  Prefix arg ALL-NAMED non-nil => Rename all frames named FRAME to NEWNAME.
  OLD-NAME may be a frame, its name, or nil.  Default is `selected-frame'.
  NEW-NAME is a string or nil.  Default NEW-NAME is current `buffer-name'."
    (interactive
     (list (read-frame (concat "Rename " (and current-prefix-arg "all ")
                               "frame" (and current-prefix-arg "s named") ": ")
                       nil t)             ; Default = selected.  Must exist.
           (read-from-minibuffer "Rename to (new name): " (cons (buffer-name) 1))
           current-prefix-arg))
    (setq old-name (or old-name (get-frame-name))) ; Batch default: current.
    (setq new-name (or new-name (buffer-name))) ; Batch default: buffer name.
    (let ((fr (get-a-frame old-name)))    ; Convert to frame if string.
      (if (and (boundp '1on1-minibuffer-frame)
               (eq (cdr (assq 'name (frame-parameters 1on1-minibuffer-frame)))
                   (cdr (assq 'name (frame-parameters fr)))))
          (and (interactive-p)
               (error "Use `rename-frame' if you really want to rename minibuffer"))
        (rename-frame))))

  ;;;###autoload
  (defun show-frame (frame)
    "Make FRAME visible and raise it, without selecting it.
  FRAME may be a frame or its name."
    (interactive (list (read-frame "Frame to make visible: ")))
    (setq frame (get-a-frame frame))
    (make-frame-visible frame)
    (raise-frame frame))

  ;;;###autoload
  (defun hide-frame (frame &optional prefix)
    "Make FRAME invisible.  Like `make-frame-invisible', but reads frame name.
  Non-nil PREFIX makes it invisible even if all other frames are invisible."
    (interactive (list (read-frame "Frame to make invisible: ")))
    (make-frame-invisible (get-a-frame frame) prefix))

  ;;;###autoload
  (defun show-a-frame-on (buffer)
    "Make visible and raise a frame showing BUFFER, if there is one.
  Neither the frame nor the BUFFER are selected.
  BUFFER may be a buffer or its name (a string)."
    (interactive
     (list (read-buffer "Show a frame showing buffer: "
                        (if (fboundp 'another-buffer) ; Defined in `misc-fns.el'.
                            (another-buffer nil t)
                          (other-buffer (current-buffer)))
                        'existing)))
    (when buffer                          ; Do nothing if null BUFFER.
      (let ((fr (car (frames-on buffer)))) (when fr (show-frame fr)))))

  ;;;###autoload
  (defun show-*Help*-buffer ()
    "Raise a frame showing buffer *Help*, without selecting it."
    (interactive) (show-a-frame-on "*Help*"))

  ;;;###autoload
  (defun delete-1-window-frames-on (buffer)
    "Delete all visible 1-window frames showing BUFFER."
    (interactive
     (list (read-buffer "Delete all visible 1-window frames showing buffer: "
                        (current-buffer) 'existing)))
    (setq buffer (get-buffer buffer))
    (save-excursion
      (when (buffer-live-p buffer)        ; Do nothing if dead buffer.
        (dolist (fr (frames-on buffer))   ; Is it better to search through
          (save-window-excursion          ; `frames-on' or `get-buffer-window-list'?
            (select-frame fr)
            (when (one-window-p t fr) (delete-frame)))))))

  ;;;###autoload
  (defun delete-other-frames (&optional frame)
    "Delete all frames except FRAME (default: selected frame).
  Interactively, use a prefix arg (`\\[universal-argument]') to be prompted for FRAME."
    (interactive (list (if current-prefix-arg
                           (get-a-frame (read-frame "Frame to make invisible: "))
                         (selected-frame))))
    (when frame
      (dolist (fr (frame-list))
        (unless (eq fr frame) (condition-case nil (delete-frame fr) (error nil))))))

  ;;;###autoload
  (defun maximize-frame-horizontally (&optional frame)
    "Maximize selected frame horizontally."
    (interactive (list (selected-frame)))
    (maximize-frame 'horizontal frame))

  ;;;###autoload
  (defun maximize-frame-vertically (&optional frame)
    "Maximize selected frame vertically."
    (interactive (list (selected-frame)))
    (maximize-frame 'vertical frame))

  ;;;###autoload
  (defun maximize-frame (&optional direction frame)
    "Maximize selected frame horizontally, vertically, or both.
  With no prefix arg, maximize both directions.
  With a non-negative prefix arg, maximize vertically.
  With a negative prefix arg, maximize horizontally.
  In Lisp code:
   DIRECTION is the direction: `horizontal', `vertical', or `both'.
   FRAME is the frame to maximize."
    (interactive (list (if current-prefix-arg
                           (if (natnump (prefix-numeric-value current-prefix-arg))
                               'vertical
                             'horizontal)
                         'both)))
    (unless frame (setq frame  (selected-frame)))
    (unless direction (setq direction 'both))
    (let (;; Size of a frame that uses all of the available screen area,
          ;; but leaving room for a minibuffer frame at bottom of display.
          (fr-pixel-width   (available-screen-pixel-width))
          (fr-pixel-height  (available-screen-pixel-height))
          (fr-origin        (if (eq direction 'horizontal)
                                (car (effective-screen-pixel-bounds))
                              (cadr (effective-screen-pixel-bounds))))
          (orig-left        (frame-parameter frame 'left))
          (orig-top         (frame-parameter frame 'top))
          (orig-width       (frame-parameter frame 'width))
          (orig-height      (frame-parameter frame 'height)))
      (let* ((borders     (* 2 (cdr (assq 'border-width (frame-parameters frame)))))
             (new-left    (if (memq direction '(horizontal both)) fr-origin 0))
             (new-top     (if (memq direction '(horizontal both)) 0         fr-origin))
             ;; Subtract borders, scroll bars, & title bar, then convert pixel sizes to char sizes.
             (new-width   (if (memq direction '(horizontal both))
                              (/ (- fr-pixel-width borders (frame-extra-pixels-width frame))
                                 (frame-char-width frame))
                            orig-width))
             (new-height  (if (memq direction '(vertical both))
                              (- (/ (- fr-pixel-height borders
                                       (frame-extra-pixels-height frame)
                                       window-mgr-title-bar-pixel-height
                                       (smart-tool-bar-pixel-height))
                                    (frame-char-height frame))
                                 ;; Subtract menu bar unless on Carbon Emacs (menu bar not in the frame).
                                 (if (eq window-system 'mac)
                                     0
                                   (cdr (assq 'menu-bar-lines (frame-parameters frame)))))
                            orig-height)))
        (modify-frame-parameters
         frame
         `((left   . ,new-left)
           (width  . ,new-width)
           (top    . ,new-top)
           (height . ,new-height)
           ;; If we actually changed a parameter, record the old one for restoration.
           ,(and new-left   (/= orig-left new-left)     (cons 'restore-left   orig-left))
           ,(and new-top    (/= orig-top  new-top)      (cons 'restore-top    orig-top))
           ,(and new-width  (/= orig-width  new-width)  (cons 'restore-width  orig-width))
           ,(and new-height (/= orig-height new-height) (cons 'restore-height orig-height)))))
      (show-frame frame)
      (incf fr-origin (if (eq direction 'horizontal) fr-pixel-width fr-pixel-height))))

  ;;;###autoload
  (defalias 'restore-frame-horizontally 'toggle-max-frame-horizontally)
  ;;;###autoload
  (defun toggle-max-frame-horizontally (&optional frame)
    "Toggle maximization of FRAME horizontally.
  If used once, this restores the frame.  If repeated, it maximizes.
  This affects the `left' and `width' frame parameters.
  FRAME defaults to the selected frame."
    (interactive (list (selected-frame)))
    (restore-frame 'horizontal frame))

  ;;;###autoload
  (defalias 'restore-frame-horizontally 'toggle-max-frame-horizontally)
  ;;;###autoload
  (defun toggle-max-frame-vertically (&optional frame)
    "Toggle maximization of FRAME vertically.
  If used once, this restores the frame.  If repeated, it maximizes.
  This affects the `top' and `height' frame parameters.
  FRAME defaults to the selected frame."
    (interactive (list (selected-frame)))
    (restore-frame 'vertical frame))

  ;;;###autoload
  (defalias 'restore-frame 'toggle-max-frame)
  ;;;###autoload
  (defun toggle-max-frame (&optional direction frame)
    "Toggle maximization of FRAME horizontally, vertically, or both.
  Reverses or (if restored) repeats the effect of the Emacs maximize
  commands.  Does not restore from maximization effected outside Emacs.
  With no prefix arg, toggle both directions.
  With a non-negative prefix arg, toggle only vertically.
  With a negative prefix arg, toggle horizontally.
  When toggling both, each is toggled from its last maximize or restore
  state.  This means that using this after `maximize-horizontal',
  `maximize-vertical', `toggle-max-horizontal', or `toggle-max-vertical'
  does not necessarily just reverse the effect of that command.
  In Lisp code:
   DIRECTION is the direction: `horizontal', `vertical', or `both'.
   FRAME is the frame to change.  It defaults to the selected frame."
    (interactive (list (if current-prefix-arg
                           (if (natnump (prefix-numeric-value current-prefix-arg))
                               'vertical
                             'horizontal)
                         'both)))
    (unless frame (setq frame  (selected-frame)))
    (unless direction (setq direction 'both))
    (let ((restore-left    (frame-parameter frame 'restore-left))
          (restore-top     (frame-parameter frame 'restore-top))
          (restore-width   (frame-parameter frame 'restore-width))
          (restore-height  (frame-parameter frame 'restore-height))
          (orig-left       (frame-parameter frame 'left))
          (orig-top        (frame-parameter frame 'top))
          (orig-width      (frame-parameter frame 'width))
          (orig-height     (frame-parameter frame 'height))
          (horiz           (memq direction '(horizontal both)))
          (vert            (memq direction '(vertical both))))
      (modify-frame-parameters
       frame `(,(and horiz restore-left   (cons 'left   restore-left))
               ,(and horiz restore-width  (cons 'width  restore-width))
               ,(and vert  restore-top    (cons 'top    restore-top))
               ,(and vert  restore-height (cons 'height restore-height))
               ,(and horiz restore-left   (cons 'restore-left   orig-left))
               ,(and horiz restore-width  (cons 'restore-width  orig-width))
               ,(and vert  restore-top    (cons 'restore-top    orig-top))
               ,(and vert  restore-height (cons 'restore-height orig-height)))))
    (show-frame frame))

  ;;;###autoload
  (defun tile-frames-horizontally (&optional frames)
    "Tile frames horizontally.
  Interatively:
    With prefix arg, you are prompted for names of two frames to tile.
    With no prefix arg, all visible frames are tiled, except a
         standalone minibuffer frame, if any.
  If called from a program, all frames in list FRAMES are tiled."
    (interactive (and current-prefix-arg (read-args-for-tile-frames)))
    (tile-frames 'horizontal frames))

  ;;;###autoload
  (defun tile-frames-vertically (&optional frames)
    "Tile frames vertically.
  Interatively:
    With prefix arg, you are prompted for names of two frames to tile.
    With no prefix arg, all visible frames are tiled, except a
         standalone minibuffer frame, if any.
  If called from a program, all frames in list FRAMES are tiled."
    (interactive (and current-prefix-arg (read-args-for-tile-frames)))
    (tile-frames 'vertical frames))

  (defun tile-frames (direction frames)
    "Tile visible frames horizontally or vertically, depending on DIRECTION.
  Arg DIRECTION is `horizontal' or `vertical'.
  Arg FRAMES is the list of frames to tile.  If nil, then tile all visible
  frames (except a standalone minibuffer frame, if any)."
    (let ((visible-frames
           (or frames
               (filtered-frame-list       ; Get visible frames, except minibuffer.
                (function
                 (lambda (fr)
                  (and (eq t (frame-visible-p fr))
                       (or (not (fboundp 'thumfr-thumbnail-frame-p))
                           (not (thumfr-thumbnail-frame-p fr)))
                       (or (not (boundp '1on1-minibuffer-frame))
                           (not (eq (cdr (assq 'name (frame-parameters 1on1-minibuffer-frame)))
                                    (cdr (assq 'name (frame-parameters fr))))))))))))
          ;; Size of a frame that uses all of the available screen area,
          ;; but leaving room for a minibuffer frame at bottom of display.
          (fr-pixel-width (available-screen-pixel-width))
          (fr-pixel-height (available-screen-pixel-height))
          (fr-origin (if (eq direction 'horizontal)
                         (car (effective-screen-pixel-bounds))
                       (cadr (effective-screen-pixel-bounds)))))
      (case direction                     ; Size of frame in pixels.
        (horizontal (setq fr-pixel-width  (/ fr-pixel-width  (length visible-frames))))
        (vertical   (setq fr-pixel-height (/ fr-pixel-height (length visible-frames))))
        (otherwise (error "Function tile-frames: DIRECTION must be `horizontal' or `vertical'")))
      (dolist (fr visible-frames)
        ;; $$$$$$ (let ((borders (* 2 (+ (cdr (assq 'border-width (frame-parameters fr)))
        ;;                               (cdr (assq 'internal-border-width (frame-parameters fr)))))))
        (let ((borders (* 2 (cdr (assq 'border-width (frame-parameters fr))))))
          (set-frame-size
           fr
           ;; Subtract borders, scroll bars, & title bar, then convert pixel sizes to char sizes.
           (/ (- fr-pixel-width borders (frame-extra-pixels-width fr))
              (frame-char-width fr))
           (- (/ (- fr-pixel-height borders (frame-extra-pixels-height fr)
                    window-mgr-title-bar-pixel-height (smart-tool-bar-pixel-height))
                 (frame-char-height fr))
              (if (eq window-system 'mac)
                  0                       ; Menu bar for Carbon Emacs is not in the frame.
                (cdr (assq 'menu-bar-lines (frame-parameters fr))))))) ; Subtract `menu-bar-lines'.
        (set-frame-position fr
                            (if (eq direction 'horizontal) fr-origin 0)
                            (if (eq direction 'horizontal) 0 fr-origin))
        (show-frame fr)
        (incf fr-origin (if (eq direction 'horizontal) fr-pixel-width fr-pixel-height)))))

  (defun frame-extra-pixels-width (frame)
    "Pixel difference between FRAME total width and its text area width."
    (- (frame-pixel-width frame) (* (frame-char-width frame) (frame-width frame))))

  (defun frame-extra-pixels-height (frame)
    "Pixel difference between FRAME total height and its text area height."
    (- (frame-pixel-height frame) (* (frame-char-height frame) (frame-height frame))))

  (defun smart-tool-bar-pixel-height (&optional frame)
    "Pixel height of Mac smart tool bar."
    (if (and (boundp 'mac-tool-bar-display-mode) (> (frame-parameter frame 'tool-bar-lines) 0))
        (if (eq mac-tool-bar-display-mode 'icons) 40 56)
      0))

  (defun read-args-for-tile-frames ()
    "Read arguments for `tile-frames'."
    (list
     (list
      ;; Note: `read-frame' puts selected-frame name at front of `frame-name-history'.
      (get-a-frame (read-frame "Tile two frames - First frame: " nil t))
      ;; Get next visible frame.  For default (prompt) value:
      ;;   If there is another visible frame in `frame-name-history', use next such.
      ;;   Else if there is another visible frame in internal frame list, use next such.
      ;;   Else use selected frame. (`frame-name-history' is defined in `frame.el'.)
      (get-a-frame
       (read-frame
        "Second frame: "
        (let ((fr-names (cdr frame-name-history))
              (visible-p nil)
              (fr nil))
          (while (and (not fr) fr-names)  ; While no visible frame found and still fr-names to check.
            (setq fr (car fr-names))      ; Name
            (setq fr (get-a-frame fr))    ; Frame
            (setq fr (and fr (eq t (frame-visible-p fr)) fr)) ; Visible frame
            (setq fr-names (cdr fr-names)))

          ;; If no visible frames in history, besides selected-frame,
          ;; then get next visible frame (not its name) from internal frame list.
          (unless fr
            (setq fr (selected-frame))
            (while (and (not visible-p)
                        (setq fr (next-frame fr))
                        (not (equal fr (selected-frame)))) ; equal => no other found.
              (setq visible-p (eq t (frame-visible-p fr)))))
          fr)
        t)))))

  (defun available-screen-pixel-bounds ()
    "Returns a value of the same form as `available-screen-pixel-bounds'.
  This represents the currently available screen area."
    (or available-screen-pixel-bounds     ; Use the option value, if available.
        (if (fboundp 'mac-display-available-pixel-bounds) ; Mac-OS-specific.
            (mac-display-available-pixel-bounds)
          (list 0 0 (x-display-pixel-width) (x-display-pixel-height)))))

  (defun effective-screen-pixel-bounds ()
    "Upper left and lower right of available screen space for tiling frames.
  This is `available-screen-pixel-bounds', possibly adjusted to allow
  for the standalone minibuffer frame provided by `oneonone.el'."
    (if (boundp '1on1-minibuffer-frame)
        (append (butlast (available-screen-pixel-bounds))
                (list (frame-geom-value-numeric 'top (cdr (assq 'top (frame-parameters
                                                                      1on1-minibuffer-frame))))))
      (available-screen-pixel-bounds)))

  (defun available-screen-pixel-width (&optional include-mini-p)
    "Width of the usable screen, in pixels.
  Non-nil optional argument `include-mini-p' means include the space
  occupied by a standalone minibuffer, if any."
    (let ((bounds (if include-mini-p
                      (available-screen-pixel-bounds)
                    (effective-screen-pixel-bounds))))
      (- (caddr bounds) (car bounds)))) ; X1 - X0

  (defun available-screen-pixel-height (&optional include-mini-p)
    "Height of the usable screen, in pixels.
  Non-nil optional argument `include-mini-p' means include the
  space occupied by a standalone minibuffer, if any."
    (let ((bounds (if include-mini-p
                      (available-screen-pixel-bounds)
                    (effective-screen-pixel-bounds))))
      (- (cadddr bounds) (cadr bounds)))) ; Y1 - Y0

  ;; Inspired by `sk-grow-frame' from Sarir Khamsi [sarir.khamsi@raytheon.com]
  ;;;###autoload
  (defun enlarge-frame (&optional increment frame)
    "Increase the height of FRAME (default: selected-frame) by INCREMENT.
  INCREMENT is in lines (characters).
  Interactively, it is given by the prefix argument."
    (interactive "p")
    (set-frame-height frame (+ (frame-height frame) increment)))

  ;;;###autoload
  (defun enlarge-frame-horizontally (&optional increment frame)
    "Increase the width of FRAME (default: selected-frame) by INCREMENT.
  INCREMENT is in columns (characters).
  Interactively, it is given by the prefix argument."
    (interactive "p")
    (set-frame-width frame (+ (frame-width frame) increment)))

  ;;;###autoload
  (defun shrink-frame (&optional increment frame)
    "Decrease the height of FRAME (default: selected-frame) by INCREMENT.
  INCREMENT is in lines (characters).
  Interactively, it is given by the prefix argument."
    (interactive "p")
    (set-frame-height frame (- (frame-height frame) increment)))

  ;;;###autoload
  (defun shrink-frame-horizontally (&optional increment frame)
    "Decrease the width of FRAME (default: selected-frame) by INCREMENT.
  INCREMENT is in columns (characters).
  Interactively, it is given by the prefix argument."
    (interactive "p")
    (set-frame-width frame (- (frame-width frame) increment)))

  ;;;###autoload
  (defun move-frame-down (&optional increment frame)
    "Move FRAME (default: selected-frame) down by INCREMENT.
  INCREMENT is in units of ten pixels.
  Interactively, it is given by the prefix argument."
    (interactive "P")
    (setq increment (if increment (prefix-numeric-value increment) 10)) ; 1 is too small
    (modify-frame-parameters frame
                             (list (list 'top '+ (new-frame-position frame 'top increment)))))

  ;;;###autoload
  (defun move-frame-up (&optional increment frame)
    "Move FRAME (default: selected-frame) up by INCREMENT.
  INCREMENT is in units of ten pixels.
  Interactively, it is given by the prefix argument."
    (interactive "P")
    (setq increment (if increment (prefix-numeric-value increment) 10)) ; 1 is too small
    (move-frame-down (- increment)))

  ;;;###autoload
  (defun move-frame-right (&optional increment frame)
    "Move FRAME (default: selected-frame) toward the right by INCREMENT.
  INCREMENT is in units of ten pixels.
  Interactively, it is given by the prefix argument."
    (interactive "P")
    (setq increment (if increment (prefix-numeric-value increment) 10)) ; 1 is too small
    (modify-frame-parameters frame
                             (list (list 'left '+ (new-frame-position frame 'left increment)))))

  ;;;###autoload
  (defun move-frame-left (&optional increment frame)
    "Move FRAME (default: selected-frame) toward the left by INCREMENT.
  INCREMENT is in units of ten pixels.
  Interactively, it is given by the prefix argument."
    (interactive "P")
    (setq increment (if increment (prefix-numeric-value increment) 10)) ; 1 is too small
    (move-frame-right (- increment)))

  ;; Helper function.
  (defun new-frame-position (frame type incr)
    "Return the new TYPE position of FRAME, incremented by INCR.
  TYPE is `left' or `top'.
  INCR is the increment to use when changing the position."
    (let ((new-pos
           (+ incr (cadr (frame-geom-value-cons type (cdr (assq type (frame-parameters frame)))))))
          (display-dimension
           (if (eq 'left type)
               (available-screen-pixel-width t)
             (available-screen-pixel-height t)))
          (frame-dimension
           (if (eq 'left type) (frame-pixel-width frame) (frame-pixel-height frame))))
      (if (not move-frame-wrap-within-display-flag)
          new-pos
        (when (< new-pos (- frame-dimension)) (setq new-pos display-dimension))
        (when (> new-pos display-dimension) (setq new-pos (- frame-dimension)))
        new-pos)))

  ;;; This was a workaround hack for an Emacs 23 bug (#119, aka #1562).
  ;;; This works OK, but it is not as refined as the version I use, and it does not work for
  ;;; older Emacs versions.
  ;;;
  ;;; (when (> emacs-major-version 22)
  ;;;   (defun enlarge-font (&optional increment frame)
  ;;;     "Increase size of font in FRAME by INCREMENT.
  ;;; Interactively, INCREMENT is given by the prefix argument.
  ;;; Optional FRAME parameter defaults to current frame."
  ;;;     (interactive "p")
  ;;;     (setq frame (or frame (selected-frame)))
  ;;;     (set-face-attribute
  ;;;      'default frame :height (+ (* 10 increment)
  ;;;                                (face-attribute 'default :height frame 'default)))))


  ;; This still doesn't work 100% well.  For instance, set frame font to
  ;; "-raster-Terminal-normal-r-normal-normal-12-90-96-96-c-50-ms-oemlatin", then decrease font size.
  ;; The next smaller existing font on my machine is
  ;; "-raster-Terminal-normal-r-normal-normal-11-*-96-96-c-*-ms-oemlatin".  Decrease size again.
  ;; Next smaller font is "-raster-Terminal-bold-r-normal-normal-5-37-96-96-c-60-ms-oemlatin".  Notice
  ;; the switch to bold from regular.  Cannot decrease any more.  Increase size.  Next larger font is
  ;; "-raster-Terminal-bold-r-normal-normal-8-*-96-96-c-*-ms-oemlatin".  Can no longer increase size.
  ;;
  ;;;###autoload
  (defun enlarge-font (&optional increment frame)
    "Increase size of font in FRAME by INCREMENT.
  Interactively, INCREMENT is given by the prefix argument.
  Optional FRAME parameter defaults to current frame."
    (interactive "p")
    (setq frame (or frame (selected-frame)))
    (let ((fontname (cdr (assq 'font (frame-parameters frame))))
          (count enlarge-font-tries))
      (setq fontname (enlarged-font-name fontname frame increment))
      (while (and (not (x-list-fonts fontname)) (wholenump (setq count (1- count))))
        (setq fontname (enlarged-font-name fontname frame increment)))
      (unless (x-list-fonts fontname) (error "Cannot change font size"))
      (modify-frame-parameters frame (list (cons 'font fontname)))
      ;; Update faces that want a bold or italic version of the default font.
      (when (< emacs-major-version 21) (frame-update-faces frame))))

  (defun enlarged-font-name (fontname frame increment)
    "FONTNAME, after enlarging font size of FRAME by INCREMENT.
  FONTNAME is the font of FRAME."
    (when (query-fontset fontname)
      (let ((ascii (assq 'ascii (aref (fontset-info fontname frame) 2))))
        (when ascii (setq fontname (nth 2 ascii)))))
    (let ((xlfd-fields (x-decompose-font-name fontname)))
      (unless xlfd-fields (error "Cannot decompose font name"))
      (let ((new-size (+ (string-to-number (aref xlfd-fields xlfd-regexp-pixelsize-subnum))
                         increment)))
        (unless (> new-size 0) (error "New font size is too small: %s" new-size))
        (aset xlfd-fields xlfd-regexp-pixelsize-subnum (number-to-string new-size)))
      ;; Set point size & width to "*", so frame width will adjust to new font size
      (aset xlfd-fields xlfd-regexp-pointsize-subnum "*")
      (aset xlfd-fields xlfd-regexp-avgwidth-subnum "*")
      (x-compose-font-name xlfd-fields)))

  ;;;###autoload
  (defun set-frame-alist-parameter-from-frame (alist parameter &optional frame)
    "Set PARAMETER of frame alist ALIST to its current value in FRAME.
  FRAME defaults to the selected frame.  ALIST is a variable (symbol)
  whose value is an alist of frame parameters."
    (interactive
     (let ((symb (or (and (fboundp 'symbol-nearest-point)(symbol-nearest-point))
                     (and (symbolp (variable-at-point)))))
           (enable-recursive-minibuffers t))
       (list (intern (completing-read "Frame alist to change (variable): "
                                      (frame-alist-var-names) nil t nil nil 'default-frame-alist t))
             (intern (completing-read "Parameter to set:"
                                      (frame-parameter-names) nil t nil nil 'left t))
             (get-a-frame (read-frame "Frame to copy parameter value from: " nil t)))))
    (unless (boundp alist)
      (error "Not a defined Emacs variable: `%s'" alist))
    (set alist (assq-delete-all parameter (copy-alist (eval alist))))
    (set alist (cons (assq parameter (frame-parameters frame)) (eval alist)))
    (tell-customize-var-has-changed alist))

  ;;; Standard Emacs 21+ function, defined here for Emacs 20.
  (unless (fboundp 'assq-delete-all)
    (defun assq-delete-all (key alist)
      "Delete from ALIST all elements whose car is `eq' to KEY.
  Return the modified alist.
  Elements of ALIST that are not conses are ignored."
      (while (and (consp (car alist)) (eq (car (car alist)) key)) (setq alist (cdr alist)))
      (let ((tail alist) tail-cdr)
        (while (setq tail-cdr (cdr tail))
          (if (and (consp (car tail-cdr)) (eq (car (car tail-cdr)) key))
              (setcdr tail (cdr tail-cdr))
            (setq tail tail-cdr))))
      alist))

  ;;;###autoload
  (defun set-all-frame-alist-parameters-from-frame (alist &optional frame really-all-p)
    "Set frame parameters of ALIST to their current values in FRAME.
  Unless optional argument REALLY-ALL-P (prefix arg) is non-nil, the
  frame parameters in list `frame-parameters-to-exclude' are
  excluded: they are not copied from FRAME to ALIST.
  ALIST is a variable (symbol) whose value is an alist of frame parameters.
  FRAME defaults to the selected frame."
    (interactive
     (let ((symb (or (and (fboundp 'symbol-nearest-point)(symbol-nearest-point))
                     (and (symbolp (variable-at-point)))))
           (enable-recursive-minibuffers t))
       (list (intern (completing-read "Frame alist to change (variable): "
                                      (frame-alist-var-names) nil t nil nil 'default-frame-alist t))
             (get-a-frame (read-frame "Frame to copy parameter values from: " nil t))
             current-prefix-arg)))
    (unless (boundp alist)
      (error "Not a defined Emacs variable: `%s'" alist))
    (set alist (set-difference (frame-parameters frame)
                               (and (not really-all-p) frame-parameters-to-exclude)
                               :key 'car))
    (tell-customize-var-has-changed alist))

  (defun frame-alist-var-names ()
    "Return an alist of all variable names that end in \"frame-alist\".
  The CAR of each list item is a string variable name.
  The CDR is nil."
    (let ((vars nil))
      (mapatoms (lambda (sym) (and (boundp sym)
                                   (setq sym (symbol-name sym))
                                   (string-match "frame-alist$" sym)
                                   (push (list sym) vars))))
      vars))

  (defun frame-parameter-names ()
    "Return an alist of all available frame-parameter names.
  The CAR of each list item is a string parameter name.
  The CDR is nil."
    (let ((params '(("display") ("title") ("name") ("left") ("top") ("icon-left") ("icon-top")
                    ("user-position") ("height") ("width") ("window-id") ("minibuffer")
                    ("buffer-predicate") ("buffer-list") ("font") ("auto-raise") ("auto-lower")
                    ("vertical-scroll-bars") ("horizontal-scroll-bars") ("scroll-bar-width")
                    ("icon-type") ("icon-name") ("foreground-color") ("background-color")
                    ("background-mode") ("mouse-color") ("cursor-color") ("border-color")
                    ("display-type") ("cursor-type") ("border-width") ("internal-border-width")
                    ("unsplittable") ("visibility") ("menu-bar-lines"))))
      (when (> emacs-major-version 20)
        (setq params (nconc params '("fullscreen" "outer-window-id" "tty-color-mode" "left-fringe"
                                     "right-fringe" "tool-bar-lines" "screen-gamma" "line-spacing"
                                     "wait-for-wm" "scroll-bar-foreground" "scroll-bar-background"))))
      (when (> emacs-major-version 21) (setq params (nconc params '("user-size"))))
      (when (> emacs-major-version 22)
        (setq params (nconc params '("display-environment-variable" "term-environment-variable"))))
      params))

  ;;;###autoload
  (defun tell-customize-var-has-changed (variable)
    "Tell Customize to recognize that VARIABLE has been set (changed).
  VARIABLE is a symbol that names a user option."
    (interactive "vVariable: ")
    (put variable 'customized-value (list (custom-quote (eval variable)))))

  ;;;###autoload
  (defun other-window-or-frame (arg)
    "`other-frame', if `one-window-p'; otherwise, `other-window'."
    (interactive "p")
    (if (one-window-p) (other-frame arg) (other-window arg)))

  ;;;;;;;;;;;;;;;;;;;;;;;

  (provide 'frame-cmds)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; frame-cmds.el ends here
#+end_src
#+begin_src emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/site-lisp/frame-fns.el
  ;;; Frame-fns.el --- Non-interactive frame and window functions.
  ;;
  ;; Filename: frame-fns.el
  ;; Description: Non-interactive frame and window functions.
  ;; Author: Drew Adams
  ;; Maintainer: Drew Adams
  ;; Copyright (C) 1996-2011, Drew Adams, all rights reserved.
  ;; Created: Tue Mar  5 16:15:50 1996
  ;; Version: 21.1
  ;; Last-Updated: Tue Jan  4 09:43:55 2011 (-0800)
  ;;           By: dradams
  ;;     Update #: 197
  ;; URL: http://www.emacswiki.org/cgi-bin/wiki/frame-fns.el
  ;; Keywords: internal, extensions, local, frames
  ;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x
  ;;
  ;; Features that might be required by this library:
  ;;
  ;;   `avoid'.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Commentary:
  ;;
  ;;    Non-interactive frame and window functions.
  ;;
  ;;  Main new functions defined here:
  ;;
  ;;    `1-window-frames-on', `distance', `flash-ding',
  ;;    `frame-geom-spec-cons', `frame-geom-value-cons',
  ;;    `frame-geom-spec-numeric', `frame-geom-value-numeric',
  ;;    `frames-on', `get-a-frame', `get-frame-name',
  ;;    `multi-window-frames-on', `read-frame', `window-coords'.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Change log:
  ;;
  ;; 2011/01/04 dadams
  ;;     Removed autoload cookies from non-interactive functions.
  ;; 2010/01/12 dadams
  ;;     1-window-frames-on, multi-window-frames-on:
  ;;       save-excursion + set-buffer -> with-current-buffer.
  ;; 2008/04/05 dadams
  ;;     get-a-frame: Define without using member-if.
  ;; 2005/10/31 dadams
  ;;     read-frame: Swapped default and init values in call to completing-read.
  ;; 2004/11/26 dadams
  ;;     Added frame-geom-spec-numeric and frame-geom-value-numeric.
  ;; 2004/03/19 dadams
  ;;     read-frame: 1) if default is a frame, use its name,
  ;;                 2) use frame-name-history, not minibuffer-history,
  ;;                    and use make-frame-names-alist, not frame-alist,
  ;;                    in completing-read
  ;; 1996/02/14 dadams
  ;;     Added: window-coords, distance.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 2, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program; see the file COPYING.  If not, write to
  ;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  ;; Floor, Boston, MA 02110-1301, USA.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Code:

  (eval-when-compile (require 'cl-lib)) ;; (plus, for Emacs 20: dolist, push
                                    ;;  and, for Emacs <20: cadr, when, unless)
  (require 'avoid nil t) ;; mouse-avoidance-point-position

  ;;;;;;;;;;;;;;;;;;;;;;;

  (defun window-coords (&optional position)
    "Return window coordinates of buffer POSITION (default: point).
  If POSITION is nil, (point) is used."
    (unless (fboundp 'mouse-avoidance-point-position) (require 'avoid))
    (cdr (mouse-avoidance-point-position)))

  (defun distance (pt1 pt2)
    "Distance as the crow flies between PT1 and PT2.
  PT1 and PT2 are each a cons of the form (X . Y)."
    (let ((xdiff (abs (- (car pt1) (car pt2))))
          (ydiff (abs (- (cdr pt1) (cdr pt2)))))
      (sqrt (+ (* xdiff xdiff) (* ydiff ydiff)))))

  (defun frame-geom-value-numeric (type value &optional frame)
    "Return equivalent geometry value for FRAME in numeric terms.
  A geometry value equivalent to VALUE for FRAME is returned,
  where the value is numeric, not a consp.
  TYPE is the car of the original geometry spec (TYPE . VALUE).
     It is `top' or `left', depending on which edge VALUE is related to.
  VALUE is the cdr of a frame geometry spec: (left/top . VALUE).
  If VALUE is a consp, then it is converted to a numeric value, perhaps
     relative to the opposite frame edge from that in the original spec.
  FRAME defaults to the selected frame.

  Examples (measures in pixels) -
   Assuming display height/width=1024, frame height/width=600:
   300 inside display edge:                   300  =>  300
                                          (+  300) =>  300
   300 inside opposite display edge:      (-  300) => -300
                                             -300  => -300
   300 beyond display edge
    (= 724 inside opposite display edge): (+ -300) => -724
   300 beyond display edge
    (= 724 inside opposite display edge): (- -300) =>  724

  In the last two examples, the returned value is relative to the
  opposite frame edge from the edge indicated in the input spec."
    (if (consp value)
        (if (natnump (cadr value))
            ;; e.g. (+ 300) or (- 300) => 300 or -300
            (funcall (car value) (cadr value))
          ;; e.g. (+ -300) or (- -300)
          (let ((oppval (- (if (eq 'left type)
                               (x-display-pixel-width)
                             (x-display-pixel-height))
                           (cadr value)
                           (if (eq 'left type)
                               (frame-pixel-width frame)
                             (frame-pixel-height frame)))))
            (if (eq '+ (car value))
                (- oppval)                ; e.g. (+ -300) => -724
              oppval)))                   ; e.g. (- -300) =>  724
      ;; e.g. 300 or -300
      value))

  (defun frame-geom-spec-numeric (spec &optional frame)
    "Return equivalent geometry specification for FRAME in numeric terms.
  A geometry specification equivalent to SPEC for FRAME is returned,
  where the value is numeric, not a consp.
  SPEC is a frame geometry spec: (left . VALUE) or (top . VALUE).
  If VALUE is a consp, then it is converted to a numeric value, perhaps
     relative to the opposite frame edge from that in the original SPEC.
  FRAME defaults to the selected frame.

  Examples (measures in pixels) -
   Assuming display height=1024, frame height=600:
   top 300 below display top:               (top .  300) => (top .  300)
                                            (top +  300) => (top .  300)
   bottom 300 above display bottom:         (top -  300) => (top . -300)
                                            (top . -300) => (top . -300)
   top 300 above display top
    (= bottom 724 above display bottom):    (top + -300) => (top . -724)
   bottom 300 below display bottom
    (= top 724 below display top):          (top - -300) => (top .  724)

  In the last two examples, the returned value is relative to the
  opposite frame edge from the edge indicated in the input SPEC."
    (cons (car spec) (frame-geom-value-numeric (car spec) (cdr spec))))

  (defun frame-geom-value-cons (type value &optional frame)
    "Return equivalent geometry value for FRAME as a cons with car `+'.
  A geometry value equivalent to VALUE for FRAME is returned,
  where the value is a cons with car `+', not numeric.
  TYPE is the car of the original geometry spec (TYPE . VALUE).
     It is `top' or `left', depending on which edge VALUE is related to.
  VALUE is the cdr of a frame geometry spec: (left/top . VALUE).
  If VALUE is a number, then it is converted to a cons value, perhaps
     relative to the opposite frame edge from that in the original spec.
  FRAME defaults to the selected frame.

  Examples (measures in pixels) -
   Assuming display height/width=1024, frame height/width=600:
   300 inside display edge:                   300  => (+  300)
                                          (+  300) => (+  300)
   300 inside opposite display edge:      (-  300) => (+  124)
                                             -300  => (+  124)
   300 beyond display edge
    (= 724 inside opposite display edge): (+ -300) => (+ -300)
   300 beyond display edge
    (= 724 inside opposite display edge): (- -300) => (+  724)

  In the 3rd, 4th, and 6th examples, the returned value is relative to
  the opposite frame edge from the edge indicated in the input spec."
    (cond ((and (consp value) (eq '+ (car value))) ; e.g. (+ 300), (+ -300)
           value)
          ((natnump value) (list '+ value)) ; e.g. 300 => (+ 300)
          (t                              ; e.g. -300, (- 300), (- -300)
           (list '+ (- (if (eq 'left type) ; => (+ 124), (+ 124), (+ 724)
                           (x-display-pixel-width)
                         (x-display-pixel-height))
                       (if (integerp value) (- value) (cadr value))
                       (if (eq 'left type)
                           (frame-pixel-width frame)
                         (frame-pixel-height frame)))))))

  (defun frame-geom-spec-cons (spec &optional frame)
    "Return equivalent geometry spec for FRAME as a cons with car `+'.
  A geometry specification equivalent to SPEC for FRAME is returned,
  where the value is a cons with car `+', not numeric.
  SPEC is a frame geometry spec: (left . VALUE) or (top . VALUE).
  If VALUE is a number, then it is converted to a cons value, perhaps
     relative to the opposite frame edge from that in the original spec.
  FRAME defaults to the selected frame.

  Examples (measures in pixels) -
   Assuming display height=1024, frame height=600:
   top 300 below display top:               (top .  300) => (top +  300)
                                            (top +  300) => (top +  300)
   bottom 300 above display bottom:         (top -  300) => (top +  124)
                                            (top . -300) => (top +  124)
   top 300 above display top
    (= bottom 724 above display bottom):    (top + -300) => (top + -300)
   bottom 300 below display bottom
    (= top 724 below display top):          (top - -300) => (top +  724)

  In the 3rd, 4th, and 6th examples, the returned value is relative to
  the opposite frame edge from the edge indicated in the input spec."
    (cons (car spec) (frame-geom-value-cons (car spec) (cdr spec))))

  (defun get-frame-name (&optional frame)
    "Return the string that names FRAME (a frame).  Default is selected frame."
    (unless frame (setq frame (selected-frame)))
    (if (framep frame)
        (cdr (assq 'name (frame-parameters frame)))
      (error "Function `get-frame-name': Argument not a frame: `%s'" frame)))

  (defun get-a-frame (frame)
    "Return a frame, if any, named FRAME (a frame or a string).
  If none, return nil.
  If FRAME is a frame, it is returned."
    (cond ((framep frame) frame)
          ((stringp frame)
           (catch 'get-a-frame-found
             (dolist (fr (frame-list))
               (when (string= frame (get-frame-name fr))
                 (throw 'get-a-frame-found fr)))
             nil))
          (t
           (error
            "Function `get-frame-name': Arg neither a string nor a frame: `%s'"
            frame))))

  (defun read-frame (prompt &optional default existing)
    "Read the name of a frame, and return it as a string.
  Prompts with 1st arg, PROMPT (a string).

  The default frame is named by the optional 2nd arg, DEFAULT, if a
  string or a frame, or by the `selected-frame', if nil.

  Non-nil optional 3rd arg, EXISTING, means to allow only names of
  existing frames."
    (setq default (if (framep default) (get-frame-name default)
                    (or default (get-frame-name))))
    (unless (stringp default)
      (error
       "Function `read-frame': DEFAULT arg is neither a frame nor a string"))
    (completing-read prompt (make-frame-names-alist)
                     ;; To limit to live frames:
                     ;; (function (lambda (fn+f)(frame-live-p (cdr fn+f))))
                     ;; `frame-name-history' is defined in `frame.el'.
                     nil existing nil '(frame-name-history . 2) default))

  (defun frames-on (buffer &optional frame)
    "List of all live frames showing BUFFER (a buffer or its name).
  The optional FRAME argument is as for function `get-buffer-window'."
    (filtered-frame-list (function (lambda (fr) (get-buffer-window buffer fr)))))

  (defun 1-window-frames-on (buffer)
    "List of all visible 1-window frames showing BUFFER."
    (setq buffer  (get-buffer buffer))
    (when buffer                          ; Do nothing if BUFFER is not a buffer.
      (let ((frs nil))
        (with-current-buffer buffer
          (when (buffer-live-p buffer)    ; Do nothing if dead buffer.
            (dolist (fr (frames-on buffer)) ; Is it better to search through
              (save-window-excursion      ; frames-on or windows-on?
                (select-frame fr)
                (when (one-window-p t fr) (push fr frs))))))
        frs)))

  (defun multi-window-frames-on (buffer)
    "List of all visible multi-window frames showing BUFFER."
    (setq buffer  (get-buffer buffer))
    (when buffer                          ; Do nothing if BUFFER is not a buffer.
      (let ((frs nil))
        (with-current-buffer buffer
          (when (buffer-live-p buffer)    ; Do nothing if dead buffer.
            (dolist (fr (frames-on buffer)) ; Is it better to search through
              (save-window-excursion      ; frames-on or windows-on?
                (select-frame fr)
                (when (not (one-window-p t fr)) (push fr frs))))))
        frs)))

  (defun flash-ding (&optional do-not-terminate frame)
    "Ring bell (`ding'), after flashing FRAME (default: current), if relevant.
  Terminates any keyboard macro executing, unless arg DO-NOT-TERMINATE non-nil."
    (save-window-excursion
      (when frame (select-frame frame))
      (let ((visible-bell t))             ; Flash.
        (ding do-not-terminate)))
    (let ((visible-bell nil))
      (ding do-not-terminate)))           ; Bell.

  ;;;;;;;;;;;;;;;;;;;;;;;

  (provide 'frame-fns)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; frame-fns.el ends here
#+end_src
#+begin_src emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/site-lisp/smooth-scrolling.el
  ;; smooth-scrolling.el
  ;; $Id: smooth-scrolling.el,v 1.8 2007/09/11 23:38:09 adam Exp $
  ;; Adam Spiers <emacs-ss@adamspiers.org>
  ;;
  ;; Make emacs scroll smoothly, keeping the point away from the top and
  ;; bottom of the current buffer's window in order to keep lines of
  ;; context around the point visible as much as possible, whilst
  ;; avoiding sudden scroll jumps which are visually confusing.
  ;;
  ;; This is a nice alternative to all the native scroll-* custom
  ;; variables, which unfortunately cannot provide this functionality
  ;; perfectly.  `scroll-margin' comes closest, but has some bugs
  ;; (e.g. with handling of mouse clicks).  See
  ;;
  ;;   http://www.emacswiki.org/cgi-bin/wiki/SmoothScrolling
  ;;
  ;; for the gory details.
  ;;
  ;;;_* Installation
  ;;
  ;; Put somewhere on your `load-path' and include
  ;;
  ;;   (require 'smooth-scrolling)
  ;;
  ;; in your .emacs initialization file.
  ;;
  ;;;_* Notes
  ;;
  ;; This only affects the behaviour of the `next-line' and
  ;; `previous-line' functions, usually bound to the cursor keys and
  ;; C-n/C-p.  Other methods of moving the point will behave as normal
  ;; according to the standard custom variables.
  ;;
  ;; Prefix arguments to `next-line' and `previous-line' are honoured.
  ;; The minimum number of lines are scrolled in order to keep the
  ;; point outside the margin.
  ;;
  ;; There is one case where moving the point in this fashion may cause
  ;; a jump: if the point is placed inside one of the margins by another
  ;; method (e.g. left mouse click, or M-x goto-line) and then moved in
  ;; the normal way, the advice code will scroll the minimum number of
  ;; lines in order to keep the point outside the margin.  This jump may
  ;; cause some slight confusion at first, but hopefully it is justified
  ;; by the benefit of automatically ensuring `smooth-scroll-margin'
  ;; lines of context are visible around the point as often as possible.
  ;;
  ;;;_* TODO
  ;;
  ;; - Maybe add option to avoid scroll jumps when point is within
  ;;   margin.
  ;;
  ;;;_* Acknowledgements
  ;;
  ;; Thanks to Mark Hulme-Jones and consolers on #emacs for helping
  ;; debug issues with line-wrapping.
  ;;
  ;;;_* License
  ;;
  ;; Released under the GNU General Public License v2 or later, with
  ;; all rights assigned to the Free Software Foundation.
  ;;

  ;;;_* Code follows
  ;;;_ + disable `scroll-margin'
  (setq scroll-margin 0)
  ;;;_ + defcustoms
  (defcustom smooth-scroll-margin 10
    "Number of lines of visible margin at the top and bottom of a window.
  If the point is within these margins, then scrolling will occur
  smoothly for `previous-line' at the top of the window, and for
  `next-line' at the bottom.

  This is very similar in its goal to `scroll-margin'.  However, it
  is implemented by activating `smooth-scroll-down' and
  `smooth-scroll-up' advise via `defadvice' for `previous-line' and
  `next-line' respectively.  As a result it avoids problems
  afflicting `scroll-margin', such as a sudden jump and unexpected
  highlighting of a region when the mouse is clicked in the margin.

  Scrolling only occurs when the point is closer to the window
  boundary it is heading for (top or bottom) than the middle of the
  window.  This is to intelligently handle the case where the
  margins cover the whole buffer (e.g. `smooth-scroll-margin' set
  to 5 and `window-height' returning 10 or less).

  See also `smooth-scroll-strict-margins'."
    :type  'integer
    :group 'windows)

  (defcustom smooth-scroll-strict-margins t
    "If true, the advice code supporting `smooth-scroll-margin'
  will use `count-screen-lines' to determine the number of
  ,*visible* lines between the point and the window top/bottom,
  rather than `count-lines' which obtains the number of actual
  newlines.  This is because there might be extra newlines hidden
  by a mode such as folding-mode, outline-mode, org-mode etc., or
  fewer due to very long lines being displayed wrapped when
  `truncate-lines' is nil.

  However, using `count-screen-lines' can supposedly cause
  performance issues in buffers with extremely long lines.  Setting
  `cache-long-line-scans' may be able to address this;
  alternatively you can set this variable to nil so that the advice
  code uses `count-lines', and put up with the fact that sometimes
  the point will be allowed to stray into the margin."
    :type  'boolean
    :group 'windows)
  ;;;_ + helper functions
  (defun smooth-scroll-lines-from-window-top ()
    "Work out, using the function indicated by
  `smooth-scroll-strict-margins', what the current screen line is,
  relative to the top of the window.  Counting starts with 1 referring
  to the top line in the window."
    (interactive)
    (cond ((= (window-start) (point))
           ;; In this case, count-screen-lines would return 0, so we override.
           1)
          (smooth-scroll-strict-margins
           (count-screen-lines (window-start) (point) 'count-final-newline))
          (t
           (count-lines (window-start) (point)))))

  (defun smooth-scroll-lines-from-window-bottom ()
    "Work out, using the function indicated by
  `smooth-scroll-strict-margins', how many screen lines there are
  between the point and the bottom of the window.  Counting starts
  with 1 referring to the bottom line in the window."
    (interactive)
    (if smooth-scroll-strict-margins
        (count-screen-lines (point) (window-end nil t))
      (count-lines (point) (window-end nil t))))
  ;;;_ + after advice
  (defadvice previous-line (after smooth-scroll-down
                              (&optional arg try-vscroll)
                              activate)
    "Scroll down smoothly if cursor is within `smooth-scroll-margin'
  lines of the top of the window."
    (and
     ;; Only scroll down if there is buffer above the start of the window.
     (> (window-start) (buffer-end -1))
     (let ((lines-from-window-top
            (smooth-scroll-lines-from-window-top)))
       (and
        ;; Only scroll down if we're within the top margin
        (<= lines-from-window-top smooth-scroll-margin)
        ;; Only scroll down if we're in the top half of the window
        (<= lines-from-window-top
            ;; N.B. `window-height' includes modeline, so if it returned 21,
            ;; that would mean exactly 10 lines in the top half and 10 in
            ;; the bottom.  22 (or any even number) means there's one in the
            ;; middle.  In both cases the following expression will
            ;; yield 10:
            (/ (1- (window-height)) 2))
        (save-excursion
          (scroll-down
                (1+ (- smooth-scroll-margin lines-from-window-top))))))))

  (defadvice next-line (after smooth-scroll-up
                              (&optional arg try-vscroll)
                              activate)
    "Scroll up smoothly if cursor is within `smooth-scroll-margin'
  lines of the bottom of the window."
    (and
     ;; Only scroll up if there is buffer below the end of the window.
     (< (window-end) (buffer-end 1))
     (let ((lines-from-window-bottom
            (smooth-scroll-lines-from-window-bottom)))
       (and
        ;; Only scroll up if we're within the bottom margin
        (<= lines-from-window-bottom smooth-scroll-margin)
        ;; Only scroll up if we're in the bottom half of the window.
        (<= lines-from-window-bottom
            ;; See above notes on `window-height'.
            (/ (1- (window-height)) 2))
        (save-excursion
          (scroll-up
           (1+ (- smooth-scroll-margin lines-from-window-bottom))))))))
  ;;;_ + provide
  (provide 'smooth-scrolling)

  ;;;_* Local emacs variables

  ;;Local variables:
  ;;allout-layout: (0 : -1 0)
  ;;mode: allout
  ;;End:
#+end_src
#+begin_src emacs-lisp :padding no :mkdirp yes :tangle ~/.emacs.d/site-lisp/zoom-frm.el
  ;;; zoom-frm.el --- Commands to zoom frame font size.
  ;;
  ;; Filename: zoom-frm.el
  ;; Description: Commands to zoom frame font size.
  ;; Author: Drew Adams
  ;; Maintainer: Drew Adams
  ;; Copyright (C) 2005-2011, Drew Adams, all rights reserved.
  ;; Created: Fri Jan 07 10:24:35 2005
  ;; Version: 20
  ;; Last-Updated: Tue Jan  4 15:52:56 2011 (-0800)
  ;;           By: dradams
  ;;     Update #: 243
  ;; URL: http://www.emacswiki.org/cgi-bin/wiki/zoom-frm.el
  ;; Keywords: frames, extensions, convenience
  ;; Compatibility: GNU Emacs: 20.x, 21.x, 22.x, 23.x
  ;;
  ;; Features that might be required by this library:
  ;;
  ;;   `avoid', `frame-cmds', `frame-fns', `misc-fns', `strings',
  ;;   `thingatpt', `thingatpt+'.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Commentary:
  ;;
  ;;  Commands to zoom font size.
  ;;
  ;;  A few commands are provided for zooming a frame or buffer, so that
  ;;  its font becomes larger or smaller.  For example, bind `zoom-in'
  ;;  and `zoom-out' to mouse wheel events to get the zooming effect you
  ;;  are used to in a Web browser.
  ;;
  ;;  With Emacs 20, 21, and 22, you can zoom a frame.  Starting with
  ;;  Emacs 23, you can zoom either a frame (all buffers shown there) or
  ;;  a single buffer (in all frames where it is displayed).  User
  ;;  option `zoom-frame/buffer' determines which kind of zooming (frame
  ;;  or buffer) is done.  You can customize this option, but you can
  ;;  also toggle it just by providing a prefix arg (`C-u') to `zoom-in'
  ;;  or `zoom-out'.
  ;;
  ;;  Note on saving changes made with the commands defined here:
  ;;
  ;;    Some of the commands defined here change frame properties.  You
  ;;    can save any changes you have made, by using Customize.  To
  ;;    visit a Customize buffer of all unsaved changes you have made,
  ;;    use command `customize-customized'.
  ;;
  ;;    Frame parameter changes, such as font size, can be saved for
  ;;    future use by all frames or all frames of a certain kind.  For
  ;;    that, you must change the frame parameters of the correponding
  ;;    frame-alist variable.
  ;;
  ;;    There is no single variable for saving changes to parameters of
  ;;    the current frame.  Instead, there are several different
  ;;    frame-alist variables, which you can use to define different
  ;;    kinds of frames.  These include: `default-frame-alist',
  ;;    `initial-frame-alist', and `special-display-frame-alist'.  The
  ;;    complete list of such frame alist variables is available using
  ;;    function `frame-alist-var-names', defined in library
  ;;    `frame-cmds.el'.
  ;;
  ;;    Example: Suppose you change the font size of a frame and want to
  ;;    make that the default font size for new frames in the future.
  ;;    You will need to update the value of variable
  ;;    `default-frame-alist' to use the `font' parameter setting of the
  ;;    changed frame.
  ;;
  ;;    You can easily copy one or all parameter values from any given
  ;;    frame to any frame alist (such as `default-frame-alist'), by
  ;;    using the commands `set-frame-alist-parameter-from-frame' and
  ;;    `set-all-frame-alist-parameters-from-frame'.  Those commands are
  ;;    defined in library `frame-cmds.el'.
  ;;
  ;;
  ;;  Commands defined here:
  ;;
  ;;    `toggle-zoom-frame', `zoom-frm-in', `zoom-frm-out',
  ;;    `zoom-frm-unzoom', `zoom-in', `zoom-out'.
  ;;
  ;;
  ;;  User options (variables) defined here:
  ;;
  ;;    `frame-zoom-font-difference', `zoom-frame/buffer' (Emacs 23+).
  ;;
  ;;
  ;;  Put this in your init file (`~/.emacs'): (require 'zoom-frm)
  ;;
  ;;  Suggested key bindings:
  ;;
  ;;  (global-set-key (if (boundp 'mouse-wheel-down-event) ; Emacs 22+
  ;;                      (vector (list 'control mouse-wheel-down-event))
  ;;                    [C-mouse-wheel])    ; Emacs 20, 21
  ;;                  'zoom-in)
  ;;  (when (boundp 'mouse-wheel-up-event) ; Emacs 22+
  ;;    (global-set-key (vector (list 'control mouse-wheel-up-event))
  ;;                    'zoom-out))
  ;;
  ;;  (global-set-key [S-mouse-1]    'zoom-in)
  ;;  (global-set-key [C-S-mouse-1]  'zoom-out)
  ;;  ;; Get rid of `mouse-set-font' or `mouse-appearance-menu':
  ;;  (global-set-key [S-down-mouse-1] nil)
  ;;
  ;;  The first two of these mean that in Emacs 22 or later you can hold
  ;;  the Control key and rotate the wheel to zoom in and out, just as
  ;;  you do in your Web browser.  In Emacs 20 and 21, however, Control
  ;;  plus wheeling zooms in, but to zoom out you need to use `C--'
  ;;  before wheeling with Control.  This is because Emacs 20 and 21 do
  ;;  not have separate events for the mouse wheel directions, and it is
  ;;  the prefix arg, not the wheel direction, that determines the
  ;;  effect.
  ;;
  ;;  Note: You can bind the zooming commands to keyboard events, as
  ;;  well as to mouse events.  You could do this, for instance:
  ;;
  ;;  (global-set-key [(control shift ?z)]  'zoom-in)  ; `C-S-z'
  ;;  (global-set-key [(control ?z)]        'zoom-out) ; `C-z'
  ;;
  ;;
  ;;  See also these files for other frame commands:
  ;;
  ;;     `autofit-frame.el' - Automatically fit each frame to its
  ;;                          selected window.  Uses `fit-frame.el'.
  ;;
  ;;     `fit-frame.el'     - 1) Fit a frame to its selected window.
  ;;                          2) Incrementally resize a frame.
  ;;
  ;;     `doremi-frm.el'    - Incrementally adjust frame properties
  ;;                          using arrow keys and/or mouse wheel.
  ;;
  ;;     `frame-cmds.el'    - Miscellaneous frame and window commands.
  ;;
  ;;     `thumb-frm.el'     - Shrink frames to a thumbnail size and
  ;;                          restore them again.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Change Log:
  ;;
  ;; 2011/01/04 dadams
  ;;     Added autoload cookies for defgroup and defcustom.
  ;; 2010/07/06 dadams
  ;;     zoom-(in|out): Put doc strings before interactive spec.  Thx to Yidong Chong.
  ;; 2009/06/11 dadams
  ;;     Added buffer zooming, for Emacs 23.
  ;;       Added zoom-(in|out), group zoom, zoom-frame/buffer.
  ;; 2006/01/07 dadams
  ;;     Added :link for sending bug report.
  ;; 2006/01/06 dadams
  ;;     frame-zoom-font-difference: Changed :group to Frame-Commands. Added :link.
  ;; 2005/01/18 dadams
  ;;     Changed default value of frame-zoom-font-difference.
  ;;     Added Note on saving changes.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;; This program is free software; you can redistribute it and/or modify
  ;; it under the terms of the GNU General Public License as published by
  ;; the Free Software Foundation; either version 2, or (at your option)
  ;; any later version.

  ;; This program is distributed in the hope that it will be useful,
  ;; but WITHOUT ANY WARRANTY; without even the implied warranty of
  ;; MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
  ;; GNU General Public License for more details.

  ;; You should have received a copy of the GNU General Public License
  ;; along with this program; see the file COPYING.  If not, write to
  ;; the Free Software Foundation, Inc., 51 Franklin Street, Fifth
  ;; Floor, Boston, MA 02110-1301, USA.
  ;;
  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;
  ;;; Code:

  (require 'frame-cmds) ;; enlarge-font

  ;;;;;;;;;;;;;;;;;;;;;;;;




  ;;; USER OPTIONS (VARIABLES) ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  ;;;###autoload
  (defgroup zoom nil
    "Zoom a frame or buffer."
    :group 'frames :group 'Frame-Commands ; Defined in `frame-cmds.el'.
    :link `(url-link :tag "Send Bug Report"
            ,(concat "mailto:" "drew.adams" "@" "oracle" ".com?subject=\
  zoom-frm.el bug: \
  &body=Describe bug here, starting with `emacs -q'.  \
  Don't forget to mention your Emacs and library versions."))
    :link '(url-link :tag "Other Libraries by Drew"
            "http://www.emacswiki.org/cgi-bin/wiki/DrewsElispLibraries")
    :link '(url-link :tag "Download"
            "http://www.emacswiki.org/cgi-bin/wiki/zoom-frm.el")
    :link '(url-link :tag "Description"
            "http://www.emacswiki.org/cgi-bin/wiki/SetFonts#ChangingFontSize")
    :link '(emacs-commentary-link :tag "Commentary" "zoom-frm"))

  ;;;###autoload
  (defcustom frame-zoom-font-difference 1
    "*Number of points to change the frame font size when zooming
  using commands `zoom-frm-in' and `zoom-frm-out'.
  The absolute value of this must be less than the current font size,
  since the new font size cannot be less than 1 point."
    :type 'integer :group 'zoom)

  (when (> emacs-major-version 22)
    (defcustom zoom-frame/buffer 'frame
      "*What to zoom: current frame or current buffer.
  See commands `zoom-in' and `zoom-out'."
      :type '(choice (const :tag "Zoom frame"  frame) (const :tag "Zoom buffer" buffer))
      :group 'zoom))


  ;;; FUNCTIONS ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

  (unless (> emacs-major-version 22) (defalias 'zoom-in 'zoom-frm-in))
  ;;;###autoload
  (defun zoom-frm-in (&optional frame flip)
    "Zoom FRAME in by `frame-zoom-font-difference', making text larger.
  If `frame-zoom-font-difference' is negative, make text smaller.
  With prefix argument FLIP, reverse the direction:
  if `frame-zoom-font-difference' is positive, then make text smaller.
  This is equal but opposite to `zoom-frm-out'."
    (interactive (list (selected-frame) current-prefix-arg))
    (setq frame (or frame (selected-frame)))
    (let ((zoom-factor (frame-parameter frame 'zoomed))
          (increment (if flip (- frame-zoom-font-difference) frame-zoom-font-difference)))
      (unless zoom-factor (setq zoom-factor 0))
      (setq zoom-factor (+ zoom-factor increment))
      (enlarge-font increment frame)
      (modify-frame-parameters frame (list (cons 'zoomed zoom-factor)))))

  (unless (> emacs-major-version 22) (defalias 'zoom-out 'zoom-frm-out))
  ;;;###autoload
  (defun zoom-frm-out (&optional frame flip)
    "Zoom FRAME out by `frame-zoom-font-difference'.
  If `frame-zoom-font-difference' is negative, make text larger.
  With prefix argument FLIP, reverse the direction:
  if `frame-zoom-font-difference' is positive, then make text larger.
  This is equal but opposite to `zoom-frm-in'."
    (interactive (list (selected-frame) current-prefix-arg))
    (setq frame (or frame (selected-frame)))
    (let ((frame-zoom-font-difference (- frame-zoom-font-difference)))
      (zoom-frm-in frame flip)))

  ;;;###autoload
  (defun zoom-frm-unzoom (&optional frame)
    "Cancel zoom of FRAME."
    (interactive)
    (setq frame (or frame (selected-frame)))
    (let ((zoom-factor (frame-parameter frame 'zoomed)))
      (if (not zoom-factor)
          (error "Frame is not zoomed")
        (enlarge-font (- zoom-factor) frame)
        (modify-frame-parameters frame '((zoomed))))))

  ;;;###autoload
  (defun toggle-zoom-frame (&optional frame)
    "Alternately zoom/unzoom FRAME by `frame-zoom-font-difference'."
    (interactive)
    (setq frame (or frame (selected-frame)))
    (if (frame-parameter frame 'zoomed)
        (zoom-frm-unzoom frame)
      (zoom-frm-in frame)))

  (when (> emacs-major-version 22)
    (defun zoom-in (arg)
      "Zoom current frame or buffer in.
  With a prefix arg, toggle between zooming frame and zooming buffer.
  Frame zooming uses command `zoom-frm-in'.
  Buffer zooming uses command `text-scale-increase'."
      (interactive "P")
      (when arg
        (setq zoom-frame/buffer  (if (eq zoom-frame/buffer 'frame) 'buffer 'frame)))
      (if (eq zoom-frame/buffer 'frame)
          (zoom-frm-in)
        (with-current-buffer
            (if (string-match "mouse" (format "%S" (event-basic-type
                                                    last-command-event)))
                (window-buffer (posn-window (event-start last-command-event)))
              (current-buffer))
          (text-scale-increase 1))))

    (defun zoom-out (arg)
      "Zoom current frame or buffer out.
  With a prefix arg, toggle between zooming frame and zooming buffer.
  Frame zooming uses command `zoom-frm-out'.
  Buffer zooming uses command `text-scale-decrease'."
      (interactive "P")
      (when arg
        (setq zoom-frame/buffer  (if (eq zoom-frame/buffer 'frame) 'buffer 'frame)))
      (if (eq zoom-frame/buffer 'frame)
          (zoom-frm-out)
        (with-current-buffer
            (if (string-match "mouse" (format "%S" (event-basic-type
                                                    last-command-event)))
                (window-buffer (posn-window (event-start last-command-event)))
              (current-buffer))
          (text-scale-decrease 1)))))

  ;;;;;;;;;;;;;;;;;;;;;;;;;

  (provide 'zoom-frm)

  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
  ;;; zoom-frm.el ends here
#+end_src

* Xsessions settings
#+begin_src text :tangle ~/.xsession
# You may need to comment out the next line to disable access control.
xhost +SI:localuser:$USER
eval $(ssh-agent)

# dropbox start
# dropboxd

# Set themes, etc.
# gnome-settings-daemon &

# Set fallback cursor.
xsetroot -cursor_name left_ptr

# Set keyboard repeat rate.
xset r rate 200 60

source "$HOME/.guix-profile/etc/profile"
source "$HOME/.config/guix/current/etc/profile"

GUIX_PROFILE="/home/bonface/.guix-profile"
. "$GUIX_PROFILE/etc/profile"

export SSL_CERT_DIR="$HOME/.guix-profile/etc/ssl/certs"
export SSL_CERT_FILE="$HOME/.guix-profile/etc/ssl/certs/ca-certificates.crt"
export GIT_SSL_CAINFO="$SSL_CERT_FILE"

# shepherd

# If Emacs is started in server mode, `emacsclient` is a convenient way to
# edit files in place (used by e.g. `git commit`).
export VISUAL=emacsclient
export EDITOR="$VISUAL"

#setxkbmap -model asus_laptop -layout us -variant dvp -option caps:ctrl_modifier
setxkbmap -layout us -variant dvp -option ctrl:nocaps

# Finally launch emacs.
export XDG_SESSION_TYPE=x11
export GDK_BACKEND=x11
nm-applet &
volumeicon &
# exec gnome-session --session=/usr/bin/emacs
# exec dbus-launch --exit-with-session emacs
xbindkeys

# Keyboard repeat rate
xset r rate 200 60

# Default backlight
xbacklight -set 50

gpg-agent --daemon

# Start gnus
# emacs -Q  --batch -l ~/.gnus.el -f gnus

exec dbus-launch emacs
#+end_src
#+begin_src text :tangle ~/.xinitrc
# You may need to comment out the next line to disable access control.
xhost +SI:localuser:$USER
eval $(ssh-agent)

# dropbox start
# dropboxd

# Set themes, etc.
# gnome-settings-daemon &

# Set fallback cursor.
xsetroot -cursor_name left_ptr

# Set keyboard repeat rate.
xset r rate 200 60

source "$HOME/.guix-profile/etc/profile"
source "$HOME/.config/guix/current/etc/profile"

GUIX_PROFILE="/home/bonface/.guix-profile"
. "$GUIX_PROFILE/etc/profile"

export SSL_CERT_DIR="$HOME/.guix-profile/etc/ssl/certs"
export SSL_CERT_FILE="$HOME/.guix-profile/etc/ssl/certs/ca-certificates.crt"
export GIT_SSL_CAINFO="$SSL_CERT_FILE"

# shepherd

# If Emacs is started in server mode, `emacsclient` is a convenient way to
# edit files in place (used by e.g. `git commit`).
export VISUAL=emacsclient
export EDITOR="$VISUAL"

#setxkbmap -model asus_laptop -layout us -variant dvp -option caps:ctrl_modifier
setxkbmap -layout us -variant dvp -option ctrl:nocaps

# Finally launch emacs.
export XDG_SESSION_TYPE=x11
export GDK_BACKEND=x11
nm-applet &
volumeicon &
# exec gnome-session --session=/usr/bin/emacs
# exec dbus-launch --exit-with-session emacs
xbindkeys

# Keyboard repeat rate
xset r rate 200 60

# Default backlight
xbacklight -set 50

gpg-agent --daemon

# Start gnus
# emacs -Q  --batch -l ~/.gnus.el -f gnus

exec dbus-launch emacs
#+end_src
* GHCI
[[https://wiki.haskell.org/GHC/GHCi][GHCi- Haskell Wiki]]
#+begin_src haskell :tangle ~/.ghci
-- Base:
-- Turn off output for resource usage and types.  This is to reduce verbosity when reloading this file.
:unset +s +t
-- Turn on multi-line input and remove the distracting verbosity.
:set +m -v0
-- Turn off all compiler warnings and turn on OverloadedStrings for interactive input.
:seti -w -XOverloadedStrings

-- Use :rr to reload this file.
:def! rr \_ -> return ":script ~/.ghci"
-- Turn on output of types.  This line should be last.
:set +t

-- Fancy prompts
:{
dotGHCI_myPrompt promptString ms _ = do
  -- Get the current directory, replacing $HOME with a '~'.
  pwd <- getpwd
  -- Determine which is the main module.
  let main_module = head' [ m' | (m:m') <- ms, m == '*' ]
  -- Put together the final prompt string.
  -- ANSI escape sequences allow for displaying colours in compatible terminals.  See [http://www.lihaoyi.com/post/BuildyourownCommandLinewithANSIescapecodes.html this guide] for help interpreting them.
  return $ concat [ "\STX\ESC[33m", pwd, main_module, "\ESC[37m", promptString, " \ESC[0m\STX" ]
  where
    head' (x:_) = " \ESC[38;5;227m" ++ x
    head' _     = ""
    getpwd = getpwd' <$> System.Environment.getEnv "HOME" <*> System.Directory.getCurrentDirectory
    getpwd' home pwd = if zipWith const pwd home == home
                         then '~':drop (length home) pwd
                         else pwd
:}
:set prompt-function dotGHCI_myPrompt "\ESC[38;5;129m λ "
:set prompt-cont-function dotGHCI_myPrompt "∷"

-- Setup hlisnt and hoogle
dotGHCI_escapeShellArg arg = "'" ++ concatMap (\c -> if c == '\'' then "'\\''" else [c]) arg ++ "'"
:def! hoogle return . (":!hoogle -q --count=15 --color " ++) . dotGHCI_escapeShellArg
:def! search return . (":!hoogle -q --count=3 --color " ++) . dotGHCI_escapeShellArg
:def! doc return . (":!hoogle -q --color --info " ++) . dotGHCI_escapeShellArg
:def! hlint \s -> return $ ":!hlint " ++ if null s then "." else s

-- lambda bot
dotGHCI_escapeShellArg arg = "'" ++ concatMap (\c -> if c == '\'' then "'\\''" else [c]) arg ++ "'"
lb s1 s2 = return $ ":!lambdabot -n -e " ++ dotGHCI_escapeShellArg s1 ++ "\\ " ++ dotGHCI_escapeShellArg s2
:def! lb lb ""                   -- runs arbitrary lambdabot commands
:def! pl lb "pl"                 -- converts code to point-free (aka pointless) form
:def! unpl lb "unpl"             -- converts back from point-free (aka pointless) form
:def! do lb "do"                 -- converts binds to do notation
:def! undo lb "undo"             -- converts do blocks to bind notation
:def! index lb "index"           -- finds the module that defines the given identifier
:def! instances lb "instances"   -- finds all instances of a given type class
:def! src lb "src"               -- tries to find the source code for the given identifier
:def! oeis lb "oeis"             -- looks up the On-Line Encyclopedia of Integer Sequences (https://oeis.org/)
#+end_src
